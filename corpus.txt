[{'name': '2021-02-18 -- Chapter II.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Chapter II: The Recording Process Objective The accounting cycle in general (especially for service giving organizations)  Accounting Cycle  The main way to know that a transaction has occurred is by the source document (source documents being invoices, receipts etc.) and then you journal such transactions with a book of original (initial) entry. Then you POST to the individual accounts to something known as a ledger (a book of secondary entry). We then prepare a form called a Trial balance (also known as pre-closing trial balance) whose purpose is to prove the equality of the ledger. After that, we then prepare a paper called a worksheet. After performing adjustments of the worksheet, we prepare a financial statement. After the creation of the statement, we prepare the closing (ሂሳብ መዝጋት). After that we create the post-closing trial balance.  The Account An account is an individual accounting record of increases and decreases in a specific asset, liability, or owner’s equity item. The simplest form of an account is called a “T” account. There are separate accounts for the items we use in transactions such as cash, salaries expense, accounts payable, etc. The simple form works like: Title, Left side (debit side) Right side (credit side) Debits and Credits Debit indicates left and credit indicates right  Double Entry System Equal debits and credits made accounts for each transaction Meaning there must be an equal credit entry for every debit entry. Total debits always equal the total credits Normal Balance When an amount is written or entered on the debit side of an account, we read as “that account has been debited”. When the amount is entered to the credit side, we read as “the account has been credited” For variables appearing before the = sign, their balance side is the left side.   Revenues increase capital so the increase side is the right side just like capital Expenses decrease capital so their balance side is the left side. Owner’s Drawing is left side because it subtracts from capital.  Nature and classification of accounts Classification of accounts There are five major classifications: Assets Current assets Assets expected to be turned into cash within a short time. Ex. Cash, A/R, Inventories, prepayments. Non-current assets (plant assets) Long term assets expected to be used within a year or so. Liabilities Current liabilities Liabilities expected to be settled within a year. Ex. A/P, salary payable, rent payable, etc. Non-current liabilities Liabilities expected to take more than a year to settle like bank loans, Bonds payable, mortgage Notes payable (NS/Pay), loans payable (back loans), etc. Capital - Can be known as shareholders’/stockholders’ equity for corporations. Revenue Expenses Chart of Accounts Are a listing of all accounts according to their codes. If an account code starts with 1, then it is an asset account If an account code starts with 2, then it is a liability account. … If an account code starts with 4, then it is a revenue account. If an account code starts with 5, then it is an expense account. If an account code starts with 11, then it is an cash (asset type) account. The Recording Process Analyze each transaction (+, -) Before recording transactions, first it must be analyzed by answering the following 3 questions. Identify the accounts affected Determine the effect of the transaction on the accounts affected. Determine the accounts to be debited and credited (apply the rules of debit and credit) Enter transaction in a journal Journal A journal is a document used to record transactions for the first time. The transfer should be recorded in a chronological order. There are two types of journals: General journal A journal used to record all types of transactions  in a chronological order. Special journal A journal used to record a specific type of transaction. 4 types: Sales journal Used to record sales of goods or merchandises only on account. Purchase journal Used to record purchase of goods only on credit Cash payment journal Used to record payment of cash for any reason. Cash received journal Used to record collection of cash from any source A journal makes several contributions to the recording process: Discloses in one place the complete effect of a transaction  Provides a chronological record of transactions Helps to prevent or locate errors.  Next class: Journalizing.  '}, {'name': '2021-04-01 -- Transportation Cost.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Transportation Cost FOB – Shipping Point The seller should handle transportation cost FOB – Destination Point The buyer should handle transportation cost  Example: Assume ABC Co. purchased merchandises costing Br 15,000, terms 2/10, n/20 @ FOB shipping point agreement. The company also paid the freight cost of Br 500 to the shipping company. Assume also that ABC Co. settled its liability in relation to the purchase within the discount period Required: Record journal entry on the date of purchase and date of payment:  Example 2: Assume XZY Co. sold Merchandises amounting to Br 40,000 terms 1/10, n/30 @FOB Shipping point agreement. On the date of sale, XYZ Co (the seller) paid a transportation cost of Br 1,000 and charged to the buyer’s invoice. On Jan 15, 2021 the buyer returned some of the merchandises costing Br 5,000, being defective. On Jan 19, 2021 received cash from the buyer for the merchandises sold on Jan 10. Required: Record the necessary journal entries in the accounting records of both the buyer and the seller.  XYZ Co.   Adjustment for Merchandise Inventory Types of merchandise inventory accounts Beginning MI (BMI) The inventory balance available at the beginning of the period Is a temporary account (should be closed at the end of the accounting period) Ending MI (EMI) The inventory balance available at the end of the period Is a permanent account (should be reported in the balance sheet as an asset) Adjustment for MI involves the following: Adjustment for BMI: Means closing the BMI against the income summary account. Income summary account will be debited and its offsetting credit will be the merchandise inventory account Adjustment for EMI: Means recording the merchandise inventory balance against the income summary account. You debit income summary account and credit income summary account.  Income Statement of Merchandising Companies There are two types of income statements for merchandising companies Single Step IS By its nature, it is a more summarized type of income statement. It is reported as follows: Net Sales -------------- -------------------------- $$$ Less: Cost of merchandises sold (CMS) ------- $$$ Gross profit \t-------------------------------------     $$$ Less: Total operating expenses -----------------($$$) NI/NL -------------------------------------------------$$$$$$ Multiple Step IS It is a more detailed type of income statement Sales  -----------------------------------------------------$$$ Less: SRA ------------------------------------------------$$$ SD ---------------------------------------------------------$$$ Net Sales ------------------------------------------------------$$$$ Less: Cost of Merchandises sold (CMS) ----------$$$ Beg. MI ---------------------------------------------------$$$ Less PD ---------------------------------------------------$$$ PRA --------------------------------------------------------$$$ Net Purchase -------------------------------------------------$$$$$ Add: Freight Cost ---------------------------------------$$$ Cost of Merchandises Purchased -------------------$$$ Cost of merchandises available for sale -----------$$$ Less: EMI --------------------------------------------------$$$ CMS --------------------------------------------------------------$$$$$ Gross profit ----------------------------------------------$$$ Less: Operating expenses ----------------------------$$$ General and administration expense -------------$$$ Selling expenses ---------------------------------------$$$ Total operating expenses --------------------------------$$$$$$ NI ---------------------------------------------------------------$$$$$$  Important formulae:          Class Work Sales ----- 860,000 \t\t\tMerchandises Inv. In Jan 1 ----- 85,000 SRA -------5,000\t\t\tMerchandise Inv. Dec 31 --------75,000 SD ---------3,000\t\t\tGeneral and Admin Exp. ---------30,000 Purchase-620,000\t\t\tSelling Expenses -------------------50,000 PD --------10,000 PRA -------5,000 Freight In 8,000  Required:  Calculate: NS NP CMAFS CMS GP NI Record the necessary closing entries adjusting entries for merchandise inventory accounts.   '}, {'name': '2021-02-20 -- Journalizing.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Journalizing Entering transaction data in the journal is known as journalizing Separate journal entries are made for each transaction. Journalizing refers to the process of recording transactions in a journal. Format of General Journal: Before transactions are recorded in a journal, first it must be analyzed as follows:(repeat from last class) What are the accounts affected? Determine the effects on each of the accounts affected. Determine the accounts to be debited and credited Ex. Mr. X purchased computers (office equipment) costing birr 100,000 by paying 50% up front and promising to pay the remaining within one month on January 5, 2021. Accounts Affected: Cash, Accounts Payable, Office Equipment Account Effects: Cash decreases, Accounts Payable increases, and Office Equipment increases Accounts to be Debited and Credited: Debit: Office Equipment  Credit: Accounts Payable, Cash Journal Entry  refers to each debit and credit recorded at the journal journal entries have two types: Single entry: involves only two accounts Compound entry: involves more than two accounts. The Ledger A group of accounts maintained by a company is called a ledger. A general ledger contains all of the owner’s equity accounts. Posting – the process of transferring transactions from a journal to a ledger. There are 4 types of ledger accounts A “T” account A Two Column account A Three Column account A Four Column account (recommended) '}, {'name': '2021-02-25 -- The Ledger.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'The Ledger A group of accounts maintained by a company is called the ledger. A general ledger contains all the assets, liabilities and owner’s equity accounts. Overdraft is an account that has withdrawn more than it has. Trial Balance The trial balance is a form which is used to prove the equality of debit and credit in the ledger. The trial balance is a list of accounts and their balances at a given time. Errors in accounting \n Slide error Related to adding or removing digits Ex. 1000 ---- 10,000 10,000 ------ 100,000  10.956 ----- 105.96 Transposition error Confusing the value of certain accounts by messing up the numbers inside a l Ex. 4594 ------ 4954 The trial balance detects the slide and transposition errors. Limitations of Trial Balance A trial balance does not prove all transactions have been recorded or the ledger is correct Numerous errors may exist even though the trial balance columns agree. For example, the trial balance may be balanced even when: A transaction is not journalized A correct journal entry is not posted A journal entry is posted twice Incorrect accounts used in journalizing or posting Offsetting errors are made in recording Posting to the correct side but to the wrong account Worksheet A worksheet is an accountant’s working paper. It is not a permanent record (meaning it is temporary) Worksheet facilitates the preparation of a financial statement Consists of the following parts: Trial balance Adjustment Adjusted trial balance Income statement  Balance sheet Adjustment A journal entry made at the end of the accounting period to bring the updated balance of some accounts is known as adjusting entries. Adjustments are required for: Deferrals Deferred expenses – expenses paid in advance Unearned revenues – revenues collected in advance Accruals Accrued expenses – expenses incurred but not yet paid Accrued revenues – revenues earned but not yet collected and recorded Next class: Deferrals '}, {'name': '2021-02-11 -- Stickies copy.txt', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'CC (accounting)\nRead the advantages and disadvantages of each forms of business organizations\n\nAdvantages\n- It’s easy to form in comparison to the others… the only thing required by the proprietor is the capital/money.\nDisadvantages\n- It’s difficult to raise the required capital\n\n02-16-2021\n'}, {'name': '2021-02-11 -- Accounting Principles and Concepts.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Accounting Principles and Concepts Basic Principles Basic Assumptions All principles and concepts are set by International Financial Reporting Standards (IFRS) Basic Principles Cost principle (Historical cost principle) Means that anything we acquire should be acquired at cost. (as in it shouldn’t be recorded at estimated value) Fair value principles We give recognition to the market  Meaning any item we acquire should be recorded based on its market value. Revenue recognition principle (a measurement principle) Revenue is recognized when it is earned Expense recognition principle (a measurement principle) Expense should be recognized immediately on incurrence. Full disclosure principle Providing additional information to the F/s Basic Assumptions Business (economic) entity concept Business transactions should be maintained separately from the owner. Going concern Refers to the continuity of the business You should assume that your business will be operational for an indefinite period of time. Periodicity assumption You should measure the performance of the business periodically. (monthly preferred but can be measured quarterly, semi-annually and annually). Monetary unit assumption To have a place in accounting, each item should be expressed in terms of common monetary value. (the focus of accounting is more quantitative than qualitative) Accrual concept. It states that all business organizations should follow accrual concept. Accrual concept states the following (with regard to revenue) Revenues should be recorded when it is earned, regardless of whether cash is received or not. Expenses should be recorded when it is incurred, regardless of whether cash is paid or not. Business Transactions and BAE Business transactions: Are events or occurrences that affect the BAE. Every transaction affects at least two accounts from the BAE. Ex. Suppose Mr. X established a sole proprietorship type of business called XYZ Taxi on Jan 1, 2021. During the first month of its operation (in the month of January) the following transactions were occurred. Transactions: Mr. X deposited birr 300,000 in a bank account opened by the name of the business. The business purchased 2 taxis for 100,000 each for cash. Mr. X purchased land as a future building site for cash of birr 25,000. The business purchased supplies costing birr 850 on account (on credit). The business paid creditors on account amounting birr 400 The business received cash of birr 45,000 from the service revenue earned from cash customers. The following expenses were incurred and paid during the month: Salary expense – 12,000 Rent expense – 8,500 Utilities – 1,500 Miscellaneous – 2,000 Total = 24,000 The business charged customers for the transporting services provided on account amounting birr 20,000 The business received cash of birr 15,000 from customers on account Mr. X, the owner, withdrew cash of birr 10,000 for personal purpose. At the end of the month, the fiscal count report shows that supplies left on hand amounts to birr 20  Required Analyze the effect of each transaction on the basic accounting equation. Prepare the necessary financial statements using the transactions given above: Supplies are consumables (like stationary materials or oil in terms of the taxi company).  '}, {'name': '2021-03-04 -- Closing.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Closing It is the process of transferring the temporary account balance to permanent account. In other words, it is the process of making the temporary account balance to be 0. Accounts are classified into: Temporary accounts/nominal accounts Permanent accounts/real accounts All balance sheet accounts are permanent accounts Balance sheet accounts: Assets Liabilities Capital All income statement accounts are temporary accounts Income statement accounts: Revenues Expenses All withdrawal/dividend accounts should be closed at the end of the period An income summary account is an account used as a bridge to transfer the summary of revenue and expenses to a capital account. By its nature, an income summary account has no balance side; rather, its balance side depends on the amount of revenue and expenses An income summary accounts debit side is the expenses and the credit side is the revenue How do we close nominal accounts (what should the closing procedures be)? To close all revenue and income accounts,  we debit revenue and credit income summary account.  To close expense accounts We debit income summary account and credit expenses account To close the income summary account  If revenue is greater than expenses then income statement will have a credit balance, but if the revenues are less than the expenses then the income statement will have a debit balance To close drawing/withdrawal account We debit capital and credit the drawing account To close an income summary with a credit balance debit summary account and credit capital. (?) Post-Closing Trial Balance A trial balance prepared using only permanent accounts after the closing entries have been posted  '}, {'name': '2021-04-08 -- Accruals and Deferrals.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Accruals (NEED TO WRITE DEFERRALS) Deferrals: expenses that are paid in advance but not yet incurred The concept of accruals are exactly opposite to that of deferrals They are services rendered but not yet paid Accrual Expenses Are expenses incurred but not yet paid and recorded Are liabilities Accrual Revenues Are revenues earned but not yet collected and recorded Are assets by nature Deferrals Payment comes before incurrence of expenses (essentially prepaid expenses) Collection of cash comes before earning of revenue (essentially deferred revenues) Accruals Incurrence of expenses comers before payment (accrued expenses) The exact opposite of deferred expenses Earning of revenue comes before collection of cash The exact opposite of deferred revenues In recording adjustment for accrued expenses, we debit the expense account and credit the liability account   In recording adjustment for accrued revenues, we debit the asset account (receivable account) and credit revenue account . Example: Suppose ABC Company pays a weekly salary of birr 60,000 on every Saturday. The number of working days in a week is assumed to be 6 days. Assume also that the last payday (Saturday) falls on the 27th of December.  Required:  Record the necessary adjusting entry on Dec 31st assuming the accounting period ends on that date. Record the necessary journal entry on the salary payday    \tWeekly Salary =  Accrued expenses =  Example for Accrued Revenues Assume fees earned but not collected amounted to Birr 2,500 at the end of the year. Record the necessary adjusting entry for the accrued revenue  Reversing Entries Reversing entries are the exact reversal of adjusting entries If adjusting entry was: salary expense debit, salary payable credit. Then the reversing entry would be salary payable debit and salary expense credit Reversing entry is an optional entry If the company has a policy of recording R.E:  We need RE only if  The deferred expenses are initially recorded as an expense Deferred revenues are initially recorded as revenue For all accruals, we need reversing entry We don’t need RE if deferrals are initially recorded as an asset and as liabilities  Example: Assume XYZ Company paid Birr 360,000 as an advance payment for 3 years building rent on January 1st 2020. The accounting period ends on December 31st. Required: By employing the system of initially recording the advance payments as an asset.  record the date of entry on date of payment.  Record the necessary adjusting entry on Dec 31.  Record the necessary closing entry Record the reverse entry if appropriate By employing the system of initially recording the advance payments as an expense, answer the requirements listed under item (a) above.    a: No RE is required because   B:  '}, {'name': '2021-02-13 -- Financial Statements.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Financial Statements Income Statement – A summary of the revenue and expenses for a specific period of time. All financial statements have two parts Heading parts Name of the Company Type of financial statement Date or duration Body part  Statement of owner’s equity – A summary of the changes in the owner’s equity that have occurred during a specific period of time.   Balance sheet (statement of financial position) – A list of assets, liabilities, and owner’s equity as a specific date. Forms of balance sheet Account form Lists assets on the left side and liabilities and capital on the right. Report form All assets, liabilities and capitals vertically Statement of cash flows – A summary of the cash receipts and disbursements for a specific period of time. From Operating Activities – reports a summary of cash receipts and cash payments from operations  From Investing Activities – reports cash received from sale of fixed assets (if any) minus cash paid for purchase of fixed assets From Financing Activities -  cash received from the owner in form of investment and cash paid to owner in the form of withdrawal. XYZ Taxi Income Statement For the Month ended January 2021   XYZ Taxi Statement of Owner’s Equity For the Month ended January 2021  XYZ Taxi Balance Sheet January 2021  XYZ Taxi Statement of Cash Flows For the Month ended January 2021  '}, {'name': '2021-04-10 -- Chapter Five.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Chapter Five Accounting for Manufacturing Companies  The purpose of Manufacturing Companies is to buy raw materials to sell finished goods. Costs Anything incurred during the production of the good or service to get the output into the hands of the customer The customer could be the public (the final consumer) or another business Controlling cost is essential to business success Meaning of Cost and Cost Accounting The term ‘cost’ has a wide variety of meanings. Different people use this term in different senses for different purposes. For example, while buying a book, you generally ask, “how much does it cost”? here the cost means the price. The amount of expenditure incurrent on or attributable to a given thing Costing is the technique and process of ascertaining costs. In simple words, …. Objects and Meaning of Cost Accounting Analysis and Ascertainment of costs: The main object of costing is to ascertain the cost of each product, process and department, service or operation Presentation of costs for cost reduction and cost control: important function of costing is to control and reduce costs. Concept of Cost The “cost” refers to expenditure not the price of any good It’s the process of ascertaining cost (its principles and rules) Definition of Cost Accounting “The process of accounting for cost from the point at which expenditure is incurred or committed to the establishment of its ultimate relationship with cost center and cost units”.  Costs are classified into two: Manufacturing cost: Manufacturing costs are costs that are incurred to make a given product and includes direct material, direct labor and overhead cost Non-manufacturing cost:   Manufacturing Cost Classifications There are three major types of costs: Direct material cost Are raw materials that are an integral part of the product and that can be conveniently traced to the product. Direct labor cost Are labor costs that can be easily traced to individual units of product. Manufacturing overhead cost  Manufacturing costs that cannot be traced directly to specific units produced Example:  Indirect labor and indirect materials Other expenses or factory burden Wages paid to employees who are not directly involved in production work (like maintenance workers, janitors and security guards) Indirect materials being materials used to support the production process (like lubricants and cleaning supplies used in the automobile assembly point).  The sum of direct material and direct material costs is called “Prime cost”   The sum of direct labor and manufacturing overhead is called “Conversion Cost”    Non-Manufacturing Costs Marketing or Selling Costs Costs necessary to get the order and deliver the product Administrative Costs All executive, organizational and clerical costs. Costs Direct costs: Costs that can easily and conveniently be traceable to a specific product are commonly known as direct costs Indirect costs: Costs that cannot be easily and conveniently traceable to a given product are commonly known as indirect costs Costs are also further classified into product cost and period cost Product costs: Are manufacturing costs Include direct materials, direct labor and manufacturing overhead Period costs Are non-manufacturing costs Include all marketing or selling costs and administrative costs Costs can also be classified into variable costs and fixed costs Variable cost: Are costs that will vary in a direct proportion to sales volume. Example: material cost, labor cost Fixed cost: These are costs that will remain constant regardless of your volume of operation or activity for a given relevant range. Example: depreciation cost Comparing Merchandising and Manufacturing Companies Merchandisers buy finished goods while manufacturing companies buy raw materials Both merchandisers and manufacturers sell finished goods/products.   Next class: Statement of Cost of Goods Manufactured '}, {'name': '2021-03-27 -- Chapter 3.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Chapter 3 Accounting for Merchandising Businesses What are merchandises? Goods purchased for resales What are merchandise inventories Asset items (goods) held for sale What are purchases? Is an account which is used to record the purchase of merchandise What are sales? They’re an account used to record sales of merchandises What is an Inventory Accounting System? There are two types: Periodic Inventory System Under this approach, there is no continuous record for inventory on hand. The inventory on hand and sold can only be determined by physical counting Merchandises purchased are recorded as purchases. At the time of sale, only sales is recorded. Perpetual Inventory System There is a continuous record for the inventory purchase and sale The inventory on hand and sold can be determined (known) by the accounting record without a physical count Inventory purchases are recorded as merchandise inventory and not as a purchase. At time of sale, both the merchandise sold and the cost will be recorded Recording Purchase and Sales Transactions: Recording cash purchase/sales: Example: XYZ Co. purchased merchandises costing Br 10,000 for cash from ABC Co.  The buyer records the merchandises as a purchase The seller records the merchandises as a sale Recording credit purchase/sales: Credit Terms The conditions under which the sales/purchases are made on credit Credit terms include: Credit period Discount terms Ex.  One-ten n-30 1 = discount rate = 1% 10 = discount period = 10 days N = net 30 = credit period = 30 days  -> implies that if a customer is able to pay within 10 days, they will get a 1% discount; otherwise, they have to pay the net amount within 30 days Types of Discounts There are two types of discounts Trade discount Means it is a reduction from the list (catalog) price Ex. ABC Co. sold merchandises for 20,000, subject to 10% Trade discount Sales price = 20,000 – (10% x 20,000)  \t         = 18,000  Cash discount  Means it is a reduction from the sales price that is allowed to the customer to encourage early payment. The cash discount is recorded as: Purchase discount (PD) for the buyer Sales discount (SD) for the seller Example:  On Jan 10, 2019 ABC purchased merchandises costing Br 20,000, terms  from XYZ Co. On Jan 19, 2019 ABC Co. paid to XYZ Co. for the purchased merchandises on Jan 10.     Return and Allowance: Return: Means to physically return merchandises that are defective (could be wrong color or wrong model or whatever) Allowance: Refers to claiming a price reduction due to a defect in merchandises Both the return and allowance are recorded as: Purchase Return & Allowance (PRA) -> by the purchaser (buyer) Is a contra purchase account.  Sales Return & Allowance (SRA) -> by the seller Is a contra sales account.  Example On Sep 5, 2020, XYZ Company Purchased Merchandises costing Br 40,000, terms , from the seller Co. On Sep 9, 2020 returned some of the merchandises costing Br 5,000 due to being defective On Sep 15, 2020 the buyer paid to the seller for the purchase made on Sep 5. XYZ Co Seller Co.  Example 2: Assume all the facts are given in Ex 1 above. But now assume that the merchandises were returned on Sep 20, rather than Sep 9 Seller Co. XYZ Co.  Recording Sales Tax (VAT) Example: ABC Co. Sold merchandises amounting Br 10,000, subject to 15% VAT.  Example: ABC Co. Sold merchandises for a VAT inclusive price of Br 23,000 for cash  Next Class: Transportation Cost '}, {'name': '2021-03-06 -- Class Work.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Class Work    290,000 - 160,000 = 200,000 – 140,000 + a + 95,000 – 80,000 – 20,000 130,000 = 60,000 + a - 5,000 75,000 = a  75,000 = 40,000 + 9,000 + b – 35,000 – 12,000 73,000 = b  19,000 = 23,000 + 10,000 + 86,100 – 89,600 – c 10,500 = c  Assume that the following financial information relates to the accounting data of Mr. George for the period ended July 31 2019. Require 1: Prepare a balance sheet Determine the amount of Net Income assuming the owner made no additional investment (AI) or withdrawal Determine the NI, assume the owner had made no additional investment but had withdrawn Birr 2,500 Determine the NI/Loss if the owner had made an AI of 1,000 and had withdrawn Birr 2,000.  Capital = 13,400 + 11,400 + 750 – 8,100 = 17,450  The following are the amounts of the assets and liabilities of C company, a sole proprietorship, at June 30, 2020, the end of the accounting period, and its revenues and expenses for the year ended on that date. The capital of Mr. C, the owner, was 13,350 at July 1st, 2019, the beginning of the current year, and the owner withdrew Birr 14,000 during the current year. Cash received from customers was 74,500 and cash paid for expenses and creditors was Birr 56,900. Cash – 6,125 Accounts Receivable – 7,600 Supplies – 675 Prepaid Insurance – 650 Accounts Payable – 1,100 Salary Payable – 300 Fees earned (revenue account) – 68,775 Salary Expenses – 28,900 Rent expenses – 9,000 Advertising expenses – 5,950 Utilities expenses – 4,500 Supplies expenses – 2,500 Tax expenses – 1,800 Insurance expenses – 900 Miscellaneous expenses – 825 Instructions: Prepare an income statement for the year ended June 30, 2020. Prepare a statement of owner’s equity for the current year ended June 30, 2020. Prepare a balance sheet as of June 30, 2020. Prepare a cash flow statement for the current year ended June 30, 2020 assuming the cash balance at the beginning of the current year was 2,525 '}, {'name': '2021-02-06 -- Accounting Principles I.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Notes', 'content': 'Accounting Principles I Chapter 1: Contains: An overview of accounting Definitions of Accounting Forms of Business organizations Basic accounting equation (BAE) Analyzing effects of business transactions on the BAE Financial statements Chapter 2: Accounting for service giving organizations  Chapter 3: Accounting for merchandizing business organizations Definition of terms Key differences between service giving and merchandizing businesses Recording purchase transactions Recording sales transactions Preparation of f/s Chapter 4: Accounting for Accruals and Deferrals Accruals? (Revenues, Expenses) Deferrals? (in terms of revenues and expenses) Chapter 5: Accounting for Manufacturing companies Cost accumulation for: Raw materials Labor cost Overhead cost Preparation of cost of goods manufactured Financial statement preparations Chapter 6 (reading assignment): Accounting system design Chapter 1: Introduction to Accounting: Accounting is the process of identifying, measuring, recording, analyzing, summarizing and communicating/reporting economic events (financial information) of an organization to the users. Users of financial information Internal users  Management External users Shareholders Creditors Government Accounting as a field: Management Accounting Designed to provide the financial information to the internal users. Financial Accounting Aims to provide the financial information to the external users. Provides more summarized reports. Forms of Business organizations: Based on activities Service giving organizations Merchandizing organizations Manufacturing organizations Based on ownership Sole Proprietorship Partnership Corporation => Share companies. Book keeping vs. Accounting Book keeping:  refers to recording transactions and keeping the logs in a systematic way. It’s just the first phase of accounting.  Any Accountant can be a book keeper but any book keeper can’t be an accountant Basic Accounting Equation (BAE)   Sources of resources can be: Owner’s equity - capital Creditor equity - liability Resources of a business = assets       liability should ALWAYS come first You can’t sell a house without the creditor’s approval so that’s why the liability should always come first. (Creditors have priority over the firm’s assets) Assets:  refers to all resources controlled/owned by the firm from which future economic benefits are expected. Refers to anything of value that the firm own. Ex. Cash, supplies, buildings, furniture, machinery, land, receivables, etc... Tangible Assets Assets having physical substance Ex. Buildings, land, equipment, etc. Intangible Assets Assets that don’t have physical substance Ex. Copyrights, Patents, Goodwill, Tradename, Franchise  Liabilities: Refers to financial obligations that result in outflow of resources. Creditors claim over the firm’s assets. Anything of value that the firm owes. Ex. Accounts payable, Salary payable, Notes payable, etc… Capital: It’s also called an owners’ equity (Net worth) It’s the residual claims over the firm’s assets. Revenues/Income: Inflows of resources that increase capital other than owner’s contributions or investment. Enhancement/increase in asset Decrease in liability (more in chapter 4) Other names: Tuition fee Sales “Fees earned” Fares Expenses: Are outflows of resources that decreases capital other than those made by the owner in the form of withdrawals. Withdrawal/Drawing: When an owner takes out assets (cash or non-cash assets) for personal purpose, it is recorded as a withdrawal  Next class: Accounting Principles and Concepts '}, {'name': 'Fundamentals of Accounting  CH 1-Chapter 7.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CC272/Lecture Materials', 'content': ' Teaching Material for the course Accounting Principles I-I     Course Outline Chapter One:  General Introduction Definition of Accounting Evolution of Accounting Profession of Accountancy 1.4. Accounting Principles and Practices Accounting As Information Systems (Data Processing Methods) Principles And Practices Business Transaction And The Accounting Equation Financial Statements Chapter Two: Accounting Cycle for Service Rendering Businesses Nature And Classification of Accounts Chart of Accounts Flow of Accounting Data Trial Balance Adjusting Process Worksheets For Financial Statements Financial Statements Journalizing And Posting Adjusting  Journalizing and Posting Closing Entries Post Closing Trial Balance Chapter Three: Accounting For Merchandising Businesses Accounting For Purchases and Sales Credit Terms, Cash Discounts and Return & Allowances Trade Discount, Transportation Costs And Sales Tax Worksheets For Merchandising Businesses Financial Statements For Merchandising Businesses Adjusting, Closing And Reversing Entries Corrections of Errors   Chapter Four: Accounting for Accruals and Deferrals Accruals- Accrued Assets And Liabilities Deferrals- Prepaid Expenses And Unearned Revenues Chapter 5: Accounting for a Manufacturing Enterprise Differences between merchandiser and manufacturer Cost classifications Inventories for manufacturing enterprise Computation of the cost of finished goods manufactured Financial reporting by manufacturing companies  Chapter 6: Accounting systems Design Principles of accounting systems Accounting system installation and revision Internal control Guidelines to strong internal control Data processing methods Special journals and subsidiary ledgers   Chapter One General Introduction to Accounting  Definition Of Accounting Accounting is defined as the process of identifying, measuring, recording, classifying, summarizing, analyzing and interpreting economic events (financial transactions) and communicating the results thereof to the entities interested in such information to enable them make informed judgments. The analysis the definition is as follows: Identifying- to distinguish an event or a transaction that must be recorded. Measuring- quantifying an event or a transaction i.e. accounting deals with only those transactions and events that can be expressed in terms of money. Recording- this is the basic function of accounting. It is essentially concerned with not only ensuring that all business transactions of financial character are in fact  recorded but also that they are recorded in an orderly manner. Classifying- it is concerned with the systematic analysis of the recorded data with a view to group transactions or entries of one nature at one place. Summarizing-this involves presenting the classified data in a manner which is understandable and useful to the internal as well as external end users of accounting statements or other accounting information Analyzing-means methodical classification of the data given in the financial statements. For example, all items relating to “current assets” are put at one place. Interpreting- explaining the meaning and significance of the data so simplified and analyzed Communicating- the accounting information after being meaningfully analyzed and interpreted has to be communicated in a proper form and manner to the proper person. Accounting: The Language of Business Accounting has rightly been termed as the language of the business. Accounting is used to communicate financial information to various parties who have some stake (interest) in the affairs of the business.  Evolution of Accounting Similar to medicine, law, economics, and accounting has evolved in response to the social and economic needs of society. As business and society have become more complex over the years, many complex economic development and social programs can not be undertaken due to shortage of financial information. There fore, accounting has evolved to develop new concepts and techniques to meet the ever increasing needs for financial information.  Primitive Accounting  In the civilization of human being, various types of records of business activities have been maintained. Of these, the oldest known is Clay Tablet records of the payment of wages in Babylonia around 3600 B.C. There are numerous evidences of record keeping and systems of accounting control in Egypt and Greek City States. In English, under the direction of King William the 12th records were compiled to ascertain the financial resources of the kingdom.  Drawbacks of the Primitive Accounting: It dealt with limited aspects of the financial operations of private or government enterprises. There was no systematic accounting for all transaction of a particular unit i.e. only for specific type or portion of transaction  Double Entry System Accounting Since the primitive accounting was incomplete, the evolution of the system of record keeping which was said to be called “Double Entry System” was strongly influenced by Venetian merchants. Double entry system is the recordings process of a transaction into two parts. The first known description of the system was published in Italy in 1494 by a person called LUCA PACIOLI   Double Entry System provides: For all business transaction, recording in a systematic manner i.e. to establish in an equilibrium. For example, if a business borrowed Br 500 from a bank, the amount of the loan is recorded both as cash of Br 500 and an obligation to repay Br 500. Either of the Br 500 amount is balanced by the other Br 500 amount. In double entry system, every transaction entered twice in the books of accounts as means of check and control.  For the set of integrated financial statements, reporting in money terms In spite of the tremendous development of business operations since 1494, and   the ever increasing complexities of business and governmental organizations, the basic elements of Double Entry System have continued virtually unchanged.  Reading Assignment: the contribution of industrial revolution to the development of accounting   Types and forms of business organization in Ethiopia    Forms of business organizations There are three different legal forms of business organization: those are Sole proprietorship: -is a business owned and managed by single individual. Advantages: Easy to establish the business It is least regulated by government No profit sharing Disadvantages: Limited life Limited capital to finance business operation Unlimited liability  the owner is responsible to pay the debt of the business even from his personal asset in case the business unable to meet its liability) Partnership: - is business organization established by two or more persons. Advantages: Easier and less expensive to establish than corporation Are not highly regulated by government More capital and managerial skill than a single proprietor ship Disadvantages: Limited life Unlimited liability (the partners are responsible to pay the debt of the business even from their personal assets in case the business unable to meet its liability) Conflict between partners throughout operating the business. Corporation: - is a business organized as a separate legal entity under state corporation law with ownership divided into transferable shares of stock. Advantages: Long life Limited liability Can raise huge amount of capital to finance business operation Disadvantages: Double taxation Highly regulated by government Difficulty of controlling management, because ownership and management is divorced in corporation.  Types of Business Organizations According to their type of activities or nature of operations, business organizations are also classified in to three main types:  Service rendering businesses: - are business organizations that are predominantly engaged in rendering of services to customers for the purpose of maximizing profit. Examples:  Hotels, restaurants, cafeterias, bars, transport and communication services, professional firms like consultations by accountants, lawyers, engineers etc. Merchandising businesses: - is profit seeking businesses, which are engaged in purchasing and reselling of merchandises. Examples: Supermarkets, boutiques, garment and shoe shops, drug stores, stationary shops, auto spare parts, importers, exporters etc. Manufacturing businesses: - are business organizations that are primarily involved in the conversion of raw materials and parts in to finished goods; and sale their finished goods to merchandising enterprises and consumers. Sometimes, they sale goods to other manufacturing firms, which utilize the goods as raw materials for production activities.  Examples:  Cement factories, sugar factories, soap factories, textile factories, paper factories, etc.     Accounting Functions Performed by accountants   Accounting as Information Systems  In order to provide information an entity must establish its own accounting system. An accounting system consists of methods and devices used by an entity to keep track its financial activities and summarize in a manner useful to decision makers. The process of forming an accounting system to provide information is performed as follows:   Step-1: Identification of Users of Accounting Information Individuals or organizations who/which have stake (interest) in accounting information of a business to make sound decisions are called users of accounting information. They will receive different reports a business to make decision and are classified in to two: (1) Internal users and (2) External users Internal Users: are individuals within an organization or business entity that need accounting information of the business for the affairs of the business. Internal users are responsible for the administration of the business and include the following management, BOD, department head, corporate officer like chief executive officers and chief operating officers and chief financial officers. Management need an accounting information: To plan future operation To evaluate and control current operation To know the profitability of each department To know the company’s cash position To know the trend of earnings To assess whether spending kept within the budget limit or not(especially in NGO and Governmental organization) To assure whether expenditure are authorized or not( governmental and not-for-profit organization)  External Users: are those individual or institutions inside or outside an economic entity who/which need accounting information about that entity for their own affair. They need accounting information for their benefit. This group include: owners of the business, potential investors, bankers, suppliers and other creditors, employees and labor union, governmental agencies, etc.  Owners need accounting information: To know the operating results of the business To know its financial position Potential investors need accounting information a business to: Assess the risk ness of  the investment Predict its future prosperities Bankers need accounting information to Evaluate the financial soundness of a business organization Assess risks involved in giving loans Suppliers need accounting information to: Decide whether to sell or not to sell goods and services on credit basis Employees and labor union need accounting information before beginning negotiation of for new labor contract to know: The financial position of a businesses The profitability of a business The stability of a business Governmental Agencies need accounting information for purpose of determining income tax payable and pension contribution of an employee  Step-2: Information Need of Users This to determine the information needs of internal users i.e. the type of information needed by internal or external stakeholders should be identified by information provider before information is provided to users.  Step-3: Information Processing  The information need of users determine the economic data to be gathered and processed by accounting system. Then the accounting system generate reports that communicate essential information to users  Accounting Principles and Practices Experienced professional accountants contribute their best thinking to the solution of problem continually confronting their staff or employees. Professional association periodically issue pronouncements on accounting principles and concepts. Accounting principles or standards are conventional rules and regulations that govern actions in undertaking accounting activities. Concepts are basic assumption up on which the science of accounting is based. Practices are the application of accounting principles and concepts to specific accounting situation. The most important concepts and principles are: 1.6.1. Overview of international financial reporting standards (IFRS)   International Financial Reporting Standards. Financial accounting standards issued by the IASB are referred to as International Financial Reporting Standards (IFRS).  Financial reporting General purpose financial reporting aims to provide useful financial information about the reporting entity to primary users who cannot require the reporting entity to provide information directly to them. Special purpose financial reporting responds to the requirements of users that have the authority to require the reporting entity to provide the information that they need for their purposes directly to them.  Examples include: prudential regulation reporting requirements tax reporting requirements  International Financial Reporting Standards (IFRS)* Designed for general purpose financial reporting by profit-oriented entities might be found to be appropriate for not-for-profit activities too  Focused on information needs of (primary users) existing and potential investors, lenders and other creditors who cannot require information from the entity information to enable primary users to make their own assessments of the reporting entity’s prospects for future net cash inflows as a basis for their decisions to buy, hold, sell equity and debt instruments or to provide a loan or to require settlement of a loan          1.6.2.   Basic Assumptions and accounting principles   The five basic assumptions in turn: (1) economic entity, (2) going concern, (3) monetary unit, (4) periodicity, and (5) accrual basis.      Economic Entity Assumption The economic entity assumption means that economic activity can be identified with a particular unit of accountability. In other words, a company keeps its activity separate and distinct from its owners and any other business unit. Thus, the entity concept does not necessarily refer to a legal entity. A parent and its subsidiaries are separate legal entities, but merging their activities for accounting and reporting purposes does not violate the economic entity assumption       Going Concern Assumption Most accounting methods rely on the going concern assumption—that the company will have a long life. Despite numerous business failures, most companies have a fairly high continuance rate. As a rule, we expect companies to last long enough to fulfill their objectives and commitments.           Monetary Unit Assumption The monetary unit assumption means that money is the common denominator of economic activity and provides an appropriate basis for accounting measurement and analysis. That is, the monetary unit is the most effective means of expressing to interested parties changes in capital and exchanges of goods and services       Periodicity Assumption To measure the results of a company’s activity accurately, we would need to wait until it liquidates. Decision-makers, however, cannot wait that long for such information. Users need to know a company’s performance and economic status on a timely basis so that they can evaluate and compare companies, and take appropriate actions. Therefore, companies must report information periodically. The periodicity (or time period) assumption implies that a company can divide its economic activities into artificial time periods. These time periods vary, but the most common are monthly, quarterly, and yearly          Accrual Basis of Accounting Companies prepare financial statements using the accrual basis of accounting. Accrual basis accounting means that transactions that change a company’s financial statements are recorded in the periods in which the events occur                  Basic Principles of Accounting There are four basic principles of accounting to record and report transactions: (1) measurement, (2) revenue recognition, (3) expense recognition, and (4) full disclosure. We look at each in turn     Measurement Principles The most commonly used measurements are based on historical cost and fair value. Selection of which principle to follow generally reflects a trade-off between relevance and faithful representation.  Historical Cost. IFRS requires that companies account for and report many assets and liabilities on the basis of acquisition price. This is often referred to as the historical cost principle. Cost has an important advantage over other valuations: It is generally thought to be a faithful representation of the amount paid for a given item.  Fair Value. Fair value is defined as “the price that would be received to sell an asset or paid to transfer a liability in an orderly transaction between market participants at the measurement date.” Fair value is therefore a market-based measure (exit price). Recently, IFRS has increasingly called for use of fair value measurements in the financial statements. The IASB believes that fair value information is more relevant to users than historical cost.         Revenue Recognition Principle   Revenue refers to increases in economic benefits during the accounting period in the form of enhancements of assets or decreases of liabilities that result in increases in equity, other than those relating to contributions from equity participants. When the company satisfies the performance obligation, it should recognize revenue.       Expense Recognition Principle   Expenses refers to decreases in economic benefits during the accounting period in the form of outflows or depletions of assets or incurrences of liabilities that result in decreases in equity, other than those relating to distributions to equity participants. Expenses should be recognized in the period in which they are incurred.             Full Disclosure Principle In deciding what information to report, companies follow the general practice of providing information that is of sufficient importance to influence the judgment and decisions of an informed user. Often referred to as the full disclosure principle, it recognizes that the nature and amount of information included in financial reports reflects a series of judgmental trade-offs. Business Transaction and the Accounting Equation Business Transaction  Business transactions are events or conditions that must be recorded in terms of money in accounting records. Events-payments or a promise to make payment or receipts or acceptance of a promise to receive cash within a specified period of time in exchange for goods and services  Conditions- the tearing and wearing out of long lived properties of a business i.e. decrease in usefulness of long lived property. Example:  Monthly electricity bill of Br 100 The acquisition of  a land and  a building for Br 250,000  Nature of Business Transaction Business transaction could be Simple or complex Business transaction could be Internal or external Business transaction affects the financial position of a business and its operating results or at least it affects two items  Business transaction must be supported by source documents (business papers). Source documents include sales invoice, receipts, checks, check stub, fright bill, and etc. Business documents normally contain information as to the monetary amount to be recorded, the parties involved, the term of transaction and other relevant information such as nature and date of transactions.  The Accounting Equation The whole of financial accounting is based on a very simple idea. This is called the accounting equation which sounds complicated but infact easy to understand. If a firm is to be set up or established definitely it need resources. In the first place let us assume that it is the owner of the business has supplied all of the resources. This can be shown: In accounting the term used to describe the resources supplied by the owner is called Owner’s Equity. The term used to describe the actual resource in a business is called Asset. Thus, the accounting equation is:   In the second place let us assume that people other than the owner have supplied some of the resources (material or financial resources). Thus, Liabilities are the term given to the amounts of resource supplied people other than the owners. This is amount of asset owed to others by the business. Thus the accounting equation is now changed to    \nHowever, liabilities are placed before Owner’s Equity, in the accounting equation, because creditors have preferential right to the assets of the business. Thus, the accounting equation can be stated as:   Definition of Terms Used in Business Transactions and Accounting Equation  Definition of elements of financial statements  ASSET. A resource controlled by the entity as a result of past events and from which future economic benefits are expected to flow to the entity.eg cash ,account receivable, supplies equipment building etc  LIABILITY. A present obligation of the entity arising from past events, the settlement of which is expected to result in an outflow from the entity of resources embodying economic benefits. Eg account payable, wage payable bond payable etc  EQUITY. The residual interest in the assets of the entity after deducting all its liabilities. The elements of income and expenses are defined as follows. INCOME/Revenue. Increases in economic benefits during the accounting period in the form of inflows or enhancements of assets or decreases of liabilities that result in increases in equity, other than those relating to contributions from equity participants.eg sales, service income  EXPENSES. Decreases in economic benefits during the accounting period in the form of outflows or depletions of assets or incurrences of liabilities that result in decreases in equity, other than those relating to distributions to equity participants.eg salary expense, rent expenses etc  Other related definition  Accounts receivable-is money to be collected in the future. It is an asset that arises from the sell of goods and services on credit basis or on account. Account payable-is money to be paid in the future. It is a liability that arises from purchasing goods or services on account basis. Prepaid expenses- are assets which represent consumable goods purchased such as supplies, prepaid rent, prepaid insurance, prepaid interest Revenue-is a general term that stands for the amount of charge against customer for goods or services sold to them. Based on the source of revenue, it is classified into two: Miscellaneous Revenue and Principal Revenue. Revenue can have different names such as: Royalties- revenue from sale of franchise Fares revenue- a revenue generated by providing transportation service Fees revenue- by providing professional service Sales- revenue from sales of goods and services Rent revenue- from renting real-estate and other equipment Tuition fee- revenue from providing educational service Net income/ net profit-is the excess of revenue earned over the expenses in the process of generating revenue. Net loss- is the excess of expenses over the revenue earned during the period Investment- represent the cash or other assets put into the business by the owner of a sole proprietorship Withdrawal (drawing)-is the cash or any asset withdrawn (taken away) from the business by the owner for personal use. Withdrawal is recorded in accounting record of the business.    1.7.4 Accounting Equation and Business Transactions   The effect of business transaction on accounting equation can be demonstrated by taking some typical transactions. Illustration: Mr. Hara established a Sole Proprietorship Business known as Hara Taxi on August 1, 1995 and decided the fiscal year of the business to be from September 1 to August 31. During the first month of operation the following transactions occurred: August 1:  Hara deposited Br 300,000 in a bank account in the name of the business. August 2: The owner purchased two taxis at Br 100,000 each for the business August 4:  Purchased a land as a future building sites for Br 7,500 paid in cash August 7: Purchased Br 850 of gasoline, oil, and other supplies on account promising to pay in the future August 10: Paid creditors on account Br 400 August 15: Hara Taxi earned fares revenue of Br 4,500 receiving the amount in cash. August 21: The business paid the following expenses in cash: Wages expense\t  Br 1,200 Rent expense\t          850    Utilities expense\t          150 Miscellaneous expense\t          200 August 23: The business charged customers for the transportation service provided on account Br 2,000 August 28: Received cash from customers on account Br 1,500 August 30: Mr. Hara withdrawn Br 1,000 from the business in cash for personal use August 31:  At the end of the month the cost of supplies left on hand is Br 50 Instructions: Indicate (show) the effect of each of the above transactions on accounting equation Prepare the accounting statements            Accounting (Financial) Statements Accounting statements are different summaries that communicate accounting information of a business to users. And include: Income statement Statement of owner’s equity Balance sheet  Cash flow statement Financial statements are identified by three headings: The name of the business  The title of the statement The specific date or period  Income Statement  This statement is a summary of revenues and expenses for the specific period of time. The procedure is the total expenses are deducted from the total of revenues to determine net loss or net income. For example, income statement for Hara Taxi   Capital Statement (Statement Of Owner’s Equity) This statement is a summary which shows change in owner’s equity or capital. For Hara Taxi the capital statement is as follows: BALANCE SHEET Balance Sheet is a statement that shows the financial position of a business on a specific date. It lists Assets, Liabilities and Capital on any specific date, which is the last date of the accounting period.  Cash Flows Statement Cash flows statement is a summary of cash inflows (Cash receipts) and Cash outflows (Cash payments) for a specific period of time. It is reported in three sections: Cash flows from operating activities Cash flows from investing activities Cash flows form financing activities   Chapter Two Accounting for Service Rendering Businesses Nature and Classification of Accounts Nature of Accounts The simplest way of providing accounting information or preparing financial statements is to record and summarize transactions on the accounting equation format. However, this format is awkward and cumbersome for recording and analyzing ten thousands of transactions to provide information. Thus, accountants accumulate the effects of individual transaction on a separate record for each item to meet the goal of providing information. These separate records show increases in the item, decreases in item and balance in item. The type of separate records used for the purpose of recording all transactions related to individual item is called An Account. A group of accounts is called ledger. The simplest form of an account has three parts: Title- the account name A space for recording the amount of increases in item in terms of money A space for recording the amount of decreases in item in terms of money \tThe left side of an account is called Debit Side and the word “Charge” sometimes used as a synonym for debit. Amounts entered in the left side of an account regardless of the account title are called debit and the account is said to be debited. The right side of an account is called credit side and the amount entered in the right side of an account is also called credit and the account is said to be credited.  . General Rules of Debit and Credit for Accounts Assets-the increasing side of all assets account is the debit side and the decrease is the credit side. Liabilities-the increase side of all liabilities is the credit side and the decreasing side is the debit side. Capital -the increase side of capital account is the credit side and the decreasing side is the debit side. Revenue- the increase side of all Revenue accounts is the credit side and the decreasing side is the debit side. Expenses -the increasing side of all expenses account is the debit side and the decrease is the credit side. Drawing- the increasing side drawing is the debit side and the decrease side is the credit side.  Normal Balance of Accounts The sum of increases recorded in an account is usually greater than or equal to the sum of decreases recorded in an account. For this reason, the normal balance of all accounts is positive rather than negative. Thus, the normal balance of any account is the increasing side. Summaries Rules of Debit and Credit with normal balances of accounts      Classification Of Accounts Accounts in a ledger are classified based on common characteristics as a balance sheet accounts or income statement accounts  Balance Sheet Accounts Balance Sheet Accounts further classified into three and are listed in the ledger in the order of Assets, Liability and Owners Equity Assets-assets are classified in the two groups as current assets and plant assets Current Assets-are any assets that may reasonably be realized in cash or sold or consumed within year or less period. For example: Cash, Accounts Receivable, supplies, commodities  Plant Assets-these are used in the business operations and are of permanent nature. For example Equipments, machinery, building, furniture, land, etc Liability- the two categories occurring most frequently are: Current liabilities- are liabilities that will be due within short period of time usually a year or less that have to be paid out current asset. For example: salary payable, interest payable, tax payable, and accounts payable Long term liabilities- are liabilities that will not be paid or due or matured comparatively for long period of time usually more than one year. For example mortgage payable, notes payable Owner’s Equity-is a residual claim against the asset of the business after liability is fully deducted. For a corporation owners’ equity is called stock holder’s equity. Drawing represents the amount of cash or other assets taken out of the business for personal use and it is one of the capital accounts.  Income Statement Accounts Income Statement Accounts are classified into three and are listed in the order of revenue first and expense second.  Revenue is increase in capital by gross amount as a result of: Sale of goods and service Renting real-estate and other properties  Providing professional service Sale of assets Expenses – represent decreasing in capital by gross amount as a result of business operation. That is as a result of consuming assets or using up of services.   Chart of Accounts Accounts are sequentially arranged and given number for use as references. The list of accounts along with their numbers showing the sequence of account in the ledger is called Chart of Accounts. According to their order in the financial statements asset comes first and then followed by liabilities, capital, revenues and expenses. The chart of account of Ethio Mobile Maintenance which is owned by Ato Samuel and managed by his wife W/o Ethiopia is follows:  Note: A flexible system of numbering is desired. Such system has the advantage of permitting of the later insertion new accounts without disturbing other account number. In the above chart of accounts certain numbers (15, 16, 18, and 22, 55-58) have not been assigned. These numbers are held in reserve so that additional accounts can be inserted in the ledger in proper sequence whenever such accounts become necessary. The number of digits given may vary from 2 to 30 digits depending up on the size and nature of the business. In the above chart of accounts, 2 digits are assigned. The first digit shows the division of the item in the ledger and the second digit indicates the position of the item in the division.   Flow of Accounting Data The flow of accounting data from the time a transaction occurs to its recording in the ledger is diagrammed as follows:   Transaction Occurs – there must be business transaction, be it internal or external, to initiate the flow of Accounting Data.  Document Prepared – If it is external transaction it must be supported by the necessary source documents. Analyzing Transaction Analysis of a transaction is a three steps procedure: Determining the accounts affected by the transaction Determining the effect of a transaction as increases and decreases Analyzing the increases and decreases as Debit and Credit Example: The owner of JJ Arts Club invested Br 20,000 on January 1, 2005 The accounts affected are Cash (Asset)  and Capital (Owner’s Equity) Cash increases and Capital also increases by Br 20000 Cash increases is Debit and Capital increases is Credit JJ Arts Club purchased electric guitar for Br 8,200 in Cash on January 10, 2005  The accounts affected are Cash and Equipment Cash decreases and Equipment increases by Br 8200 Cash decreases is debit and Equipment increases is Credit Recording Transaction in a Journal After analyzing transactions, they are recorded in a book called journal in an orderly manner. Journal provides for transactions: Permanency-it is permanent record of transactions for reference Orderliness or chronology-transactions are recorded sequentially Accuracy or Approval- before transactions are recorded in their account approval will be made  There are two types of journals: General Journal- is a journal on which any type of transaction is recorded upon. Special journal- this is a journal on which one type of transaction with recurrent nature is recorded upon. The process of recording transaction in a journal is called journalizing and the steps in journalizing are as follows: Step-1: Recording the Date Inserting the year Inserting the month Inserting the date Step-2: Recording the account title to be debited at the extreme left of the description column of the General Journal and enter the amount of debit Step-3: Recording the account title to be credited just below the debit entry moderately indented and enter the credit amount Step-4: Writing an explanation Write an explanation for each transaction or replace it with its source document number if it is self explanatory transaction. The above two analyzed transactions are recorded in the General Journal as follows:  Posting a Transaction The processing of transferring a transaction to ledger accounts is called posting. There are different types of accounts: T-accounts which resembles a capital letter “T” Two column account which consists of two date, post referencing, debit and credit columns Four column account which consists of one date, one post referencing, one debit, one credit and one debit and credit under balance column Three column account which consists of one date, one post referencing, one debit, one credit and one balance column. The abnormal balance is shown in bracket. The steps in posting are: Step-1: Record the date and Post the debit or the credit  Step-2: Insert journal page numbers in the post reference column of ledger accounts Step 3: Insert Account numbers in the post reference column of General Journal   Illustration on Journalizing and Posting The following transactions are related to Ethio Mobile Maintenance (EMM) which is owned by Ato Samuel, for the first month operation ended December 31, 2004 December 1: The following assets were invested to the business: Cash\t Br 5,900.00 Supplies\t         550.00 Land\t    10,000.00 The liabilities transferred to the business was\t         400.00 December 1: EMM paid a premium of Br 2,400 for a comprehensive insurance policy which will cover a 2 years period December 1: EMM received Br 720 for renting the land for 3 months December 2: EMM paid Br 800 for the rent of the month December. December 5: EMM Purchased Office Equipment on account Br 7,000 December 7: EMM paid Br 180 for a daily news paper December 11: EMM paid Br 400 to creditors  December 13: EMM paid receptionist and part-time assistant Br 1,250 for two weeks salary December 16: EMM received Br 5,000 from revenues earned for the 1st half of the month December 16: fees revenue on account totaled Br 1,750 for 1st half of the month December 20: EMM paid Br 3,500 to creditors on the Br 7000 debt owed from the December 4 transaction December 23: EMM Received Br 1,150 from customers in payment of their accounts December 25: EMM purchased supplies for Br 1,450 in cash December 27: EMM paid receptionist and part-time assistant Br 1,250 for two weeks salary December 31: EMM paid Br 310 and Br 240 telephone and electric bill for the month, respectively December 31: EMM received Br 2,750 from revenue earned for the second half of the month December 31:  fees revenue earned on account totaled Br 1,200 for the second half of the month December 31: the owner withdrew Br 1,000 for his personal use  Instructions: Analyze and Journalize the transaction for the month December 2005 in two column journal assuming that the policy of the company is to record money paid for telephone, electric and water as utilities expense and for advertising, postage and stamp and news paper as miscellaneous expense. Post entries from journal to ledger accounts using a four or three column ledger account  Journalizing: Recording Transactions in General Journal (Assume transactions from Dec.1 to 15 and Dec.16 to 31 are recorded on page 1 and 2, respectively)   Transactions from December 16 to 31, 2005  Posting: Transferring transactions from General Journal to ledger accounts Cash Account has a debit balance of Br 2,740.  Accounts Receivables General Ledger Account has a debit balance of Br 1,800 Supplies General Ledger Account has a debit balance of Br 2,000 Prepaid Insurance General Ledger Account has a debit balance of Br 2,400 Equipment General Ledger Account has a debit balance of Br 7,000 No transaction is posted to Accumulated Depreciation General Ledger Account so far. Land General Ledger Account has a debit balance of Br 10,000 Accounts Payable General Ledger Account has a credit balance of Br 3,500 Unearned Rent General Ledger Account has a credit balance of Br 2,400 Samuel Capital General Ledger Account has a credit balance of Br 16,050 Samuel Drawing General Ledger Account has a debit balance of Br  No transaction is posted to Income Summary General Ledger Account   Service Revenue General Ledger Account has a Credit balance of Br  No Transaction is posted to Rent Income General Ledger Account 800 Salary Expense General Ledger Account has a debit balance of Br  Supplies Expense General Ledger Account has a debit balance of Br  Rent Expense General Ledger Account has a debit balance of Br  Utilities Expense General Ledger Account has a debit balance of Br  Miscellaneous Expense General Ledger Account has a debit balance of Br  No Transaction is posted to Depreciation Expense General Ledger Account Insurance Expense General Ledger Account has a debit balance of Br   Trial Balance  Before preparing financial statements, the ledger account balances must be proved as to the equality of the total debit balances and the total credit balances. The working paper which provides the proof of the equality of debit and credit balances is called a trial balance. The trial balance is a two column schedule listing the names and balances of all accounts in the ledger i.e. debit balances are listed in the left hand column and the credit balances in the right hand column. It is a working paper which is useful only to the accountant. It is not a financial statement and it is not intended for distribution to the users of accounting information. Preparing a trial Balance requires five steps Determine the balance of each account List the accounts with a balance other than zero, the debits in the left column and the credits in right column Add debit balances Add credit balances Compare the sum of the debit balances with the sum of the credit balances Instruction: Prepare a Trial Balance for EMM  Uses of a Trial Balance A trial balance provides a proof that the ledger in a balance and it is also a cornerstone for preparation of financial statements. The following types of errors will cause the two total of the trial balance to unequal.  Error in preparing the trial balance such as: One of the columns of the TB was incorrectly added The amount of an account balance is incorrectly recorded on the trial balance A debit balance was recorded on the trial balance as a credit or vice-versa or the balance was entirely omitted  Error in determining the account balances such as: A balance was incorrectly computed A balance was entered in the wrong balance column Error in recording transaction in the ledger such as An erroneous amount was posted to the account A debit entry was posted as a credit or vice-versa A debit and a credit posting was omitted  Limitations of a Trial Balance The trial balance does not prove that transactions have been correctly analyzed and recorded in the proper account because there are many errors that do not cause the two totals of the trial balance to be out of balance. The following errors do not affect the equality of the two columns of the trial balance: Failure to record a transaction or to post a transaction Recording the same erroneous amount for both debit and credit parts of a transaction Recording the same transaction more than once for both parts of a transaction Posting a part of a transaction correctly as a debit or a credit but to the wrong account  Discovery of Errors If the two totals of the trial balance are not equal, the error can be discovered in the following manner: By Audit procedures By Chance discovery Through the medium of the trial balance Through the medium of the trial balance, first determine the difference between the debit total and the credit total. This gives the clue A difference of Br10, 100, 1000 is frequently the result of an error in addition If a difference divisible evenly by 2, the error is either the omission of a debit or a credit or the posting of debit as a credit or vice-versa If the discrepancy of the two totals is evenly divisible by 9, the error is either transpositions or slide. Transpositions error is the erroneous rearrangement of digits Slide error is the entire number is erroneously moved one or more spaces to the right or to the left  The Adjusting Process Revenues and expenses might be reported on the income statement by the cash basis or the accrual basis. In the cash basis of accounting, revenues are reported in the period cash is received and expenses are reported in the period when cash is paid. In cash basis of accounting, the net income equals cash receipts minus cash payments. This basis of accounting is used by various professional service businesses. For most businesses, how ever, it is not considered an acceptable method. In the actual basis of accounting, revenues are reported in the period in which they are earned and expenses are reported in the period in which they are incurred. Thus, accrual basis of accounting requires adjusting processing.   At the end of the acct period many of the amounts listed on the trial balance can be transferred with out change to the financial statements. For example, cash, notes payable. On the other hand there are some accounts whose balance listed on the trial balance should not pass directly to the financial statements. For example, the amounts listed for prepaid expenses are normally overstated. The reason is part of the amount is consumed in the day to day operation of the business in generating revenues. Also other data needed for the financial statement may be entirely omitted from the trial balance because revenues or expenses related to the period has not been recorded. For example, salary expenses incurred between the last pay day and the end of the accounting period would not ordinarily be recorded in the accounts because salaries are customarily recorded only when they are paid. The entries required at the end of the accounting period to bring the amounts up to date and to ensure the proper matching of revenues and expenses are called adjusting entries. Adjusting entries are internal transactions made at the end of the accounting period. Illustrations of Adjusting Entry Adjusting Deferred Expenses (Prepaid Expenses) Adjusting Supplies In a trial balance, the supplies account has a balance of Br2000 on December 31, 2004. Assuming that the inventory of supplies on December 31, is Br 500, determine the amount to be transferred from asset account (supplies) to the expense account (supplies expense)  Supplies available during the year\tBr 2,000 Supplies on hand\t     (500)   Supplies used (amount of adjustment)\t    1,500  Adjusting prepaid insurance The balance of prepaid insurance account has a balance of Br 2400 which was paid for 24 months. As a result every month Br 100 is expired. Other examples of prepaid expense are prepaid advertising, interest, rent, etc  Adjusting Deferred Revenue (Unearned Revenue) On December 31, the balance in the unearned rent account is Br720. This balance represents the receipt of three month’s rent. At the end of December, the unearned rent account should be debited (decreased) by Br 240 and the rent income account should be credited (increased) by Br 240.   Adjusting Accrued Expenses (Accrued Liabilities) Some services are paid for after the services have been performed. For example, Wages expense accumulated or accrues hour by hour and day by day, but payment may be made only weekly, biweekly, or monthly. The amount of such an accrued but unpaid item at the end of the accounting period is both an expense and a liability. For example, at the end of December accrued wages for Ethio Mobile Maintenance was Br 250. This amount is an additional expense of December and is debited to the salary expense and salary payable. In this example, December 1 is on Sunday and the first and the second salary payment on 13th and 27th of December, respectively if salary is paid on biweekly basis. If payment for the next 10 working days is Br 1250 the accrued salary will be Br 250  Adjusting Plant Assets As time passes, the equipment loses its ability to provide useful services. This decrease in usefulness is called depreciation. All plant, except land, loses their usefulness. It is difficult to objectively measure the decrease in usefulness of a plant asset. For this reason, depreciation in accounting is the systematic allocation of plant assets cost to the useful life as an expense. This allocation occurs over the asset’s estimated life during which it is expected to generate revenue. The adjusting entry is made by debiting a depreciation expense account and crediting an accumulated depreciation account followed by the specific name of that plant asset. For example, assuming that the estimated amount of depreciation for the month is Br 100, the adjusting entry debits (increases) Depreciation Expense by 100 and credits (increases) Accumulated Depreciation-Equipment by the same amount.  Book Value (BV) an Asset = Cost – Accumulated Depreciation Book Value of the Equipment= Br 7,000 – 100= Br 6,900   Worksheet for Financial Statements A working paper often used by accountants to summarize adjustment data and assist in preparing the financial statements is called the worksheet. It is identified by three headings and has five columns: Trial Balance Column, Adjustment Column, Adjusted Trial Balance Column, Income Statement Column, and Balance Sheet Column. Uses of Worksheet: It Reduces The Possibility Of Overlooking The Need For An Adjustments It provides A Convenient Means Of Verifying Arithmetical Accuracy It Provides For The Arrangement Of Data Is A Logical Form It Provides The Source Data For The Financial Statements Preparing worksheet based on the above adjustment data for the service rendering business.     Preparation of Financial Statements The worksheet is an aid in preparing the financial statement namely the income Statement, The Capital Statement and the Balance Sheet. For Ethio-Mobile Maintenance, the financial statements are presented as follows: The Income Statement  Statement of Owner’s Equity The Balance Sheet Note: Financial statements may annual or interim. Statements that are prepared for a period of less than one year are called interim statements. A financial report that is prepared annually is said to be fiscal year statement.  Journalizing and Posting Adjusting Entries At the end of the accounting period, the adjustment data appearing in the work sheet are recorded in the journal and posted to the ledger. This procedure brings the ledger into agreement with the data reported on the financial statements. The adjusting entries are dared as of the last day of the period, even though they are usually recorded at a later date. Each entry may be supported by an explanation, but a suitable caption above the first adjusting entry is sufficient. The Adjusting Entries for EMM is presented in a General Journal as follows:  Journalizing and Posting Closing Entries Revenues, expenses and drawing or dividend accounts are temporary accounts used in classifying and summarizing changes in the owner’s equity during accounting period. Since these accounts are reported for each period, the balances of these accounts should be zero at the beginning of the next period. Because the balances of these accounts are not carried forward, they are sometimes called temporary accounts or nominal accounts. The balances of temporary accounts and preparing these accounts for use in accumulating data for the following period is accomplished by removing their balances through closing entries. Closing entries are made with the help of another temporary account called Income Summary. The four entries required to close the temporary accounts of a sole proprietorship at the end of the accounting period are: to close revenue accounts-each revenue account is debited for the amount of its balance and the income summary is credited for total revenue to close expense accounts-each expense account is credited for the amount of its balance and income summary is debited Income summary might have debit (net loss) or credit (net income) balance after revenues and expenses are closed. If it is debit balance income summary is credited and capital is debited and if it is credit balance income summary is debited and capital is credited. To close drawing account-the drawing account is credited for the amount of its balance and the capital account is debited for the same amount.   Post Closing Trial Balance The last and optional procedure of the accounting cycle is the preparation of a trial balance after all the temporary accounts have been closed. The purpose of the post closing trial balance is to make sure that the ledger is in balance at the beginning of the new accounting period.   Chapter Four  Accounting for Merchandising Businesses In the preceding chapters we have illustrated the accounting cycle for organizations that render services to their customers. Merchandising companies, in contrast, earn their revenue by selling goods.  A business that buys and resells goods is called Merchandising Business. The goods that a merchandising company sells to its customers are called inventory (or merchandise). Merchandising companies include both retailers and wholesalers. These companies purchase readymade or ready to sell goods and get all earning or revenue by selling them. Merchandise may include anything, which a merchandising business can buy for resell purpose and may vary from needle to automobiles. Merchandising enterprises commonly use the procedures described below. However, these procedures may very from business to business. For Example: Purchases and sells may be made for cash or on credit basis Different arrangement may be made for making payment on accounts Policies for the return of merchandising may differ and  Policies for the payment of transportation costs may also vary  Accounting For Purchases and Sales  Purchases of merchandise are usually identified in the ledger as purchases. A merchandising business can accumulate in the purchases account the cost of all merchandise purchased for resale during the accounting period. The cost of merchandise purchased is recorded by debiting an account called “PURCHASES”. Purchases can be made for cash or on account. The sale of merchandise during an accounting period credited to an account called “SALES”. Merchandises may be sold on cash or may also be sold on account.  Illustration 4.1: Mulu Super Market purchases 2000 cartons of Canned Fish from Century Trading House at a cost of Br 50 per carton on cash. Record the transaction for both the buyer and the seller. The Buyer (Mulu Super Market):  The seller (Century Trading House): Illustration 4.2: Lucy Cosmo Trading Company sold merchandises of Br 5,700 on credit to Selam Cosmetics. Record the transaction for both parties The Buyer: The Seller:  Illustration 4.3: Assume Ambassel Trading House purchases 10,000 cartons of Exercises book from Guna Trading Enterprise for Br 150,000 with dawn payment of 60%. Record the transaction in the book’s of the buyer and the seller. The Seller (Guna Trading Enterprises):  The Buyer (Ambassel Trading House): Note: The Purchases account is used only for merchandise for resale to customers. That is, other assets purchased for use in the business are not debited to the purchases account. The acquisition of the asset recorded by debiting the appropriate asset account  Credit Terms, Cash Discounts and Return & Allowances Credit Terms The arrangements agreed upon by the buyer and the seller as to when payments for merchandise are to be made is called the credit terms. If the payment is required upon delivery, the terms are said to be “Cash term” or “Net cash term”. If the payment is not required upon delivery, the buyer is allowed a certain period of time for payment; the term is known as the credit period. The credit period usually begins with the date of the sale as shown by the date of the invoice or the bill. Examples of Credit Period terms: n/30 (i.e. net 30 days) – payment will be made or due within 30 days after the date of the invoice. n/EOM (i.e. net end of the month) – the payment will due by the end of the month in which the sales was made. 20/EOM (i.e. 20 end of the month) – Payment is due 20 days after the end of the month in which the sales was made  Cash Discounts As a means of encouraging payment before the end of the credit period, the seller may offer a discount for the early payment of cash. Such type of deduction or discount is known, as a cash discount. It is a discount for prompt payment made from the invoice price.  Illustration 4.4: A seller may offer a buyer a 2% discount if payment is received within 10 days of the invoice date. For this, the term “2/10, n/30” can be used and it means that: The credit period is net 30 days The period during which a discount is available is called the Discount Period i.e. is the first 10 days The buyer will get a deduction of 2% of the amount of the invoice if it is paid within the 10 days of the credit period.  Cash discounts can be Purchase discount and Sales discount.  Purchase discount: the cash discount taken by the buyer for early or prompt payment of an invoice is called purchase discounts. The buyer records purchase discount by crediting the “PURCHASES DISCOUNTS” account and they are usually viewed as a deduction from the amount initially recorded as in purchases. Purchase discount account is a contra (offsetting) account to Purchases account.  Sales discounts: the seller refers to the same cash discounts taken by the buyer as “SALES DISCOUNT”. It is recorded by debiting sales discount account and considered as the amount to be deducted from the amount sales. Sales discount is a contra sales account.  Illustration 4.5: On March 1, 2005 assume Hebesha Trading House purchased ready made clothes from Kombolcha Textile Factory on account for Br 600,000; terms 2/10,n/30. Instructions: record the transaction in the books of both the buyer and the seller assuming that (A) the Buyer settled the payment within the discount period, and (B) the Buyer did not settle the payment within the discount period Within the Discount Period The Buyer: The Seller:                           After the Discount Period The Buyer:  The Seller: Note: From the buyer’s stand point, it is important to take advantage of all available discounts even though it may be necessary to borrow money to make the payment. Example 4.6: on January 1, 2005 Ethiopian Electric Company purchased 20 transformers from Wallace Electronic Supplies at Br 200 per unit; terms 2/10,n/30. The invoice is to be paid within the discount period from the bank at 10% for remaining 20 days. Determine the amount of net saving for Ethiopian Electric Company Total invoice price\tBr 4,000 Cash discount (Br 4000 * 2%= 80)\t        (80) The amount to be borrowed\t Br 3,920 Interest on money borrowed (3920*10%*20/360)\t      21.80 Net saving (Br 80- 21.80= )\t Br 58.20 Net saving is the difference between the discount received and the interest to be paid for the 20 days i.e. if the business borrowed money and settled the liability within the discount period, the business can save an amount of Br 58.20  Exercise 4.1: On November 1, 2004 ABC Company purchased merchandise on a credit terms 3/10, n/30 and on November 10, 2004 the company paid Br 9700. Instruction: record the transaction in a journal at the date of purchases and on the date of payment   Return and Allowances  Merchandise purchased from the supplier may be unsatisfactory, defective or wrong specification. In this case the goods may be returned to the supplier (this is called Returns) or the buyer may requests for a price reduction or adjustment (this is called Allowances). The same return and allowance is referred by the buyer as purchases returns and allowances and by the seller as sales returns and allowances.  Purchases Returns and Allowances (PRA): The buyer sends a debit memo to the supplier to notify that it is debiting the seller’s account. It is recorded by crediting “Purchases Return and Allowances” or “Purchases” account. But management needs specific information as to the percentage of purchases return and allowances so that they prefer the credit goes to “Purchases Returns and Allowances”.    Sales Returns and Allowances (SRA): The effect of sales return and allowances is a deduction in sales revenue and a reduction in or account receivable. There fore, excessive sales return and allowances show there is loss in revenue, an additional expense and customer dissatisfaction. It is possible to debit the sales account instead of debiting the sales returns and allowances account. How ever, debiting sales account will not disclose the amount of sales returns and allowances.  Illustration 4.7: On July 8, 2005 Global Trading Enterprise sold merchandises on account to GYB Company Br 40,000 terms 3/10, n/eom. On July 11, GYB Returned Br4000 defective merchandises to Global which is part of the sale of July 8. On July 17, Global received cash from GYB. Instruction: record the transactions in the books of the buyer and the seller. The Buyer:   The Seller:   Exercise 4.2: Assume Guna Trading Enterprises sold merchandise for cash for Br 80,000 to Gungo Trading Company on August 10, 2004. Guna Trading Enterprises received some of the merchandises sold to Gungo because they are found to be defective. The company has given the cash refund of Br 2500 for goods returned by the buyer on August 12. Instruction:  Record the transaction in the book’s of the buyer and the seller   Trade Discounts, Sales Taxes, and Transportation Costs Trade Discounts Many wholesalers of merchandise publish periodic catalogs that are used by buyers in ordering merchandise. Rather than updating their catalogs frequently, wholesalers publish price updates which may involve large discounts from the list prices or suggested price or gross price in their catalogs. In addition, the sellers offer certain classes of buyers such as government agencies or buyers who order large quantities, special discounts. The special discounts or discounts for large quantities purchased are called Trade discounts. Sellers and buyers usually don’t record the list prices and the related trade discounts in their accounting records. For accounting purpose only the final price or agreed price is important.  Illustration 4.8: KOKET Company purchased 600 units of merchandises from BB Company terms 3/10, n/30. The merchandise has a list price of Br 50 per unit with the trade discount of 20%, 10% and 5%. Assuming that KOKET Company is allowed all these discounts compute the invoice price for the 600 units and make the necessary journal Entries in the record of both Companies assuming that the buyer paid within the discount period. List price (600 units * Br 50)\t Br 30,000.00 Trade discount (20%*30,000)\t       (6000.00) Balance after the 20% TD\t Br 24,000.00 Less: TD (10%*24,000)\t       (2,400.00) Balance after the 10% TD\t Br 21,600.00 Less: TD (5%*21,600)\t       (1,080.00) Agreed Price or Invoice price\t Br 20,520.00  The Buyer: The Seller:  Sales Taxes Government usually levies or imposes tax on retail sales of merchandises. Sales of merchandise that will be resold are usually not taxed. A sales tax is imposed on the final consumer but the seller must collect the tax, file tax returns at a time specified by law and remit the collected tax on the reported sales to the government.  Value Added Tax (VAT) one of the sales tax which charged on the supply of most goods and services for the value added on it.  Some goods are not taxable. For example, postal services are not taxable. In addition, some persons and firms are exempted from sales tax- Ambassador and Embassy residents and Charities organizations (Zero Rated Firms). Nature of the business also affects the sales tax. A bank for instance does not have to add VAT on its bank charges and small firms, too. If small firms do register for VAT then they will have to keep full VAT records in addition to charging out VAT.  Accounting For Sales Tax by the Seller The seller records sales tax collected by crediting sales tax payable account at the time of sales whether it is cash sales or credit sales. Illustration 4.9: assume Building Materials Supply Enterprise sold 200 KGs of nails at Br 10 per kilo; 600 iron sheets at Br 40 per sheet and 700 cans of Tsedey Paint at Br60 per can on January 5, 2004. The goods are subject to sales tax at the rate of 15%. Record the transaction.  The journal entries are as follows:  Illustration 4.10: Assume Building Materials Supply Enterprise sold 500 cans of paint at Birr 60 per can to Lalibela Engineering on account, on January 10, 2004. The sale was subject to a sales tax of 15%. Journalize the transaction and the remittance of tax payable amount on January 5 and 10, respectively.  Total Price (Br 60 * 500 cans)\tBr 30,000.00 Sales Tax (Br 30000 * 15%)\t        4,500.00 Total Amount\t Br 3,4500.00  An Alternative Approach to Sales Tax: Instead of recording the sales tax liability at the time of sale, some businesses prefer to credit the sales with the entire amount collected including the sales tax and to make an adjustment at the end of each period to reflect sales tax payable. Illustration 4.11: suppose that the total amount recorded to the sales account including the sales tax for the period was Br 345000. If the sales tax rate is 15% make the necessary adjustment to record the sales tax liability at the end of the period. Total Amount-----Br 345,000.00 Sales Tax -------------- 15%  Sales + Sales Tax = 345,000.00 Sales + (Sales * Sales Tax Rate) = 345,000.00 Sales + 15% Sales =   345,000.00 Sales + 0.15 Sales = 345,000.00 1.15 Sales = 345,000.00 Sales = 345,000.00 / 1.15 Sales= 300,000.00                                       Sales + Sales Tax = 345,000.00 300000 + Sales Tax = 345,000.00 Sales Tax = 345000- 300000 Sales Tax= 45,000.00 Sales: Adjusting Entries: Payment: The Buyer:   Transportation Costs The terms of agreement between a buyer and seller include when the ownership of the merchandise passes to the buyer and which party is to absorb the cost of delivering the merchandise to the buyer. There are two most common terms with respect to this: FOB (Free on Board) Shipping Point and Destination. \t FOB Shipping Point: under this term the seller places merchandise “Free On Board” at the shipping point. Thus, The buyer pays transportation costs Ownership is transferred at point of shipment The goods are the property of the buyer after the point of shipment Any risk is absorbed by the buyer while the goods is in transit  FOB Destination: under this term the seller places merchandise “Free On Board” at the buyer’s final destination by paying the delivery costs. Thus,  The seller pays the transportation costs Title or ownership to the goods is transferred at the buyer’s location The goods are the property of the seller while in transit Any risk while the goods in transit is absorbed by the seller  When merchandise is purchased on terms of FOB shipping point, the transportation costs paid by the buyer is debited to Transportation In or Freight In or Purchases account. In some cases, the seller may prepay the transportation costs and add them to the buyer, even though the agreement is states that the buyer bear such costs (i.e. terms FOB shipping point). This is also debited to the same accounts as above.  When the agreement states that the seller is to bear the delivery costs (FOB Destination), the amount paid by the seller for delivery of merchandise is debited to Transportation Out or Freight Out or delivery Expense or a similarly titled account. The total of such costs incurred during a period is reported on the seller’s income statement as a selling expense and will not be included in the cost of goods sold. Illustration 4.12: on February 1, 2004 RR Trading Company purchased merchandise on account from KK Company for Br 12,000, terms FOB shipping point 2/10, n/30 and the buyer paid a transportation cost of Br 100 to XX Transportation Company. On February 12, RR Company paid cash to KK Co.     Illustration 4.13: On March 5, MM Company Purchased merchandise from JJ Company on account Br 8500 terms 1/10, n/30 FOB shipping point. JJ Company pays the transportation charges of Br 5000. Instructions: At the date of purchase If MM Co. returned some merchandise which have a cost Br 500 on March 9 If MM Co. paid cash to JJ Company on March 14  Illustration 4.13: on May 1, 2004 Melat Private Limited Company sold merchandise to Belule Private Limited Company on account for Br 90,000 terms FOB destination 2/10, n/30. The seller paid Br 4,000 to TT Transport Share Co. and received the amount on May 10. Instructions: journalize the above transactions:  Exercise 4.3: MEWIT (Merchandise Whole Sale and Import Trade Enterprise) sold to BMSE on account, list price Br40000, trade discount 20%, sales tax 5%, term 3/10, n/30, FOB Shipping Point. The seller pays transportation cost of Br 1000 and adds it to the invoice and the seller issues the credit memorandum for Br 5000 merchandise returned and subsequently receives the amount within the discount period. Record the transactions for both parties    Periodic Reporting and Merchandise Inventory System Periodic Reporting The sequence of year end procedures may be changed slightly, but in general the following outline is typical: Prepare a trial balance of the ledger on a worksheet form Review the accounts and gather the data required for the adjustment Insert the adjustments and complete the work sheet Prepare financial statements from the data in the worksheet Journalize the adjusting entries and post to the ledger Journalize the closing entries and post to the ledger Prepare a post closing trial balance of the ledger  Merchandise Inventory Systems The system through which you can determine CGS and Cost of Ending Inventory is called inventory system. The two main systems for accounting for merchandise held for sale are the periodic inventory system and the perpetual inventory system.  The Periodic Inventory System and Determination of Cost of Merchandise Sold In this system: The purchase of merchandise is debited to purchases account  The revenue from sales is recorded when at sale was made but no attempt is made to record the cost of merchandise sold The cost of Ending Inventory is determined by taking a physical inventory (counting the merchandise at hand or unsold and multiplying by its unit price). The cost of merchandise sold (CMS) is determined as follows: Merchandise Inventory (Beginning)\txxxxx Add: Purchases\t xxxxx Less: Purchase Return & Allow\t(xxxxx) Less: PD\t (xxxxx) Net Purchases\t  xxxxx Add: Freight in\t  xxxxx Cost of merchandise purchased\txxxxx Cost of Merchandise Available for sales (CMAS)\txxxxx Less: Ending Inventory\t(xxxxx) Cost of Merchandise Sold\t xxxxx  Adjustments in Merchandising Business Adjusting Merchandise Inventory Merchandise inventory account showed the inventory balance at the beginning of the period through out an accounting period if the business is using Periodic Inventory System. Purchases and purchases related account are recorded separately during the year and thus at the end of the period two adjusting entries are required to update merchandise inventory account. To adjust beginning inventory: To adjust ending inventory: Illustration 4.14: Assume from January 1, 2004, the merchandise inventory has a balance of Br 180,000 and the ending inventory on December 31 of the same year is Br 220,000. Instruction: journalize the adjusting entry Adjusting Beginning Inventory Adjusting Ending Inventory  Adjusting Deferrals and Accruals In merchandising business in addition to merchandise inventory, deferrals and accruals are adjusted. This will be discussed in next chapter.   Worksheets For Merchandising Businesses After all transactions for the year 2004 were recorded and posted, the accounts in the ledger of Far East Trading Corporation appeared with the following unadjusted balances. See the Trial Balance on the next Page. The data needed for year end adjustments on December 31 are as follows:  Merchandise Inventory on December 31, 2004\tBr 150,500.00     \t Insurance expired during the year\t          6,400.00\t Store supplies inventory on December 31, 2004\t          2,150.00\t Depreciation for the current year\t         19,200.00\t Accrued Sales Salaries on December 31, 2004\t           2,800.00\t Accrued Office Salaries on December 31, 2004\t           1,300.00 Required: Complete the worksheet Prepare Income statement in Single- step and Multiple- step forms Prepare a Retained earnings Statement Prepare a classified Balance sheet, in a Report form Record the necessary year end adjusting and closing entries on general journal Page 1\t Prepare a Post- closing trial balance\t\t     Financial Statements For Merchandising Businesses Prepare Income Statement In Single- Step And Multiple- Step Forms Multiple-Step Income Statement    Single Step Income Statement \t\t\t\t\t\t\t Prepare a Retained Earnings Statement Prepare a Classified Balance Sheet  Adjusting and Closing Entries Adjusting Entries Closing Entries Post Closing Trial Balance   Corrections of Errors If there is error in recording transactions or posting to ledger accounts, it will be corrected through correcting entries. For example a debit purchases account may be debited to plant asset account while the credit is correctly recorded. Thus, the correcting will debit purchases account and credit the plant asset account so that the error will be corrected.   Chapter Five Deferrals and Accruals  Adjusting for Deferrals Deferrals are an expense that has already been paid or revenue that has already been received. Deferrals are created when we record a transaction in the way that it delays or defers recognition of an expense already paid or revenue already received. Deferrals include deferred expense (prepaid expense) and deferred revenue (unearned revenue).  Deferred Expense(Prepaid Expense) Deferred Expense is an expense that has been paid but delayed for recognition. At the time an expense is paid, it may be debited either to an asset account or to an expense. Examples: supplies, prepaid insurance, prepaid rent, prepaid interest, etc. Deferred Expense may initially be recorded as an asset or as an expense.  Prepaid Expense Initially Recorded As an Asset   Advance payments or prepayments for deferred expense is recorded as debits to the appropriate asset account even though all or a part prepayment is expected to be used or consumed during the accounting period. Thus, The adjusting entry transfers the amount used or expired during the period to the expense account The amount unused remains in asset account Reversing entry is not required  Illustration 5.1: assume that the unexpired insurance for OLYMPIC Company on January 1, 2003 amounted to Br 7,000. On January 2, the Company purchased additional insurance policy for a total of Br 12,000. Assume further that Br 14,000 of the premium or the insurance policy is expired during the year and the Company follows the system of recording prepayment for insurance as an asset. Record the Transactions:  Prepaid Expense Initially Recorded As an Expense   In this method: Prepayments for deferred expense is debited to the expense accounts The adjusting entry transfers the amount unused or unexpired from expense account to the asset account The amount expired or used remains in the expense account and closed at the end. Reversing entry is required- an entry which is made at the beginning of the period to comply with the initial recording system and the exact reverse of the adjusting entry   Illustration 5.2: Assume all the data in the above illustration except that the business follows the system of recording prepaid insurance as an expense and that the insurance policy that applies to the future period is found to be Br 5,000. Record all the necessary transactions: NOTE: In this system the assets account will have a zero balance where as the expense will have a balance. This balance is not an expense rather it is an asset. Reversing entry transfers the amount unused back to an expense account i.e. the amount in prepaid insurance at the beginning of the new period is transferred to the expense.   Deferred Revenue (Unearned Rent) Deferred revenue is revenue that has been received but delayed for recognition. Deferred revenue includes money received in advance such as magazine subscription, tuition fee revised by school, universities or college, money received by advertising companies. Deferred Revenue is initially recorded either as an asset or as an expense.  Deferred Revenue Initially Recorded As a Liability   If Deferred Revenue is initially recorded as a liability, then: The adjusting entry transfers the amount earned  during the period from the liability  to the revenue account The amount unearned remains in the liability account Reversing entry is not required Deferred Revenue Initially Recorded As an a Revenue   In this method: Cash received in advance is credited to the revenue accounts The adjusting entry transfers the amount unearned from the revenue account to the liability account The amount earned remains in the Revenue account and closed at the end Reversing entry is required    Illustration 5.3: On November 1, 2004 OLYMPIC COMPANY rented the portion of its building by receiving Br 1200 in advance for three months time. The fiscal period ends on December 31, 2004 Instruction: Make the necessary journal entries assuming that the system of recording Unearned Rent initially as a revenue and as liability:   Adjusting for Accruals An accrual is an expense that has been incurred but not paid or revenue that has been earned but not received. Accruals include accrued expense (accrued liability) and accrued revenue (Accrued Asset).  Accrued Expense or Accrued Liability Illustration 5.4: assume that on December 31, 2003 the end of fiscal year sales salary expense and office salary expense account for XYZ PLC have debit balances of Br 86,000 and 60,000, respectively. For the reason that payment date is different from the end of the accounting period, the total salary accrued is Br 10,000 out of which 4,000 was office salary expense. Assume that the business paid Br 20,000 on January 15, 2004 out which Br 8,000 was for Office salary Expense including the accrued salary. Instruction: Record all the necessary entries assuming that the business: Does not use the policy of reversing entry Uses the policy of reversing entry  Without Reversing Entry: With Reversing Entry:  Illustration 5.5: On November 1, 2003 AA Company borrowed Br 60000 from CBE issuing a promissory note payable showing 12% interest where by the loan and interest will be paid after four months (March 1, 2004). The company has a fiscal period that ends on December 31 and the interest expense account has a balance of Br 17000 at year end. Make the necessary journal entries for the Company assuming that the company:  does not use the reversing entry  use the policy reversing entry With Out Reversing Entry: With Out Reversing Entry:  Accrued Revenue or Accrued Assets These are items of revenue that have been earned at the end of the accounting period but not recorded because cash is not received. Since the business recognizing both revenue and assets it is so called Accrued Revenue or Accrued Assets.  Illustration 5.6: On September 1, 2000 BB Auditing Firm entered into a contract with Dire-Dawa Food Complex to provide auditing service for 6 months for a total of Br 36,000 Payable when the service is completed. The fees income account of the firm has a credit balance of Br 126,000 and that the firm has a fiscal year ending on December 31. Make the necessary journal entries for the firm assuming that Reversing Entry is not Used Reversing Entry Is Used  With No Reversing Entry:  With Reversing Entry:     Chapter Six Accounting Systems Design Accounting system is a system which provides the information for use in conducting the affairs of the business and in reporting to owners, creditors and other interested parties. In a general sense, an accounting system includes the entire network of communications used by a business organization to provide needed information. It consists of business paper (source document), records (journals and ledger) and reports (financial statements).  Principles of Accounting Systems Because of differences in businesses, in number of transactions to be processed and in the uses made of accounting data, accounting systems will vary from business to business. How ever, there are a number of broad principles that are discussed as follows and apply to all systems: Cost- Effectiveness Balance The major considerations in developing or designing an accounting system are cost effectiveness. That is to balance the benefits against the cost information. Cost of information at least should be equal to the benefit of information Flexibility to Meet Future Needs An accounting system must be flexible enough to meet changing demands of the businesses world. The business must adapt to the constantly changing environment in which it operates. For example, changes in accounting principles or data processing technology or other factors should comply with the government regulations. Adequate Internal Controls An accounting system must provide information which help management in planning and controlling activities. The system should aid management in directing operations. The detailed policies and procedures used to direct operations and provide reasonable assurance that entity’s objectives are achieved are called internal controls. An accounting system should show any deviation from the internal controls structure. Effective Reporting When reports (financial Information) are prepared, the requirements and knowledge of the user should be recognized. For example, management may need detailed basis, and regulatory agencies often require uniform data. Adaptation to Organizational Structure Different businesses may have different organizational structure and level of management. There fore, an accounting system that goes with the organizational structure must be designed to meet the information needs of all level of management at the lowest cost.  Accounting System Installation and Revision Before designing and installing or reviewing an accounting system for an enterprise, the designer must have a complete knowledge of the business operations. The designer should recognize that some areas of the system, such as the types and design of the forms needed and the number and titles of the accounts required, maybe affected by factors that are not known when a business is first organized. As new information about a business is obtained and as a basins “out grows” or expands to new operational areas, the system will need to be revised.  Many large businesses continually review their accounting system and may constantly be involved in changing some part of it. The job of installing or changing an accounting system, either in its entirety or only in part, is made up of three phases: System Analysis System Design and  Implementation  System Analysis The goal of system analysis is to determine information needs and sources of such information, and deficiencies in procedures and data processing methods presently used. The system analyst should determine management’s plans for changes in operations such as volume, products, territories, etc. System Design This deals with determining the requirement of the new system and changing it based on the result of the system analysis. In this stage a proposal for the new system is prepared and finalized. System Implementation The final stage of the creation or revision of an accounting system is to carry out, or implement the proposals fro the new system. It includes: Installing new or revised forms, records, procedures and equipment Training and supervising all personnel responsible for operating the system until satisfactory efficiency is achieved. The old system is changed over time by new system. This is done gradually over an extended period rather than all at once. Weakness and conflicting or unnecessary elements in the design may also become apparent during the implementation.     Internal Control Principles and Structure  Internal control structure consists of the policies and procedures established to provide reasonable assurance that the entity’s objective will be achieved. This internal control structure can be divided into three elements: (1) the control environment, (2) the control procedures, and (3) the accounting system, each of which is discussed as follows:  The Control Environment The control environment represents an overall attitude toward and awareness of the importance of controls by management and other employees. Factors influencing the control environment of an enterprise include management’s philosophy and operating style, the organizational structure of the enterprise and personnel policies and practices.  The Control Procedures The general control procedures (strong internal control guidelines) which apply to all organization through an accounting system are: Competent Personnel and Rotation of Duties  All accounting system requires procedures to ensure that people are able to perform the duties to which they are assigned. It is also advisable to rotate clerical personnel periodically from job to job. Assignment of responsibility If employees are to work efficiently, their responsibilities must be clearly defined Separation of responsibility The responsibility for a sequence of related operations should be divided among two or more persons. For example, no one individual should be authorized to order merchandise, verify the receipt of the merchandise and pay the supplier. That is purchasing, receiving and payment should be separated. The business documents prepared as a result of the work of each department must fit with those prepared by the other departments Adequate Documentation There is control without adequate documentation.  Separation of accounting and operations The responsibility for maintaining the accounting records should be separated from the responsibility for engaging in the business transaction and for the custody of the firm’s asset. A cashier should be not having access to the journal and ledger. Proofs and Security Measures This control procedure includes the use of bank account and safekeeping measures for cash and other valuable documents, cash registers machine to record daily cash sales and fidelity insurance. Independent Review To determine whether internal control procedures are being effectively applied, the control structure should be periodically reviewed and evaluated by internal auditors. Internal auditors should report any weakness and recommend changes to correct them  The Accounting System The Accounting system is an integral part of the internal control structure of an enterprise. Without the information generated by the accounting system, management would lack the ability to plan and direct operations in achieving goals and objectives.  Data Processing Methods: Special Journals and Subsidiary Ledgers Depending upon the variety and the amount of data included in the database, various processing methods- manual and computerized may be used. These processing methods may use special journals and subsidiary ledgers to process an accounting data.  Special Journals: are journals used to record only one type of transaction. It is especially useful to accumulate a transaction with recurrent nature. This saves time and costs. For example: most businesses use the following four special journals: Purchases journal Cash payment journal Sales journal Cash receipts journal  Subsidiary Ledgers: ledgers that are used to provide detail information about a general ledger accounts. Subsidiary ledgers may include accounts receivables, account payables, subscriber’s subsidiary ledgers, stock subsidiary ledgers, etc.             '}, {'name': '2021-02-20 -- Chapter 1.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS485/Notes', 'content': 'Chapter 1: Information Retrieval  Information Retrieval System Web search systems: Lycos, excite, yahoo, google, live, northern light, Teoma, HotBot, Baidu Are systems that retrieve documents (web pages) in response to a query Understanding what goes on behind the scenes in IRSes… How to broad web-pages relate, connect, communicate with an IRS? Basically, the system is working on documents and the documents are on the web. The way to get the information off the webpages is by a spider (web crawler). This crawler goes through web pages and gets every document (gets a copy of it) and generates a “document corpus” that is then transferred to the IRS. The two inputs of an IRS are the document corpus and the query string Using those two inputs, the IRS generates a “ranked document” which basically means results from the document corpus based on the query string that are ranked by relevance. The query string gets processed while the document corpus gets represented A similarity calculation is then conducted to find the most relevant document and ranked as such based on a higher similarity score Information Retrieval System – Definition Is an important sub-discipline of information science/Computer Sciences that is concerned with developing theories and methods of access to information Focus is on helping user find information that matches their information need (User Centered View) Is a branch of applied Computer Science that focus on representation, storage, organization of, and access to information items (System Centered View). The definition incorporates all important features of a good information retrieval system Representation Storage (how to effectively organize) Organization (how to effectively organize) Access Evaluation Documents information items: usually text, but possibly also image, audio, video, etc. IR from different perspectives Conceptually,  IR is used to cover all related problems in finding needed information Historically, Information retrieval is about document retrieval, emphasizing documents as basic units Technically, Information retrieval refers to (text) string manipulation, indexing, matching, querying, etc. Can be structured for ease of discussion as Text IR Discusses the classic problem of searching a collection of documents for useful information Focuses is on document images that are predominantly text (rather than text) These are called textual images and are amenable to automatic extraction of key words. Multimedia IR Discusses how to index document images and other binary data by extracting features from their content and how to search them efficiently Human computer interaction (HCI) for IR Discusses current trends in IR towards improved user and better data visualization tools Applications of IR Covers modern applications of IR (such as the Web, bibliographic systems, and digital libraries) Entities in IRS Two important entities Information need: to be represented by search statements (query) Information need is the gap between what you know and what you want to know. Information items (documents): to be represented by index terms for any form of representation like summary The information item is anything with content embedded that has to be represented by the indexer. Thus, the process in IRS is matching these abstractions. We need documents to be broken down into index terms because users can’t search using documents; so ultimately, the documents will need to be broken down into terms Key Issues IR Organizing How to describe information resources or information-bearing objects in ways so that they may be effectively used by those who need to use them Retrieving How to find the appropriate information resources or information-bearing objects for someone’s (or your own) needs. Build a system that retrieves documents that users are likely to find relevant to their queries IR is an Iterative Process – Basic theory Stages The information creation stage The searching stage The utilization stage The IR deals with Organizing and Indexing, Accessing and Retrieving, and … Implementation This in order to meet the above key issues the implementation is developing an Inforamtion System Retrieval system IR deals with very large sets of documents High amount of robustness, efficiency Domain-independent and multi-linguality IR usually deals with Natural Language text which is not always well structured and could be semantically ambiguous. IR considers Natural Language text mainly from a lexical view. Identifying possible word forms Elimination of stop words (e.g. the, of zu, …) Stemming (e.g., supporting, supported support) Finding the root forms of source words. (from a destination perspective) Selection of index terms Term weighting. The Retrieval Process The high-level interpretation is that web pages are inputs to spiders which in turn give inputs to an index which in turn accepts the query from a user-facing interface and gives out relevant documents. Factors Affecting Effective Retrieval The effective retrieval of relevant information is directly affected by two things The user tasks The logical view of the documents adopted by the retrieval system. The user task: the user task might be one of retrieval or browsing Retrieval Information or data Information need (retrieval goal) is focused and crystalized, purposeful, often user sophisticated Browsing/surfing Information need (retrieval goal) is vague and imprecise Glancing around, often user is naïve Logical View of Documents The logical view of documents Full text Any point in between full text and index terms Index terms.  '}, {'name': '2021-03-02 -- Content-Subject Analysis and Representation.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS485/Notes', 'content': 'Content/Subject Analysis and Representation Content Analysis Automated transformation of raw text into a form that represents some aspect(s) of its meaning. Including but not limited to: Term selection (index term) Automated thesaurus generation Categorization/Clustering Summarization  … Knowledge Organization Tools Index (document containing representatives of information items) Classification schemes (are tools that are designed to provide a hierarchical arrangement of numeric or alphabetic notation to represent (wide) topics. Divide a particular subject into successive classes and sub-classes, with chosen characteristics as the basis for each stage. Possible examples are DDC, LCC Subject heading lists (are knowledge organization tools which are designed to provide a set of controlled (managed) terms to represent the subject content of items in a collection) Authority files (are a list of terms that are used to control (manage) variant forms of personal, geographical, or organizational names and details) Thesauri (s a document that shows the relationship between the terms) Next Class: Indexing. '}, {'name': '2021-02-27 -- Subsystems.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS485/Notes', 'content': 'Subsystems There are generally two types of subsystems, a Searching Subsystem and an Indexing Subsystem TODO: FILL IN FROM PREVIOUS SLIDES  Components of an IRS At a higher level, an IRS has an Indexing Subsystem and a Searching Subsystem There is also an additional component, the spider/crawler  ….    Database Systems Vs. Information Retrieval Systems KMS (Knowledge Management Systems) DMS (Database Management Systems) To use Entities and use properties to describe them. IRS (Information Retrieval Systems) The purpose is to represent the document itself These all work on the knowledge hierarchy.  E.g. we don’t name people with numbers cause unwritten rules  E.g. red light means stop.  E.g. the reason traffic lights are red because some experts have studied patterns and decided on it. E.g. Computer Scientists and Psychologists have a different understanding on saving files. Comp. Sci. people would know in depth the process while the Psych. People would not have such a deep understanding. Knowledge is either tacit or explicit  DMS works on more structured data while IRS might work on any data IRS focuses on content/document while DMS works more on the entity itself IRS is more complex than DMS because DMS works more with data storage and retrieval while IRS works more on processing data on a more in-depth level. On the information/data DBMS: structured data (often homogeneous records), semantic unambiguity IRS: unstructured (free text), ambiguity On the answers/results DBMS: Records (tuples), perfect precision and recall ,each item is relevant (no ranking), well defined results IRS: Documents, imperfect precision and recall, each item has a specific relevance (ranking), fuzzy results On their relationship Systems complement each other On their history DB grew out of files and traditional business system IR grew out of library science and need to categorize/group/access books/articles  A document containing some words about information retrieval can be considered relevant for any search about information retrieval Means that any small amount of information is enough to search. Data retrieval Records contain a set of keywords Well defined semantics A single erroneous object implies failure! Information retrieval Information about a subject or topic Semantics is frequently loose Small errors are tolerated Because the representation and search are not 100% accurate, we should tolerate some errors. IRS: Interpret contents of information items Generate a ranking which reflects relevance Information retrieval is much more difficult than data retrieval  '}, {'name': '2021-02-22 -- Logical view of Documents.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS485/Notes', 'content': 'Logical view of Documents Documents in a collection are frequently represented through a set of index terms or keywords An index term is a key word (or group of related words) which has some meaning of its own (which usually has the semantics of a noun) In its more general form, an index term is simply any word which appears in the text of a document collection It is simply a word whose semantic helps in remembering the documents main theme How to generate index terms? (will be discussed in the next chapter) Key words might be extracted directly from the text or the document or Keywords might be specified by a human expert (this is frequently done in the information science arena) No matter whether these representative keywords are derived automatically or generated by a specialist, they provide a logical view of a document (concise logical view) Modern computers make possible to represent a document by its full set of words In this case, we say that the retrieval system adopts a full text logical view (or representation) of the documents With very large collections, however, modern computers might have to reduce the set of representative keywords This can be accomplished through the following standard steps: Recognizing document structures (titles, sections, paragraphs, etc.) Break into tokens Usually space and punctuation delimited Special issues with some languages The elimination of stop-words (such as articles and connectives) Conflation: the use of stemming/morphological analysis Purpose: overcome the variants of word forms by reducing all words in the same root, i.e., (which reduces distinct words to their common grammatical root) Most IR systems perform stemming on both text and query The identification of noun groups (which eliminates adjectives, adverbs, and verbs) Other further operations can also be performed Store in an inverted index Such text operations reduce the complexity of the document representation and allow moving the logical view form that of a full text to that of indexed terms Index – a list of important key words from the documents The full text is the most complete logical view of a document, bit its usage usually implies higher computational costs Given a set of index terms for a document, we notice that not all the terms are equally useful for describing the document contents There are index terms that are simply vague than the others Deciding on the importance of a term for summarizing the contents of a document is not a trivial issue Despite this difficulty, there are properties of an index term Examples of such properties A word which appears in each of the one hundred thousand documents is completely useless as an index term because it does not tell us anything about which documents the user might be interested in A word which appears in just five documents is quite useful because it narrows down considerably the space of documents which might be of interest to the user Thus, distinct index terms have varying relevance when used to describe the document contents This effect is captured through the assignment of numerical weights to each of the index term of a document. Challenges in IR Why is IR a difficult problem? Finding very specific information using general key words might be hard because of the way index terms are weighted Possible inefficiencies in the steps between understanding the users’ query and parsing the document corpus efficiently to extract the right information. …. The size of the web is doubling every year: 50 million pages in November 1995, 320 million pages in December 1997, 800 million pages in February 1999, 1 billion pages in 2000, and growing every day Huge amount of data (e.g., WWW) dictates efficiency, effectiveness and user-friendliness) Unstructured data: difficult to capture the semantics in documents. Documents have unrestricted domains It is hard to predefine or pre-categorize the subject domains of documents A particular subject is related to several major topics including Linguistics, Psychology, Cybernetics, Communications, Information System design, Engineering & Technology, Networking, Computer Science, Mathematics, Economics, Management Science, Education… Diversified user base: expert to casual users The users of information retrieval systems include Research scientists (that seek articles related to particular experiments) Engineers (who try to determine whether a patent is covering some new idea has previously been obtained) Attorney (who search for legal presidents) Buyers in general (who try to obtain new product material) Distributed and interlinked (e.g., hypertext and WWW) Where to start a search? Unlike in a centralized database, you have only one (or a few) databases to search How are the information related? Efficiency vs. effectiveness With a limited amount of resources, one can only improve efficiency and effectiveness to a certain degree. Moreover, improving efficiency often means degrading effectiveness, and vice versa. Efficiency means how fast or quick things get done while effectiveness is about how well the work is done. Information Retrieval System: Components, Structures and Functions What is a system? A collection of interrelated components working together to achieve a goal. Is a set of interrelated components interacting together to achieve an objective. Has basic characteristics like: Input, output, environment, boundary, objectives, components, interaction, interface Can be living or non-living What is “systems thinking”? The act (art?) of seeing (everything in) the world as a system Do you agree with this? “a system is bigger than the sum of its components” The reason the system is bigger than just the sum of its components is because of the link. The interaction, interrelation. Systems thinking Is a mind set or way of thinking to view the world as a system. It emphasizes on interaction that keeps the system alive. Benefits Identification of a system leads to abstraction From abstraction y outthink about essential characteristics of a specific system IRS Is a system that is capable of storage, retrieval, and maintenance of information items The process of an IR system is to match two abstractions Index terms/key words abstracted from information items Queries abstracted from the users’ needs The purpose of an IRS is to capture wanted items (information) and to filter out unwanted information. Because we want to avoid information overload. We want the search engine to give us ONLY the relevant data and filter out the unwanted stuff. Present results in format that helps user determine relevant items Arbitrary (physical) order Relevance order Basic functions of an IRS User need Analysis and parsing of user need Documents Parsing and indexing of documents Analysis of a document and organization of information (creation of document database) Analysis of users’ preparation of a strategy to search the database Actual searching or matching of users queries with database Retrieval of items that fully or partially match the search statement A crawler: Basics of crawlers Definition: A web crawler is a computer program that browses the World Wide Web in a methodical, automated manner. Utilities: Gather pages from the web. Support a search engine, … '}, {'name': '2020-02-08 -- Course Outline.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS485/Notes', 'content': 'Information Retrieval What is information retrieval? The process of actively seeking out information relevant to a topic of interest (van Rijsbergen) Typically, it refers to the automatic (rather than manual) retrieval of documents Information Retrieval System (IRS) A good example for these are Search Engines Also includes technical aspects “Document” is the generic term for an information holder (book, chapter, article, webpage, etc.) Our focus will be on automatic information retrieval. There is no standard structure for all the created information. Any system that can index and organize information and then make it searchable or browsable would qualify as an Information Retrieval System What is the course about? How people search and find information The focus of the course is mainly here as it is a technical course. How computers store and retrieve information How computer systems are designed to help people find information they need. Motivation (Why this course)? Because of the availability of the huge amount of information Information overload caused by the large amounts of information Difficulties in accessing the right information at the right time/context. Course Objective: The general objective of the course is to let students understand the motivation, mechanisms, and potential of information storage and retrieval. In line with this, at the end of the course, students are expected to: Know the basic theories and principles of knowledge organization and information retrieval Understand the process of Information Storage and Retrieval Acquire qualities to study and analyze Information Retrieval Systems designed using various models Be familiar with evaluation issues in Information Retrieval. Course Outline (What we’ll be doing): Information Storage and Retrieval (ISR): Basic Concepts Content (subject) analysis and Representation Standardization and Identifying term importance Models of Modern IR Systems Evaluation of Information Retrieval System Current areas of research in Information Retrieval (week) Evaluation Course work (Assignments) – search engine evaluation or SE component development (20%) Mid exam (25%) Final exam (50%) Class participation and attendance (5%) Lecture notes and other resources Course website:  The course emphasizes on the understanding of Theories (the why and how of things) Tools/Components (lexical analyzers, stemmers, etc.) Algorithms (ranking, matching, clustering, etc.) and Evaluation of Information Retrieval Systems What the course is NOT An algorithm design course We might use several related algorithms, not study them in detail System development course Except some assignments may require you to write or compile some C, C++, java, etc. procedures. We look at an IR system as a while not as individual components. Knowledge Useful for the Course Mathematics (set theory, probability, vector algebra) Data / File structure Linguistics (read papers on Linguistics in Information Science) Like identifying the root word by removing affixes and suffixes. System Analysis & Design / Software engineering Programming in higher level languages such as C, C++, Java, VB, etc. What IR assumes? Information is stored (or available) A user has an information need. An automated system exists from which information can be retrieved The system works '}, {'name': 'CS363-Operating Systems_Modified.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Lecture Slides', 'content': ' COURSE CONTENT Introduction What Operating Systems Do Computer-System Organization, Architecture, Structure, and Operations Operating System Structures Processes and Process Management The Process Concept Theads Interprocess Communication Process Scheduling Deadlocks  Memory Management Introduction Fixed Partitions Variable Partitions Virtual Memory File Systems The User’s point of view Implementation point of view Disk Management Input/output Principles of I/O Hardware Principles of I/O Software Security and Protection Overview Threats, Intruders, Accidental Data Loss Possible Solutions  '}, {'name': '2021-02-15 -- Operating System Operations.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Operating System Operations Interrupt driven (hardware and software) Software interrupt (exception or trap): Software error (e.g. division by zero) Request for operating system service Other process problems include infinite lop, processes modifying each other or the operating system Dual-mode operation allows OS to protect itself and other system components User mode and kernel mode Mode bit provided by hardware Provides ability to distinguish when system si running user code or kernel code Some instructions designated as privileged, only executable in kernel mode. System call changes mode to kernel, return from call resets it to user Increasingly CPUs support multi-mode operations i.e. virtual machine manager (VMM) mode for guest VMs Computing Environments – Traditional stand-alone general-purpose machines but blurred as most systems interconnect with others (i.e., the Internet) portals provide web access to internet systems Network computers (thin clients) are like web terminals Mobile computers interconnected via wireless networks Networking becomes ubiquitous – even home systems use firewalls to protect home computers from internet attacks Computing Environments – Mobile Handheld smartphones, tablets, etc Whatis the functional difference between them and a “traditional” laptop? Extra feature – more OS features (GPS, gyroscope) Allows new types of apps like augmented reality Use IEEE 802.11 wireless, or cellular data networks for connectivity Leaders are Apple IOS and Google Android  Computing Environments – Distributed Distributed computing Collection of separate, possibly heterogeneous, systems networked together Network is a communications path, TCP/IP most common Local Area Network (LAN) Wide Area Network (WAN) Metropolitan Area Network (MAN) Personal Area Network (PAN) Network Operating System provides features between systems across network Communication scheme allows systems to exchange messages Illusion of a single system Computing Environment – client-Server Client-Server computing Dumb terminals supplanted by smart PCs  Many systems now servers, responding to requests generated by clients Compute-server system provides an interface to client to request services (i.e. database) File-server system provides interface for clients to store and retrieve files Computing Environment – Peer to Peer Another model of distributed system P2P does not distinguish clients and servers Instead all nodes are considered peers May each act as client, server or both Node must join P2P network Registers its service with central lookup service on network, or Broadcast request for service and respond to requests fro service via discovery protocol Examples include napster and Gnutella, Voice over IP (VoIP) such as skype Computing Environments – Virtualization Allows operating systems to run applications within other OSes Vast and growing industry Emulation used when source CPI type different from target type (i.e. PowerPC to Intel x86) Generally slowest method When computer language not compiled to native code- interpretation Virtualization – OS natively compiled for CPU, running guest OSes also natively compiled Consider VMware running WinXP guests Use cases involve laptops and desktops running multiple OSes for exploration or compatibility Apple laptop running Ma OS X host, Windows as a guest Developing apps for multiple OSes without having multiple systems QA testing applications without having multiple systems Executing and managing compute environments within data centers VMM can run natively, in which case they are also the host There is no general-purpose host then (VMware ESX and Citrix XenServer) Computing Environments – Cloud Computing Delivers computing, storage, even apps as a service across a network Logical extension of virtualization because it uses virtualization as the base for its functionality Amazon EC2 has thousands of servers, millions of virtual machines, petabytes of storage available across the Internet, pay based on usage Many types Public cloud – available via internet to anyone willing to pay Private cloud – run by a company for the company’s own use Hybrid cloud – includes both public and private cloud components Software as a service (SaaS) – one or more applications available via the internet (i.e. word processor) Platform as a Service (PaaS) – software stack ready for application use via the Internet (i.e. a database server) Infrastructure as a Service (IaaS) – servers or storage available over internet (i.e. storage available for backup use) Cloud computing environments composed of traditional OSes plus VMMs, plus cloud management tools Internet connectivity requires security like firewalls Load balancers spread traffic across multiple applications Computing Environments – Real-Time Embedded Systems Real-time embedded systems most prevalent form of computers Very considerable, special purpose, limited purpose OS, real-time OS Use expanding Many other special computing environments as well Some have OSes, some perform tasks without an OS Real-time OS has well-defined fixed time constraints Processing must be done within constraint Correct operation only if constraints met  Open-Source Operating Systems Operating systems made available in source-code format rather than just binary closed-source Counter to the copy protection and Digital Rights Management (DRM) movement Started by Free Software Foundation (FSF), which has “copyleft” GNU Public License (GPL) Examples include GNU/Linux and BSD UNIX (including core of Mac OS X), and many more Can use VMM like VMware Player (Free on Windows), VirtualBox (open source and free on many platforms) Use to run guest operating systems for exploration Operating-System Structures Operating System Services User Operating System Interface System Calls Types of System Calls System Programs Operating System Structure System Boot Objectives To describe the services oan operating system provides to users, processes and other systems To discuss the various ways of structuring an operating system Operating System Services Operating Systems provide an environment for execution of programs and services to programs and users One set of operating-system services provides functions that are helpful to the user: User interface – almost all operating systems have a user interface (UI) Varies between Command-Line (CLI), Graphics User Interface (GUI), Batch Program Execution – the system must be able to load a program into memory I/O operations File-system manipulation – the file system is of particular interest. Programs need to read and write files and directories, create and delete the Communications – Processes may exchange information, on the same computer or between computer over a network Communications may be shared memory through messages Error detection Another set of OS functions exist for ensuring the efficient operation of the system itself via resources sharing Resource allocation – when multiple users or multiple jobs running concurrently, resources must be allocated to each one of them Accounting – to keep track of which users use how much and what kinds of computer resources Protection and Security – the owners information stored in a multiuser or networked computer system may want to control use of that information, concurrent processes should not interfere with each other Protection involves ensuring that all access to system resources is controlled Security of the system from outsiders requires user authentication, extends to defending external I/O devices from invalid access attempts. User Operating System Interface – CLI CLI or command interpreter allows direct command entry Sometimes implemented in kernel, sometimes by systems program  User Operating System Interface – GUI User friendly desktop metaphor interface Usually mouse, keyboard, and monitor Icons represent files, programs, actions, etc Various mouse buttons over objects in the interface cause varios actions (provide information, options, execute function, open directory (known as a folder) Invented as Xerox PARC Many systems not use both CLI and GUI interfaces Microsoft Windows is GUI with CLI “command” shell Apple Mac OS X is “Aqua” GUI interface with UNIX kernel underneath the shells available Unix and Linux have CLI with optional interfaces (CDE, KDE, GNOME) Touchscreen Interfaces Touchscreen devices require new interfaces Mouse not possible or desired Actions and selection based on gestures Virtual keyboards for text entry Voice commands.  System Calls Programming interface to the services provided by the OS Typically written in high-level language (C or C++) Mostly accessed by programs via a high-level API rather than direct system call use Three most common APIs are Win32 API for Windows, POSIX API for POSIX-based systems (including virtually all versions of UNIX, Linux and Mac OS X) and Java API for the Java virtual machine (JVM) Types of System Calls Process control Create process, terminate process End, abort Load, execute Get process attributes, set process attributes Wait for time  Wait event, signal event Allocate and free memory Dump memory if error Debugger for determining bugs, single step execution Locks for managing access to shared data between processes File management Create file, delete file Open, close Read, write, reposition Get and set file attributes Device management Request device, release device Read, write reposition Get device attributes, set device attributes Logically attach or detach videos Information maintenance Get time or date, set time or date Get system data, set system data Get and set process, file, or device attributes Communications Create, delete communication connection Send, receive message if message passing model to host name or process name From client to server Shared-memory model create and gain access to memory regions Transfer status information Attach or detach remote devices Protection Control access to resources Get and set permissions . Next class: Ssytem Programs '}, {'name': 'Indexing.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Indexing Is the art of organizing information. Is an association of descriptors (keywords, concepts, metadata) to documents in view of future retrieval. Is a process of constructing document surrogates by assigning identifiers to text items. Is the notion of storing data in a particular way in order to locate and retrieve the data as effectively as possible It is the process of analyzing the information content in the language of the indexing system, which is used in IRS. Give access point to a collection that are expected to be most useful to the users of the information. Indexing: From text to index Whether it used by human being or by a machine, its essences is a list of index entries. Index term is a word of phrase in a document whose semantics gives an indication of the document scheme  It might be single word or multi-word phrases. And are mainly nouns (because nouns have meanings by themselves) Each index entry leads to an indexed item somewhere outside the index; for instance, to a record in a database, to a folder in a file drawer or to an item in a container. '}, {'name': '2021-03-04 -- CPU Scheduling.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'CPU Scheduling Basic Concepts Maximum CPU utilization obtained with multiprogramming CPU – I/O Burst Cycle – process execution consists of a cycle of CPU execution and I/O wait CPU burst followed by I/O burst CPU burst distribution is of main concern Body Short-term scheduler selects from among the processes in the ready queue, and allocates the CPU to one of them Queue may be ordered in various ways CPU scheduling decisions may take place when a process: Switches from running to waiting state Switches from running to ready state Switches from waiting to ready Terminates Scheduling under 1 and 4 is non-preemptive All other scheduling is preemptive Consider access to shared data Consider preemption while in kernel mode Consider interrupts occurring during crucial OS activities Dispatcher Dispatcher module gives control of the CPU to the process selected by the short-term scheduler, this involves: Switching context Switching to user mode Jumping to the proper location in the user program to restart that program Dispatch latency – time it takes for the dispatcher to stop one process and start another running Scheduling Criteria CPU utilization – keep the CPU as busy as possible Throughput – number of processes that complete their execution per time unit Turnaround time – amount of time to execute a particular process Waiting time – amount of time a process has been waiting in the ready queue Response time – amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment) Scheduling Algorithm Optimization Criteria Max CPU utilization Max throughput Min turnaround time Min waiting time Min response time Frist-Come, First-Served (FCFS) Scheduling Supposed that the processes arrive in the order P1, P2, P3 Waiting time for P1 = 0; P2 = 24; P3 = 27 Average waiting time  Suppose that the processes came in the order: P2, P3, P1 The waiting time for P1 = 6, P2 = 0, P3 = 3 The average waiting time will be  Shortest-Job-First (SJF) Scheduling Associate with each process the length of its next …. … …. … Shortest-Remaining-Time-First This one works by determining the burst time and picking the smallest one.   P5 -> P1 -> P4 -> P3 -> P2  P1 -> 4 -> P5 -> 5 -> P1 -> 7 -> P4 -> 10 -> P3 -> 17 -> P2 -> 25  Average waiting time   Priority Scheduling A priority number (integer) is associated with each process The CPU is allocated to the process with the highest priority (smallest integer = highest priority) Preemptive Non-preemptive SJF is priority scheduling where priority is the inverse of predicted next CPU burst time Problem = Starvation – low priority processes may never execute Solution = Aging – as time progresses increase the priority of the process Round Robin (RR) Each process gets a small unit of CPU time (time quantum q), usually 10-100 milliseconds. After this time has elapsed, the process is preempted and added to the end of the ready queue. If there are n processes in the ready queue and the time quantum is q, then each process gets 1/n of the CPU time in chunks of at most q time units at once. No process waits more than (n-1)q time units Timer interrupts every quantum to schedule next process Performance  q large => FIFO q small => q must be large with respect to context switch, otherwise overhead is too high Next Class: Multi-Level Queue & Deadlocks  '}, {'name': '2021-03-08 -- Multilevel Queue.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Multilevel Queue Ready queue is partitioned into separate queues: Foreground (interactive) Background (batch) .. … … Multilevel Feedback Queue A process can move between the various queues; aging can be implemented this way Multilevel-feedback-queue scheduler defined by the following parameters: Number of queues Scheduling algorithms for each queue Method used to determine when the upgrade a process Method used to determine when to demote a process . . Example Three queues: Q0 – RR with time quantum 8ms Q1 – RR time quantum time 16ms  Q2 – FCFS Scheduling A new job enters queue Q- which is served FCFS When it gains CPU, job receives 8ms If it does not finish in 8ms, job is moved to Q1, At Q1 job is received again served FCFS and receives 16 additional milliseconds If it still does not complete, it is preempted and moved into queue Q2 Deadlocks Objectives To develop a description of deadlocks, which prevents …. … System Model System consists of resources Resource types R1, R2, …, Rm CPU cycles, memory space, I/O devices Each resource type R1 has W1 instances Each process utilizes a resource as follows: Request Use Release Deadlock Characterization Deadlock can arise if four conditions hold simultaneously. Mutual exclusion: only one process at a time can use a resource Hold and wait: a process holding at least one resource is waiting to quire additional resources held by another processes No preemption: a resource can be released only voluntarily by the process holding it, after that process has completed its task Circular wait: there exists a set {P0, P2, …, Pn} of waiting process such that P0 is waiting for a resource that is held P1, P1 is waiting for a resource that is held by P2, …, Pn-1 is waiting for a resource that is held by Pn and Pn is waiting for a resource that is held by P0. Resource-Allocation Graph A set of vertices V and a set of edges E. V is partitioned into two types: , the set consisting of all the processes in the system   Basic Facts If graph contains no cycles -> no deadlock If a graph contains a cycle -> If only one instance per resource, then deadlocks can occur If several instances per resource type, then there is a possibility of a deadlock Methods of Handling Deadlocks Ensure that the system will never enter a deadlock state: Deadlock prevention Deadlock avoidance Allow the system to enter a deadlock state and then recover Ignore the problem and pretend that deadlocks never occur in the system; used by most operating systems, including UNIX and Windows. (ostrich algorithm) Deadlock Prevention Restrain the ways request can be made Mutual exclusion – not required for sharable resources (e.g. read-only files); must hold for non-sharable resources Hold and wait – must guarantee that whenever a process requests a resource, it does not hold any other resources Require process to request and be allocated all its resources before it begins execution, or allow process to request resources only when the process has none allocated to it. Low resource utilization; starvation possible No Preemption  If a process that is holding some resources requests another resource that cannot be immediately allocated to it, then all resources currently being held are released Preempted resources are added to the list of resources for which the process is waiting Process will be restarted only when it can regain its old resources, as well as the new ones that it is requesting Circular Wait – impose a total ordering of all resource types, and require that each process requests resources in an increasing order of enumeration. Deadlock Avoidance Requires that the system has some additional a priori information available Simplest and most useful model requires that each process declare the maximum number of resources of each type that it may need The deadlock-avoidance algorithm dynamically examines the resource-allocation state to ensure that there can never be a circular-wait condition Resource-allocation state is defined by the number of available and allocated resources, and the maximum demands of the processes. Safe State When a process requests an available resource, system must decide if immediate allocation leaves the system in a safe state. System is in a safe state if there exists a sequence <P1, P2, …, Pn> of ALL the processes in the systems such that for each Pi, the resources that Pi can still request can be satisfied by currently available resources + resources held by Pj with j < i That is: If Pi resource needs are not immediately available, then Pi can wait until all Pj have finished When Pj is finished Pi can obtain needed resources, execute, return allocated resources and terminate When Pi terminates, Pi+1 can obtain its needed resources and so on. Basic Facts If a system is in a safe state then there are no deadlocks If a system is in an unsafe state, there is a possibility of a deadlock situation Avoidance ensures that a system will never enter an unsafe state. Avoidance Algorithms Single instance of a resource type Use a resource-allocation graph Multiple instances of a resource type Use the banker’s algorithm Resource-Allocation Graph Scheme Claim edge Pi -> Rj indicated that project Pj may request resource Rj; represented by a dashed line Claim edge converts to request edge when a process requests a resource Request edge converted to an assignment edge when the resources is allocated to the process When a resource is released by a process, … … Resource-Allocation Graph Algorithm Suppose that process Pi requests a resource Rj The request can be granted only if converting the request edge to an assignment edge does not result in the formation f a cycle in the resource allocation graph Banker’s Algorithm Multiple instances Each process must a priori claim maximum use When a process requests a resource, it may have to wait When a process gets all its recourses it must return them in a finite amount of time. Data Structures for the Banker’s Algorithm Let n = number of process, and m = number of resources types. Available: vector of length m. if available [j] = k, there are k instances of resource type Rj available Max: n x m matrix. If Max[i, j] = k, then process Pi may request at most k instances of resource type Rj Allocation: n x m matrix. If Allocation[i, j] = k then Pi is currently allocated k instances of Rj Need: n x m matrix. If Need[i, j] = k, then Pi may need k more instances of Rj to complete its task  Safety Algorithm Let work and finish be vectors of length m and n respectively initialize:   Find an I such that both:   If no such i exists, go to step 4    Go to step 2 If  for all i, then the system is in a safe state Resource-Request Algorithm for Process Pi Requesti = process vector for process Pi, if Requesti[j] = k then process Pi wants k instances of resource type Rj If  go to step 2. Otherwise, raise error condition, since process has exceeded its maximum claim If , go to step 3. Otherwise Pi must wait, since resources are not available Pretend to allocated requested resources to Pi by modifying the state as follows:    Deadlock Detection Allow system to enter deadlock state Detection algorithm Recovery scheme Single Instance of Each Resource Type Maintain wait-for graph nodes are processes Pi -> Pj if Pi is waiting for Pj Periodically invoke an algorithm that searches for a cycle in a graph. If there is a cycle, there exists a deadlock An algorithm to detect a cycle in a graph requires an order of n2 operations, where n is the number of vertices in the graph. Several Instances of a Resource Type Available: a vector of length m indicates the number of available resources of each type Allocation: an n x m matrix defines the number of resources of each type currently allocated to each process Request: an n x m matrix indicates the current request of each process. Detection Algorithm Let work and finish be vectors of length n and m respectively. Initialize: Work = available For I = 1, 2, …, n, if allocationi != 0, then finish[i] = false; otherwise finish[i] = true … Work = work + allocationi Finish[i] = true Go to step 2 If finish[i] == false for some I, 1 <= I <= n, then the system is in a deadlock state. Moreover, if finish[i] == false, then Pi is deadlocked Detection-Algorithm Usage When, and how often to invoke depends on: How often a deadlock is likely to occur How many processes will need to be rolled back? One for each disjoint cycle If detection algorithm is invoked arbitrarily, there may be many cycles in the resource graph so we could not be able to tell which of them are deadlocks… Recovery from Deadlock: Process Termination Abort all deadlocked processes Abort one process at a time until the deadlock cycle is terminated In which order should we choose to abort? Priority of the process How long process has computed, and how much longer to completion Resources the process has used Resources process needs to compute How many processes will need to be terminated Is process interactive or batch? Recovery from Deadlock: Resource Preemption Selecting a victim – minimize cost Rollback – return to some safe state, restart process for that state Starvation – same process may always be picked as victim, include number of rollback in cost factor '}, {'name': '2021-02-18 -- System Programs.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'System Programs system programs provide a convenient environment for program development and execution. They can be divided into: File manipulation Status information sometimes stored in a file modification Programming language support Program loading and execution Communications Background services Application programs Most users’ view of the operation system is defined by system programs, not the actual system calls. Provide a convenient environment for program development and execution Some of them are simply user interfaces to system calls; others are considerably more complex File Management – create, delete, copy, rename, print, dump, list, and generally manipulate files and directories Status Information Some ask the system for info – date, time, amount of available memory, disk space, number of users Others provide detailed performance, logging, and debugging information. Typically, these programs format and print the output to the terminal or other output devices Some systems implement a registry – used to store and retrieve configuration information File Modification Text editors to create and modify files Special commands to search contents of files or perform transformations of the text Programming-language support – compilers, assemblers, debuggers and interpreters sometimes provided Program loading and execution – absolute loaders, relocatable loaders, linkage editors, and overlay-loaders, debugging systems for higher-level and machine language Communications – Provide the mechanism for creating virtual connections among processes, users, and computer systems Allow users to send messages to one another’s screens, browse web pages, send electronic-mail messages, log in remotely, transfer files from one machine to another Background Services Launch at boot time Some for system startup, then terminate Some from system boot to shutdown Provide facilities like disk checking, process scheduling, error logging, printing Run in user context Known as services, subsystems, daemons Applications programs Don’t pertain to systems Run by users Operating System Structure General-purpose OS is very large program Various ways to structure ones Simple structure – MS-DOS More complex – UNIX Layered – an abstraction Microkernel – Mac Simple Structure MS-DOS – written to. Provide the most functionality in the least space Not divided into modules Although MS-DOS has some structure, its interfaces and levels of functionality are not well separated Non-Simple Structure  UNIX – limited by hardware functionality, the original UNIX operating system had limited structuring. The UNIX OS consists of two separable parts System programs The kernel Consists of everything below the system-call interface and above the physical hardware Provides the file system, CPU scheduling, memory management, and other operating-system functions; a large number of functions for one level. Microkernel System Structure Moves as much from the kernel into user space Mac example of microkernel Mac OS X kernel (Darwin) partly based on Mac Communication takes place between user modules using message passing Benefits: Easier to extend a microkernel Easier to port the operating system to new architectures More reliable (less code is running in kernel mode) More secure Detriments: Performance overhead of user space to kernel space communication     … …            …         …         ..        …. System Boot When power initialized on system, execution starts at a fixed memory location Firmware ROM used to hold initial boot code Operating system must be available to hardware so hardware can start it Small piece of code – bootstrap loader, stored in ROM or EEPROM locates the kernel, loads it into memory, and starts it Sometimes two-step process where boot block at fixed location loaded by ROM code, which loads bootstrap loader from disk common bootstrap loader, GRUB, allows selection of kernel from multiple disks, versions, kernel options kernel loads and system is then running.  Chapter 2: Processes Objectives to introduce the notion of a process – a program in execution which forms the basis of all computation to describe the various feature of processes, including scheduling, creation, termination and communication. Process Concept an operating system executes a variety of programs: batch system – jobs time-shared systems – user programs or tasks textbook uses the terms job and process almost interchangeably Process – a program in execution; process execution must progress in sequential fashion Multiple parts The program code, also called text section Current activity including program counter, processor and registers Stack containing temporary data Function parameters, return addresses, local variables  Data section containing global variables Heap containing memory dynamically allocated during run time Program is passive entity stored on disk (executable file), process is active Program becomes process when executable file loaded into memory Execution of program started via GUI mouse clicks… ….. Process State As a process executes, it changes state new: the process is being created running: instructions are being executed waiting: the process is waiting for some event to occur ready: the process is waiting to be assigned to a processor terminated: the process has finished execution Process Control Block (PCB) Information associated with each process (also called task control block) process state – running, waiting, etc program counter – location of instruction to next execute CPU registers – contents of all process-centric registers CPU scheduling information – priorities, scheduling queue pointers Memory-management information – memory allocated to the process Accounting information – CPU used, clock time elapsed since start, time limits I/O status information – I/O devices allocated to process, list of open files  '}, {'name': '2021-03-11 -- Chapter 3.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Chapter 3 Main Memory Memory Management Background Swapping Contiguous Memory Allocation Segmentation Paging Structure of the Page Table Objectives To provide a detailed description of various ways of organizing memory hardware To discuss various memory-management techniques, including paging and segmentation Background A program must be brought (from disk) into memory and placed within a process for it to be run Main memory and registers are only storage CPU can access directly Memory unit only sees a stream of addresses + read requests, or address + data and write requests Registers access in one CPU clock (or less) Main memory can take many cycles, causing a stall Cache sits between main memory and CPU registers Protection of memory required to ensure correct operation Base and Limit Registers A pair of base and limit registers define the logical address space CPU must check every memory access generated in user mode to be sure it’s between base and limit for that user Hardware Address Protection (ADD IMAGE HERE) Address Binding Programs on disk, ready to be brought into memory to execute from an input queue Without support, must be loaded into address 0000 Inconvenient to have first user process physical address always at 0000 How can it not be? Further, addresses represented in different ways at different stages of a program’s life Source code addresses usually symbolic Compiled code addresses bind to relocatable addresses i.e. “14 bytes from beginning of this module” linker or loader will bind relocatable addresses to absolute addresses i.e. 74014 each binding maps one address space to another. Address binding of instructions and data to memory addresses can happen at three different stages Compile time: if memory location known a priori, absolute code can be generated; must recompile code if starting location changes Load time: must generate relocatable code if memory location is not known at compile time Execution time: binding delayed until run time in the process can be moved during its execution from one memory segment to another (most commonly practiced one) Need hardware support for address maps (e.g., base and limit registers) Logical vs. Physical Address Space The concept of a logical address space is bound to a separate physical address space is central to proper memory management Logical address – generated by the CPU; also referred to as virtual address Physical address – address seen by the memory unit Logical and physical addresses are the same in compile-time and load-time address-binding schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme Logical address space is a set of all logical addresses generated by the program Physical address space is the set of all physical addresses generated by a program Memory-Management Unit (MMU) Hardware device that at run time maps virtual to physical address Many methods possible, covered in the rest of this chapter To start, consider simple scheme where the value in the relocation register is added to every address generated by a user process at the time it is sent to memory Base register now called relocation register MS-DOS on Intel 80x86 used 4 relocation registers The user program deals with logical addresses; it never sees the real physical address Execution-time binding occurs when reference is made to location in memory Logical address bound to physical addresses Dynamic relocation using a relocation register Routine is not loaded until it is called Better memory-space utilization; unused routine is never loaded All routines kept on disk in relocatable load format Useful when large amounts of code are needed ot handle infrequently occurring cases No special support from the operating system is required  Implemented through program design OS can help by providing libraries needed…. Dynamic Linking Static linking – system libraries and program code combined by the loader into the binary program image Dynamic linking – linking postponed until execution time small piece of code, stub, used to locate the appropriated memory-resident library routine Stub replaces itself with the address of the routine, and executes the routine Operating system checks if routine is in processes’ memory address If not in address s pace, add to address space. Dynamic linking is particularly useful for libraries System also known as shared libraries. Consider applicability to patching system libraries Versioning may be needed Swapping A process can be swapped temporarily out of memory to a backing store, and then brought back into memory for continued execution Total physical memory space of processes can exceed physical memory Backing Store – fast disk large enough to accommodate copies of all memory images for all users; must provide direct access to these memory images Roll out, roll in – swapping variant used for priority-based scheduling algorithms; lower-priority process is swapped out so higher-priority process can be loaded and executed Major part of swap time is transfer time; total transfer time is directly proportional to the amount of memory swapped System maintains a ready queue of ready-to-run processes which have memory images on disk. Does the swapped-out process need to swap back into the same physical addresses? Depends on address binding method Plus consider pending I/O to / from process memory space Modified versions of swapping are found on many systems (i.e., UNIX, Linux, and Windows) Swapping normally disabled Started if more than threshold amount of memory allocated Disabled again once memory demand reduced below threshold  Schematic View of Swapping (IMAGE) Context Switch Time including Swapping If next process to be put on CPU is not in memory, need to swap out a process and swap in a target process Context switch time can then be very high 100MB process swapping to hard disk with transfer rate of 50MB/s Swap out time of 2000ms Plus, swap in of same sized process Total context switch swapping component time of 4000ms (4 seconds) Can reduce size of memory swapped – by knowing how much memory really being used System calls to inform OS of memory use via request_memory() and release_memory() Swapping on Mobile Systems Not typically supported Flash memory based Small amount of space Limited number of write cycles Poor throughput between flash memory and CPU on mobile platform Instead of other methods to free memory if low iOS asks to voluntarily relinquish allocated memory read-only data thrown out and reloaded from flash if needed failure to free can result in termination Android terminates apps if low free memory, but first writes application state to flash for fast restart Both OSes support paging as discussed below Contiguous Allocation Main memory must support both OS and user processes Limited resource, must allocate efficiently Contiguous allocation is one early method Main memory usually into two partitions: Resident operating system, usually held in low memory with interrupt vector User process then held in high memory Each process contained in single contiguous section of memory Relocation registers used to protect user processes from each other, and from changing operating-system code and data Base register contains value of smallest physical address the process contains Limit register contains range of logical addresses – each logical address must be less than limit register MMU maps logical addresses dynamically Can then allow actions such as kernel code being transient and kernel changing code Hardware Support for Relocation and Limit Registers (IMAGE) Multiple-Partition Allocation Multiple-partition allocation Degree of multiprogramming limited by number of partitions Variable-partition sizes for efficiency (sized to given process’ needs) Hole – block of available memory; holes of various size are scattered throughout memory When a process arrives, it is allocated memory from a hole large enough to accommodate it  Process exiting … …  Dynamic Storage-Allocation Problem How to satisfy a request of size n from a list of free holes First-fit: Allocate the first hole that is big enough Best-fit: Allocate the smallest hole that is big enough: must search entire list, unless ordered by size Produces the smallest leftover hole Worst-fit: allocate the largest hole; must also search entire list Produces the largest leftover hole First-fit and best-fit better than worst-fit in terms of speed and storage utilization  Fragmentation External Fragmentation – total memory space exists to satisfy a request, but it is not contiguous. (it is the sum of internal fragmentation) Internal fragmentation – allocated memory maybe slightly larger than request memory; this size difference is memory internal to a partition, but not being used First fit analysis reveals that given N blocks allocated…. … Reduce external fragmentation by compaction… Shuffler memory contents to place all free memory together in one large block Compaction is possible only if relocation is dynamic and is done at execution time I/O problem Latch job in memory while it is involved in I/O Do I/O only into OS (futures ?) …. Segmentation Memory-management scheme that supports user view of memory A program is a collection of segments A segment is a logical unit such as: main program procedure function method object local variables, global variables common block stack symbol table arrays User’s View of a Program (IMAGE)  Segmentation Architecture Logical address consists of a two tuple: \tSegment-number, offset, Segment table – maps two-dimensional physical adedresses; each table entry has Base Limit … … … … .. Protection With each entry in segment table associate:\t Validation bit = 0 => illegal segment Read/write/execute privileges Protection bits associated with segments; code sharing occurs at segment level Since segments vary in length, memory allocation is a dynamic storage-allocation problem A segmentation example is shown in the following diagram Segmentation Hardware (IMAGE)  Paging Physical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available  Avoids external fragmentation Avoid problem of varying sized memory chunks Divide physical memory into fixed-size blocks called frames Size is power of 2, between 512 bytes and 16Mbytes Divide logical memory into blocks of same size called pages Keep track of all free frames To run a program of size N pages, need to find N free frames and load program Set up a page table to translate logical to physical addresses Backing store likewise split into pages Still have internal fragmentation Address Translation Scheme Addresses generated by CPU is divided into: Page number (p) – used as an index into a page table which contains base address of each page in physical memory Page offset (d) – combined with base address to define the physical memory address that is sent to the memory unit Page number | page offset P \t\t | d m-n \t\t| n For given logical address space 2m and page size 2n Paging Hardware (IMAGE)   '}, {'name': '2021-02-11 -- Operating System.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Operating System Chapter 1: Introduction   Objectives Describe the basic organization of computer systems  To provide a grand tour of the major components of operating systems  To give an overview of many types of computing environments.  What is an Operating System? A program that acts as an intermediary between a user of a computer and the computer hardware (it is an interface between the hardware and the user) Operating system goals: Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner. What Operating Systems Do Depends on the point of view Users want a convenience, ease of use and good performance Don’t care about resource utilization But shared computers such as mainframes or minicomputers must keep all users happy Users of dedicate systems such as workstations have dedicated resources but frequently use shared resources from servers Handheld computers are resource poor, optimized for usability and battery life Some computers have little or no user interface, such as embedded computers in devices and automobiles. Operating System Definition OS is a resource allocator Manages all resources Decides between conflicting requests for efficient and fair resource use OS is a control program Controls execution of programs to prevent errors and improper use of the computer. No universally accepted definition “Everything a vendor ships when you order an operating system” is a good approximation But varies wildly “The one program running at all times on the computer” is the kernel Everything else is either A system program (ships with the operating system), or  An application program.  …   Common Functions of Interrupts …. An operating system is interrupt driven  Interrupt Handling The operating system preserves the state of the CPU by storing registers and the program counter Determines which type of interrupt has occurred: polling vectored interrupt system Storage Structure main memory -only large storage media that the CPU can access directly Random access Typically volatile Secondary storage – extension of main memory that provides…    Storage Hierarchy Storage systems organized in hierarchy Speed cost volatility Caching – copying information into faster storage system; main memory can be viewed as a cache for secondary storage. Device driver…   Direct Memory Access Structure Used for high-speed I/O devices able to transmit information at close to memory speeds. Device controller transfers blocks of data from buffer storage …  Computer-System Architecture Most systems use a single general-purpose processor Most systems have special-purpose processors as well Multiprocessors systems growing in use and importance Also known as parallel systems, tightly-coupled systems Advantages include: Increased throughput Economy scale Increased reliability – graceful degradation or fault tolerance Two types: Asymmetric Multiprocessing – each processor is assigned a specific task Symmetric Multiprocessing – each processor performs all tasks  Clustered Systems Like multiprocessor systems, but multiple systems working together Usually sharing storage via a storage-area network (SAN) Provides a high-availability service which survives failures Asymmetric clustering has one machine in hot-standby mode Symmetric clustering has multiple nodes running applications, monitoring each other Some clusters are for high-performance computing (HPC) Applications must be written to use parallelization Some have distributed lock manager (DLM) to avoid conflicting operations. Operating System Structure Multiprogramming (Batch system) needed for efficiency Single user cannot keep CPU and I/O devices busy at all times Multiprogramming organizes jobs (code and data) so CPU always has one to execute A subset of total jobs in system is kept in memory One job selected and run via job scheduling. When it has to wait (for I/O for example), OS switches to another job Timesharing (multitasking) is a logical extension in which CPU switches jobs so frequently that users can interact with each job while it is running, creating interactive computing. Response time should be < 1 second Each user has at least one program executing in memory => process If several jobs ready to run at the same time => CPU scheduling If processes don’t fit in memory, swapping moves them in and out to run Virtual memory allows execution of processes not completely in memory '}, {'name': '2021-03-25 -- Page Fault.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Page Fault If there is a reference to a page, first reference to that page will trap to operating system; Page fault Operating system looks at another table to decide: Invalid reference => abort Just not in memory Find free frame Swap page into frame via scheduled disk operation Reset tables to indicate page now in memory set validation bit = v Restart the instruction that caused the page fault. Aspects of Demand Paging Extreme case – start process with no pages in memory OS sets instruction pointer to first instruction of process, non-memory-resident -> page fault And for every other process pages on first access Pure demand paging Actually, a given instruction could access multiple pages -> multiple page faults Consider fetch and decode of instruction which adds 2 numbers fro memory and stores result back to memory Pain decreased because of locality of reference Hardware support needed for demand paging Page table with valid / invalid bit Secondary memory (swap device with swap space) Instruction restart Performance of Demand Paging Stages in Demand Paging (worst case) Trap to the operating system Save the user registers and process satte Determine that the interrupt was a page fault Check that the page reference was legal and determine the location of the page on the disk Issue a read from the disk to a free frame Wait in a queue for this device until the read request is serviced Wait for the device seek and/or latency time Being the transfer of the page to a free frame While waiting, allocate the CPU to some other user Receive an interrupt from the disk I/O subsystem (I/O completed) Save the registers and process state for the other user Determine that the interrupt was from the disk Correct the page table and other tables to show page is now in memory Wait for the CPU to be allocated to this process again Restore the user registers, process state, and new page table, and then resume the interrupted instruction. What Happens if There is no Free Frame? Used up by process pages Is also in demand from the kernel, I/O buffers, etc. How much to allocate to each? Page replacement – find some page in memory, but not really in use, page it out Algorithm – terminate? Swap out? Replace the page? Performance – want an algorithm which will result in minimum number of page faults Page Replacement Prevent over-allocation of memory by modifying page-fault service routine to include replacement. Use modify (dirty) bit to reduce overhead of page transfers – only modified pages are written to disk. Page replacement completes separation between logical memory and physical memory – large virtual memory can be provided on a smaller physical memory. Basic Page Replacement Find the location of the desired page on disk . . . Page and Frame Replacement Algorithms Frame-allocation algorithm determines How many frames to give each process Which frames are …. . . . .  First-In-First-Out (FIFO) Algorithm Reference string: 7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1 3 frames (3 pages can be in memory at a time per process) 15 page-faults Can vary by reference string: consider 1,2,3,4,1,2,5,1,2,3,4,5 Adding more frames can cause more page faults! Belady’s Anomaly How to track ages of pages? Just use a FIFO queue Optimal Algorithm Replace page that will not be used for longest period of time 9 is optimal for the example How do you know this? You can’t read the future Used for measuring how well your algorithm performs   Least Recently Used (LRU) Algorithm Use past knowledge rather than future Replace page that has not been used in the most amount of time Associate time with last use with each page 12 faults – better than FIFIO but worse than OPT Generally good algorithm and frequently used But how to implement?   Enhanced Second-Chance Algorithm Improve algorithm by using reference bit and modify bit (if available) in concert Take ordered pair (reference, modify) (0, 0) neither recently used nor modified – best page to replace (0, 1) not recently used but modified – not quite as good, must write out before replacement (1, 0) recently used but clean – probably will be used again soon (1, 1) recently used and modified – probably will be used again soon and need to write out before replacement When page replacement called for, use the clock scheme but use the four classes replace page in lowest non-empty class Might need to search …. Counting Algorithms Keep a counter of the number of references that have been made to each apge Not common Least Frequently Used (LFU) Algorithm: replaces page with smallest count Most Frequently Used (MFU) Algorithm: based on the argument that the page with the smallest count was probably just brought in and has yet to be used.   Overview of Mass Storage Structure Magnetic disks provide bulk of secondary storage to modern computers . / /. . . . . . . . . .  Hard Disks Platters range from .85” to 14” (historyically) Commonly 3.5”, 2.5”, and 1,8” Range from 30GB to 3TB per drive Performance Transfer rate – theoretical – 6Gb/sec Effective transfer rate – real-1Gb/sec Seek time from 3ms to 12ms – 9ms common for desktop drives Average seek time measured or calculated based on 1/3 of tracks Latency based on spindle speed 1/(RPM/60) = 60/RPM Average latency = ½ latency Hard Disk Performance Average latency = Average access time = average seek time + average latency For fastest disks 3ms + 2ms = 5ms For slow disks 9ms + 5.56ms = 14.56ms Average I/O time = average access time + (amount to transfer/transfer rate) + controller overhead For example, to transfer a 4KB block on a 7200RPM disk with a 5ms average seek time, 1Gb/sec transfer rate with a .1ms controller overhead = 5ms + 4.17ms + 0.1ms + transfer time =  Transfer time = 4KB/1Gb/s * 8Gb/GB * 1GB / 10242KB = 32/(10242) = 0.031ms Average I/O time for 4KB block = 9.27ms + 0.031ms = 9.301ms Solid-State Disks Nonvolatile memory used like a hard drive Many technology variations Can be more reliable than HDDs More expensive per MB Maybe have shorter life span Less capacity But much faster Busses can be too slow 0> connected directly to PCI for example No moving parts, so no seek time or rotational latency Magnetic Tape Was early secondary-storage medium Evolved from open spools to cartridges Relatively permanent and holds large quantities of data Access time slow Random access ~1000 times slower than disk Manly used for backup, storage of infrequently-used data, transfer medium between systems Kept in spool and wound and rewound past read/write head .. .. Disk Structure Disk drives are addressed as large 1-dimensional arrays of logical blocks, where the logical block is the smallest unit of transfer Low-level formatting creates logical blocks on physical media The 1-dimensional array of logical blocks is mapped into the sectors of the disk sequentially Sector 0 is the first sector of the first track on the outermost cylinder Mapping proceeds in order through that track, then the rest of the tracks in that cylinder, and then through the rest of the cylinders from the outermost to the innermost. '}, {'name': '2021-04-12 -- NFS.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'NFS …. … …  Nfs is designed to operate in a heterogeneous environment of different machine, operating systems, and network architectures; the NFS specifications independent of these media This independence is achieved through the use of RCP primitives built on top of a … … NFS Mount Protocol Establishes initial logical connection between server and client Mount operation includes name of remote directory to be mounted and name of server machine storing it Mount request is mapped to corresponding RPC and forwarded to mount server running on server machine Export list – specifies local file systems that server exports for mounting, along with names of machines that are permitted to mount them Following a mount request that conforms to its export list, the server returns a file handle – a key for further accesses File handle – a system-file identifier, and an inode number to identify the mounted directory within the exported file system The mount operation changes only the user’s view and does not affect the server side NFS Protocol Provides a set of remote procedure calls for remote file operations. The procedures support he following operations: Searching for a file within a directory Reading a set of directory entries Manipulating links and directories Accessing file attributes Reading and writing files NFS server are stateless; each request has to provide a full set of arguments (NFS v4. is just coming available – very different, stateful) Doesn’t collect any data on the clients Modified data must be committed to the server’s disk before results are returned to the client (lose advantages of caching) The NFS protocol does not provide concurrency-control mechanisms Three Major Layers of NFS Architecture UNIX file-system interface (based on the open, read, write, and close calls and file descriptors) Virtual File System (VFS) layer – distinguishes local files from remote ones, and local files are further distinguished according to their file-system types  The VFS activates file-system-specific operations to handle local requests according to their file-system types Calls the NFS protocol procedures for remote requests NFS layer….. …. … NFS Path-Name Translation Performed by breaking the path into component names and performing a separate NFS lookup call for every pair of component name and directory vnode. To make lookup faster, a directory name lookup cache on the client’s side holds the vnodes for remote directory names NFS Remote Operations Nearly one-to-one correspondence between regular UNIX system calls and NFS protocol RPCs (except opening and closing files) NFS adheres to the remote service paradigm, but employs buffering and caching techniques for the sake of performance File-blocks cache – when a file is opened, the kernel checks with the remote server whether to fetch or revalidate the cached attributes Cached file blocks are used only if the corresponding cached attributes are up to date File-attribute cache – the attribute cache is updated whenever new attributes arrive from the server. Clients do not free delayed-write blocks until the server configrms that the data has been transferred to the disk.  WAFL File System Used on Network Appliance “Filers” – distributed file system appliances “write-anywhere file layout” Serves up NFS, CIFS, http, ftp Random I/O optimized, write optimized NVRAM for write caching Similar to Berkeley fast file system, with extensive modifications] Each inode contains 16 pointers to blocks (or indirect blocks) belonging to the file described by the inode. . . WAFL File Layout The WAFL file system is a tree of … … … … …    I/O I/O Hardware Incredible variety of I/O devices Storage  Transmission Human-interface Common concepts – signals from I/O devices interface with computer Port – connection point for device Bus – daisy chain or shared direct access PCI bus common in Pcs and servers Expansion bus connects relatively slow devices Controller (host adapter) – electronics that operate port, bus, device Sometimes integrated Sometimes separate circuit board (host adapter) Contains processor, microcode, private memory, bus controller, etc. Some talk to per-device controller with bus controller, micro-code memory.  I/O instructions control devices Devices usually have registers where device driver places commands, addresses, and data to write, or read data from registers after command execution Data-in register, data-out register, status register, control register Typically 1-4 bytes, or FIFO buffer Devices have addresses used by Direct I/O instruction Memory-mapped I/O Device data and command registers mapped to processor address space Especially for large address spaces (graphics) Polling For each byte of I/O Read busy bit from status register until 0 Host sets read or write bit and if write copies data into data-out register Host sets command-ready bit Controller sets busy bit, executes transfer Controller clears busy bit, error bit, command-ready bit when transfer is done Setup 1 is busy-wait cycle to wait for I/O from device Reasonable if device is fast But inefficient if device slow CPU switches to other tasks But if miss a cycle data overwritten/lost Interrupts Polling can happen in 3 instruction cycles Read status, logical-and to extract status bit, branch if not zero How to be more efficient if non-zero infrequently CPU interrupt-request line triggered by I/O device Checked by processor after each instruction Interrupt handler receives interrupts Maskable to ignore or delay some interrupts Interrupt vector to dispatch interrupt to correct handler Context switch at start and end Based on priority Some non-maskable Interrupt chaining if more than one device at same interrupt number Interrupt mechanism also used for exceptions Terminate process, crash system due to hardware error Page fault executes when memory access error System call executes via trap to trigger kernel to execute request Multi-CPU systems can process interrupts concurrently If operating system designed to handle it Used for time-sensitive processing, frequent, must be fast '}, {'name': '2021-04-08 -- File System Implementation.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'File System Implementation Directory Implementation Linear List of file names with pointer to data blocks Simple to program Time-consuming to execute Linear search time Could keep ordered alphabetically via linked list or use B+ tree Hash Table – linear list with hash data structure Decreases directory search time Collisions – situations where two file names hash to the same location Only good if entries are fixed size, or use chained-overflow method Allocation Methods – Contiguous An allocation method refers to how disk blocks are allocated for files: Contiguous allocation – each file occupies set of contiguous blocks Best performance in most cases Simple – only starting location (block #) and length (number of blocks) are required Problems include finding space for file, knowing file size, external fragmentation, need for compaction off-line (downtime) or on-line ….  Extent-Based Systems Many newer file systems (i.e., Veritas File System) use a modified contiguous allocation scheme Extent-based file systems allocate disk blocks in extents An extent is a contiguous block of disks Extents are allocation for file allocation A file consists of one or more extents Allocation Methods – Linked Linked allocation – each file a linked list of blocks File ends at nil pointer No external fragmentation Each block contains pointer to next block No compaction, external fragmentation Free space management system called when new block needed Improve efficiency by clustering blocks into groups and increases internal fragmentation Reliability can be a problem Locating a block can take many I/Os and disk seeks FAT (File Allocation Table) variation Beginning of volume has a table, indexed by block number Much like a linked list, but faster on disk and cacheable New block allocation simple Allocation Methods – Indexed Indexed allocation Each file has its own index block(s) of pointer to its data blocks Need index table Random access Dynamic access without external fragmentation but have overhead of index block Mapping from logical to physical in a file of maximum size of 256KB and block size of 512B. we need only 1 block for index table LA/512 ----Q              ----R Q = displacement into index table R = displacement into block Performance in the File System (In Association with the Allocation Methods) Best method depends on file access type Contiguous is great for sequential and random access Linked list is good for sequential access but not random access. Declare access type at creation -> select either contiguous or linked Indexed is more complex Single block access could require 2 index block reads then data block read Clustering can help improve throughput and reduce CPU overhead Adding instructions to the execution path to save one disk I/O is reasonable Intel Core i7 Extreme Edition 990x (2011) at 3.46Ghz = 159,000 MIPS Typical disk drive at 250 I/Os per second 159,999 MIPS / 250 = 630 million instructions during one disk I/O Fast SSD drives provide 60,000 IOPS 150,000 MIPS / 60,000 = 2.65 million instructions during one disk I/O Free Space Management File system maintains free-space list to track available blocks/clusters (using term “block” for simplicity) Bit vector or bit map (n blocks) Bit map requires extra space Example: Block size = 4KB = 212 bytes Disk size = 240 bytes (1 Tera Byte) N…   Linked Free Space List on Disk Linked list (free list) Cannot get contiguous space easily No waste of space No need to traverse the entire list (if # free blocks recorded) … …  Grouping Modify linked list to store addresses of next n-1 free blocks in first free block… … .. … … … .. Efficiency and Performance (for Free Space Management)  Efficiency is dependent on: disk allocation and directory algorithms types of data kept in file’s directory entry pre-allocation or as-needed allocation of metadata structures fixed-size or varying-size data structures Performance Keeping data and metadata close together Buffer cache – separate section of the main memory for frequently used blocks Synchronous writes sometimes requested by apps or needed by OS No buffering / caching – writes must hit disk before acknowledgement Asynchronous writes more common, buffer-able, faster Free-behind and read-ahead – techniques to optimize sequential access Reads frequently slower than writes Recovery Consistency checking – compares data in directory structure with data blocks on disk, and tries to fix inconsistencies Can be slow and sometimes fails Use system programs to back up data from disk to another storage device (magnetic tape, other magnetic disk, optical) Recover lost file or disk by restoring data from backup ..  Next Class: The Sun Network File System (NFS) '}, {'name': '2021-03-29 -- Disk Scheduling.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Disk Scheduling The operating system is responsible for using hardware efficiently – for the disk drives, this means having a fast access time and disk bandwidth Minimize seek time Seek time ~~ seek distance Disk bandwidth is the total number of bytes transferred, divided by the total time between the first request for service and the completion of the last transfer There are many sources of disk I/O requests OS System processes Users Processes I/O request includes input or output mode, disk address, memory address, number of sectors to transfer OS maintains queue of requests, per disk or device Idle disk can immediately work on I/O request, busy disk means work must queue Optimization algorithms only make sense when a queue exists Note that drive controllers have small buffer and can manage a queue of I/O requests (of varying “depth”) Several algorithms exist to schedule the servicing of disk I/O requests The analysis is true for one or many platters We illustrate scheduling algorithms with a request queue (0-199) 98, 183, 37, 122, 14, 124, 65, 67 Head pointer 53  First Come First Served  Shortest Seek Time First Shortest seek time first selects the request with the minimum seek time from the current head position SSTF scheduling is a form of SJF scheduling; may cause starvation of some requests  Scan The disk arm starts at one end of the disk, and moves toward the other end, servicing requests until it gets to the other end of the disk, where the head movement is reversed and servicing continues. SCAN algorithm is sometimes called the elevator algorithm Illustration shows total head movement of 208 cylinders But note that if requests are uniformly dense, largest density at other end of disk and those wait the longest  C-SCAN Provides a more uniform wait time than SCAN The head moves from one end of the disk to the other, servicing requests as it goes When it reaches the other end, however, it immediately returns to the beginning of the disk, without servicing any request on the return trip Treats the cylinders as a circular list that wraps around from the list cylinder to the first one  C-LOOK LOOK a version of SCAN, C-LOOK a version of C-SCAN Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk Selecting a Disk-Scheduling Algorithm SSTF is common and has a natural appeal SCAN and C-SCAN perform better for systems that place a heavy load on the disk Less starvation Performance depends on the number and types of requests Requests for disk service can be influenced by the file-allocation method And metadata layout The disk-scheduling algorithm should be written as a separate module of the operating system, allowing it to be replaced with a different algorithm if necessary Either SSTF or LOOK is a reasonable choice for the default algorithm What about rotational latency Difficult for OS to calculate   File-System Interface File Concept Contiguous logical address space Types: Data Numeric Character Binary Program Contents defined by the file’s creator Many types Consider text file, source file, executable file File Attributes Name – only information kept in human-readable form Identifier – unique tag (number) identifies file within file system Type – needed for systems that support different types Location – pointer to file location on device Size – current file size Protection – controls who can do reading, writing, executing Time, date and user identification – data for protection, security, and usage monitoring Information about files are kept in the directory structure, which is maintained on the disk Many variations, including extended file attributes such as file checksum Information kept in the direction structure File Operations File is an abstract data type Create Write – at write pointer location Read – at read pointer location Reposition within file – seek Delete Truncate Open (Fi) – search the directory structure on disk for entry Fi, and move the content of entry to memory Close (Fi) – move the content of entry Fi in to memory to directory structure on disk File Structure None – sequence of words, bytes Simple record structure Lines Fixed length Variable length … … … Directory Structure A collection of nodes containing information about all files Both the directory structure and the files reside on disk Next class: File Systems '}, {'name': '2021-03-22 -- Paging Continued.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Paging Continued Calculating internal fragmentation Page size = 2,048 bytes Process size = 72,776 bytes 35 pages + 1,086 bytes Internal fragmentation of 2,048 – 1,086 = 962 bytes Worst case fragmentation = 1 frame – 1 byte On average fragmentation = ½ frame size So small frame sizes are desirable? But each page table entry takes memory to track Page sizes growing over time Solaris supports two pages sizes – 8 KB and 4 MB Process view and physical memory now very different By implementation process can only access its own memory Implementation of Page Table Page table is kept in main memory Page-table base register (PTBR) .. .. Some TLBs store address-space identifiers (ASIDs) in each TLB entry – uniquely identifies each process to provide address-space protection for that process Otherwise need to flush at every context switch TLBs typically small (64 to 1,024 entries) On a TLB miss, value is loaded into the TLB for faster access next time Replacement policies must be considered Some entries can be wired down for permanent fast access           Shared Pages Shared Code One copy of read-only (reentrant) code shared among processes (i.e. text editors, compilers, window systems) Similar to multiple threads sharing the same process space Also useful for inter-process communication if sharing of read-write pages is allowed Private code and data ….             Hierarchical Page Tables Break up the logical address space into multiple page tables A simple technique is a two-level page table We then page the page table …         Hashed Page Tables Common in address spaces > 32 bits The virtual page number is hashed into a page table This page table contains a chain of elements hashing to the same location Each elements (1) the virtual page number (2) the value of the mapped page frame (3) a pointer to the next element Virtual page number are compared in this chain searching for a match If a match is found, the corresponding physical frame is extracted Variation for 64-bit addresses is clustered page tables Similar to hashed but each entry refers to several pages (such as 16) rather than 1 Especially useful for sparse address spaces (where memory references are non-contiguous and scattered) Inverted Page Tables Rather than each process having a page table and keeping track of all possible logical pages, track all physical pages One entry for each real page of memory Entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns that page Decreases memory needed to store each page table, but increases time needed to search the table when a page reference occurs Use hash table to limit the search to one – or at most a few – page-table entries TLB can accelerate access But how to implement shared memory? One mapping of a virtual address to the shared physical address     Virtual Memory Objectives Understanding how pages come from backing stores when they’re demanded To describe the benefits of a virtual memory system To explain the concepts of demand paging, page-replacement algorithms, and allocation of page frames Background Code needs to be in memory to execute, but entire program is rarely used Error code, unusual routines, large data structures Entire program code not needed at same time Consider ability to execute partially-loaded program Program no longer constrained by limits of physical memory Each program takes less memory while running -> more programs run at the same time Increased CPU utilization and throughput with no increase in response time or turnaround time Less I/O needed to load or swap programs into memory -> each user program runs faster Virtual address space – logical view of how process is stored in memory Usually start at address 0, contiguous addresses until end of space Meanwhile, physical memory organized in page frames MMU must map logical to physical Virtual memory can be implemented via: Demand paging Demand segmentation  Virtual-Address Space Usually design logical address space for stack to start at max logical address and grown “down” while heap grows “up” Maximizes address space use Unused address space between the two is hole No physical memory needed until heap or stack grows to be a givewn new page Enables sparse address spaces with heles left for growth, dynamically linked libraries, etc System libraries shared via mapping into virtual address space Shared memory by mapping pages read-write into virtual address space Pages can be shared during  speeding process creation Demand Paging Could bring entire process into memory at load time Or bring a page into memory only when it is needed Less I/O needed, no unnecessary I/O Less memory needed Faster response More users Similar to paging system with swapping (diagram on right) Page is needed => reference to it Invalid reference => abort Not-in-memory => bring to memory Lazy swapper – never swaps a page into memory unless page will be needed Swapper that deals with pages is pager  Next class: Aspects of Demand Paging '}, {'name': '2021-03-01 -- Process Syncrhonization.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'Process Syncrhonization  …  Background Processes can execute concurrently May be interrupted at any time, partially completing execution Concurrent access to shared data may result in data inconsistency Maintaining data consistency requires mechanisms to ensure the orderly execution of cooperating processes Illustration of the problem: Suppose that we wanted to provide a solution to the consumer-producer problem that fills all the buffers, we can do so by having an integer counter that keeps track of the number of full buffers. Initially, counter is set to 0. It is incremented by the producer after it produces a new buffer and is decremented by the consumer after it consumes a buffer. Two processes running at the same time and when one process shares the same data with the other and when the one process writes to the data without reading it, then it is known as a race condition. Critical Section Problem Consider system of n processes  Each process has a critical section segment of code Process may be changing common variables, updating table, writing file, etc. When one process in critical section, no other may be in its critical section Critical section problem is to design protocol to solve this Each process must ask permission to enter critical section in entry section, may allow…  Solution to Critical-Section Problem Mutual Exclusion – If process P1 is executing in its critical section, then no other process can be executing in their critical sections Progress – If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the process that will enter the critical section next cannot be postponed indefinitely Bounded Waiting – A bound must exist on the number of times that other process are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted Assume that each process executes in a nonzero speed No assumption concerning relative speed of the n processes Critical Section Handling in OS Two approaches depending on if kernel is preemptive or non-preemptive Preemptive – allows preemption of processes when running in kernel mode Non-preemptive – runs until exists kernel mode, blocks, or voluntarily yields CPU Essentially free of race conditions in kernel mode Peterson’s Solution (a.k.a. The Software Solution) Good algorithmic description of soliving the problem Two process solution Assume the load and store machine-language instructions are atomic; that is, cannot be interrupted The two processes share two variables: Int turn Boolean flag[2] The variable turn indicates whose turn it is to enter the critical section The flag variable indicates who is interested to get a turn? Algorithm for Process Pi do { \tflag[i] = true \tturn = j; \twhile (flag[j] && turn = = j); \t\tcritical section \tflag[i] = false; \t\tremainder section } while (true); Provable that the three CS requirements are met: Mutual exclusion is preserved Pi enters CS only if: \tEither flag[j] is false or ….   Synchronization Hardware Many systems provide hardware support for implementing the critical section code. All solutions below based on idea of locking Protection critical regions via locks Uniprocessors – could disable interrupts Currently running code would execute without preemption Generally, too inefficient on multiprocessor systems Operating systems using this not broadly scalable Modern machines provide special atomic hardware instructions Atomic = non-interruptible Either test memory word and set value Or swap contents of two memory words\n Solution to Critical-section Problem Using Locks do{ \tacquire lock \t\tcritical section \trelease lock \t\tremainder section } while (true)  test_and_set Instruction Definition: \tboolean test_and_set (boolean *target) \t{ \t\tboolean rv = *target; \t\t*target = TRUE; \t\treturn rv; \t} Executed atomically Returns the original value of passed parameter Set the new value of passed parameter to “TRUE”. compare_and_swap Instruction Definition: \tint compare_and_swap(int *value, int expected, int new_value){ \t\tint temp = *value;  \t\tif (*value == expected) \t\t\t*value = new_value; \t\tReturn temp; \t} Executed atomically   Mutex Locks Previous solutions are complicated and generally inaccessible to application programmers OS designers build software tools to solve critical section problem Simplest is mutex lock Protect a critical section by acquire() a lock then release() the lock Boolean variable indicating if lock is available or not. Calls acquire() and release() must be atomic Usually implemented via hardware atomic instructions But this solution requires busy waiting This lock therefore called a spinlock. acquire() and release() acquire() …   Semaphore Synchronization tool that provides more sophisticated ways (than mutex locks) for process to synchronize their activities Semaphore S – integer variable Can only be accessed via two indivisible (atomic) operations wait() and signal() originally called P() and V() definition of wait() operation wait(S) { \twhile (s<=0); \t\t//busy wait \ts--; } Definition of signal() operation signal() { \ts++; } Semaphore Usage Counting semaphore – integer value can range over na unrestricted domain Binary semaphore – integer value can range only between 0 and 1 Same as mutex lock Can solve various synchronization problems Consider P1 and P2 that require S1 to happen before S2 Create a semaphore “synch” initialized to 0. P1: \tS1; \tSignal(sync); P2: \tWait; \tSignal(sync); Semaphore Implementation Must guarantee that no two processes can execute the wait() and signal() on the same semaphore at the same time Thus, the implementation becomes the critical section problem where the wait and signal code are placed in the critical section Could now have busy waiting in critical section implementation. But implementation code is short Little busy waiting if critical section rarely occupied Note that applications may spend lots of time in the critical section… Semaphore Implementation with no Busy waiting With each semaphore there is an associated waiting queue Each entry in waiting queue has two data items: Value (of type integer) Pointer to next record in the list Two operations: block – place the process invoking the operation on the appropriate waiting queue wakeup – remove one process in the waiting queue and place it in the ready queue Deadlock and Starvation Deadlock – two or more processes are waiting indefinitely for an event that can be caused by only one of the waiting processes Starvation – indefinite blocking A process may never be removed from the semaphore queue which it is suspended Priority Inversion – scheduling problem when lower-priority process holds a lock needed by higher-priority process Solved via priority-inheritance protocol Classical Problems of Synchronization Classical problems used to test newly-proposed synchronization schemes Bounded-Buffer Problem Readers and Writers Problem Dining-Philosophers Problem Sleeping Barber Problem Monitors A high-level abstraction that provides a convenient and effective mechanism for process synchronization Abstract data type, internal variables only accessible by code within the procedure Only one process maybe active within the monitor at a time But not powerful enough to model some synchronization schemes Condition Variables Condition x, y; Two operations allowed on a condition variable x.wait() – a process that invokes the operation is suspended until x.signal() x.signal() – resumes one of processes (if any) that invoked x.wait() if no x.wait() on the variable, then it has no effect on the variable if process P invokes x.signal(), and process Q is suspended in x.wait(), what should happen next? Both Q and P cannot execute in parallel. If Q is resumed, then P must wait. Options include Signal and wait – p waits until Q either leaves the monitor or it waits for another condition Signal and continue – Q waits until P either leaves the monitor or waits for another condition. Both have pros and cons – language implementer can decide Monitors implemented in concurrent pascal compromise P executing signal immediately leaves the monitor, Q is resumed Implemented in other languages including Mesa, C#, Java Monitors are the ultimate solution to Mutexes.  Next Class: CPU Scheduling '}, {'name': '2021-04-05 -- File Systems.docx', 'path': '/Users/brukb/Documents/Class/Year 3/Term 1/CS363/Notes', 'content': 'File Systems Types of File Systems We mostly talk of general-purpose file systems But systems frequently have many file systems, some general and some special purpose Consider Solaris, it has: tmpfs – memory-based volatile FS for fast, temporary I/O objfs – interface into kernel memory to get kernel symbols for debugging ctfs – contract file system for managing daemons lofs – loopback file system allows one fs to be accessed in place of another procfs – kernel interface to process structures ufs, zfs – general purpose file systems Operations Performed on Directory Search for a file Create a file Delete a file  List a directory Rename a file Traverse the file system Directory Organization The directory is organized logically to obtain Efficiency – locating a file quickly Naming – convenient to users Two users can have same name for different files The same file can have several different names. Grouping – logical grouping of files by properties, (e.g., all Java programs, all games, …) Directory Structure (REFERENCE IMAGES) Two-Level Directory Contains path names Can have the same file name for different users Is efficient in searching No grouping capability Tree-Structured Directories Almost all OSes use this structure Efficient searching Grouping capabilities Able to know the current directory (working directory)   Absolute or relative path name Creating a new file is done in current directory Delete a file   Creating a new subdirectory is done in current directory   Acyclic-Graph Directories Has shared subdirectories and files. (REFERENCE IMAGE HERE) Two different names (aliasing) New directory entry type Link – another name (pointer) to an existing file Resolve the link – follow pointer to locate the file  …  File Sharing – Remote File Systems Uses networking to allow file system access between systems Manually via programs like FTP Automatically, seamlessly using distributed file systems Semi automatically via the world wide web Client-server model allows clients to mount remote file systems from servers Server can serve multiple clients Client and user-on-client identification is insecure or complicated NFS is standard UNIX client-server file sharing protocol. CIFS is standard Windows protocol Standard operating system file calls file calls are translated into remote calls Distributed Information Systems (distributed naming services) such as LDAP, DNS, NIS, Active Directory implement unified access to information needed for remote computing. File Sharing – Failure Modes All file systems have failure modes For example corruption of directory structures or other non-user data, called metadata Remote file systems add new failure modes, due to network failure, server failure .. .. .. File Sharing – Consistency Semantics Specify how multiple users are to access a shared file simultaneously Similar to Ch. 2 On process synchronization algorithms Tend to be less complex due to disk I/O and network latency (for remote file systems) Andrew File System (AFS) implemented complex remote file sharing semantics Unix File System (UFS) implements: Writes to an open file visible immediately to other users of the same open file Sharing file pointer to allow multiple users to read and write concurrently AFS has session semantics Writes only visible to sessions starting after the file is closed. File System Implementation  File System Structure File structure Logical storage unit Collection of related information File system resides on secondary storage (disks) Provided user interface to storage, mapping logical to physical Provides efficient and convenient access to disk by allowing data to be stored, located and retrieved easily Disk provides in-place rewrite and random access I/O transfers performed in blocks of sectors (usually 512 bytes) File control block – storage structure consisting of information about a file Device driver controls the physical device File system organized into layers File System Layers Device drivers manage I/O devices at the I/O control layer Given commands like “read drive1, cylinder 72, track 2, sector 10, into memory location 1060” outputs low-level hardware specific commands to hardware controller Basic file system given commands like “retrieve block 123” translates to device driver Also manages memory buffers and caches (allocating, freeing, replacement) Buffers hold data in transit Caches hold frequently used data File organization module understands files, logical address spaces, and physical blocks Translates logical block # to physical block # Manages free space, disk allocation Logical file system manages metadata information Translates file name into file number, file handle, location by maintaining file control blocks (inodes in UNIX) Directory management Protection Layering useful for reducing complexity and redundancy, but adds overhead and can decrease performance. Translates file name into file number, file handle, location by maintaining file control blocks (inodes in UNIX) Logical layers can be implemented by any coding method according to OS designer. Many file systems, sometimes within an operating system. Each with its own format (CD-ROM is ISO 9660; UNIX has UFS, FFS; Windows has FAT, FAT32, NTFS as well as floppy, CD, DVD Blu-ray, Linux has more than 40 types, with extended file system ext2 and ext3 leading; plus, distributed file systems, etc.) New ones still arriving – ZFS, GoogleFS Oracle ASM, FUSE File-System Implementation We have system calls at the API level, but how do we implement their functions? On-disk and in-memory structures Boot control block contains info needed by system to boot OS from that volume Needed if volume contains OS, usually first block of volume Volume control block (superblock, master file table) contains volume details Total number of blocks, number of free blocks, block size, free block pointers or array Directory structure organizes the files Names the inode numbers, master file table. Per-file File Control Block (FCB) contains many details about the file inode number, permissions, size, dates NTFS stores into in master file table using relational DB structures In-Memory File System Structures Mount table storing file system mounts, mount points, file system types The following figure illustrates the necessary file system structures provided by the operating systems Figure 12-3(a) refers to opening a file Figure 12-3(b) refers to reading a file Plus buffer holds data blocks from secondary storage Open returns a file handle for subsequent use Data from read is eventually copied to specified user process memory address Partitions and Mounting Partition can be a volume containing a file system (“cooked”) or raw – just a sequence of blocks with no file system Boot block can point to boot volume or boot loader set of blocks that contain enough code to know how to load the kernel from the file system Or a boot management program for multi-OS booting Root partition contains the OS, other partitions can hold other OSes, other file systems, or be raw Mounted at boot time Other partitions can mount automatically or manually. At mount time, file system consistency is checked Is all metadata correct? If not, fix it, try again If yes, add to mount table, allow access Virtual File Systems Virtual File System (VFS) on UNIX provide an object-oriented way of implementing file systems VFS allows the same system call interface (the API) to be used for different types of file systems Separates file-systems generic operations from implementation details Implementation can be one of many file systems types, or network file system Implements vnodes which hold inodes or network file details Then dispatches operations to appropriate file system implementation routines. Virtual File System Implementation For example, Linux has four object types: inode, file, superblock, dentry VFS defines set of operations on objects that must be implemented Every object has a pointer to a function table Function table has addresses of routines to implement that function on that object For example: int open () open a file int close () close an already-opened file ssize t read () – read from that file ssize t write (…) – write to a file int mmap (…) – memory-map a file  Next Class: Directory Implementation '}, {'name': 'Algorithm Profiler Description.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/References', 'content': 'Algorithm Profiler Description Algorithm Profiler is a program that empirically analyzes and describes the resource requirements and growth rate of algorithms. For the purpose of this assignment, you are required to design and implement an algorithm profiler program that takes simple sorting algorithms discussed in the class. Your program should analyze each i.e. bubble, selection and insertion sorting algorithms, empirically, and discuss their behavior. The profiler should consider and determine the performance of each algorithm for its best, average and best case scenarios. The testing you perform for each algorithm in each case scenario should be plotted and represented with graphs which may be used to visually proof the growth rate of the algorithms. Deliverables A not less than 15 pages of document that describes the assignment work, per the template provided. Source code of the assignment.  (Language Independent) Note: Assignment is expected to be delivered on or before 15th of September 2020.  '}, {'name': 'Documentation Template.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/References', 'content': '\n Introduction <In this section you describe what the assignment is for or about. What sorting is, what algorithm analysis is, what complexity is, what growth rate is and etc. this section must have at least 3 pages > Bubble Sort Algorithm <Bubble sort description goes here with algorithm at most two pages.> Best Case <Beast case analysis goes here describing what data set makes this algorithm to perform in its best. Table for data vs. time you used to plot the graph to be shown and described. At most two pages> Worst Case <Worst case analysis goes here describing what data set makes this algorithm to perform in its worst. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Average Case <Average case analysis goes here describing what data set makes this algorithm to perform in average. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Selection Sort Algorithm <Selection sort description goes here with algorithm at most two pages.> Best Case <Beast case analysis goes here describing what data set makes this algorithm to perform in its best. Table for data vs. time you used to plot the graph to be shown and described. At most two pages> Worst Case <Worst case analysis goes here describing what data set makes this algorithm to perform in its worst. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Average Case <Average case analysis goes here describing what data set makes this algorithm to perform in average. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Insertion Sort Algorithm <Insertion sort description goes here with algorithm at most two pages.> Best Case <Beast case analysis goes here describing what data set makes this algorithm to perform in its best. Table for data vs. time you used to plot the graph to be shown and described. At most two pages> Worst Case <Worst case analysis goes here describing what data set makes this algorithm to perform in its worst. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Average Case <Average case analysis goes here describing what data set makes this algorithm to perform in average. Table for data vs. time you used to plot the graph to be shown and described. At most two pages > Conclusion <Conclusion goes here. You describe your findings, observations and understandings here. At least 1 page>    '}, {'name': '2021-01-15 -- FINAL REVIEW Trees.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/Notes', 'content': 'Trees struct node {    int data;       struct node *leftChild;    struct node *rightChild; }; Basic operations you can perform on a Binary Search Tree Insert, Search, PreOrder Traversal, InOrder Traversal, PostOrder Traversal void insert(int data) {    struct node *tempNode = (struct node*) malloc(sizeof(struct node));    struct node *current;    struct node *parent;     tempNode->data = data;    tempNode->leftChild = NULL;    tempNode->rightChild = NULL;     //if tree is empty, create root node    if(root == NULL) {       root = tempNode;    } else {       current = root;       parent  = NULL;        while(1) {                          parent = current;           //go to left of the tree          if(data < parent->data) {             current = current->leftChild;                                          //insert to the left             if(current == NULL) {                parent->leftChild = tempNode;                return;             }          } \t\t\t          //go to right of the tree          else {             current = current->rightChild;                          //insert to the right             if(current == NULL) {                parent->rightChild = tempNode;                return;             }          }       }                } }  struct node* search(int data) {    struct node *current = root;    printf("Visiting elements: ");     while(current->data != data) {       if(current != NULL)       printf("%d ",current->data);               //go to left tree        if(current->data > data) {          current = current->leftChild;       }       //else go to right tree       else {                          current = current->rightChild;       }        //not found       if(current == NULL) {          return NULL;       }        return current;    }   }  In-order Traversal In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself. If a binary tree is traversed\xa0in-order, the output will produce sorted key values in an ascending order.  We start from\xa0A, and following in-order traversal, we move to its left subtree\xa0B.\xa0B\xa0is also traversed in-order. The process goes on until all the nodes are visited. The output of inorder traversal of this tree will be − D → B → E → A → F → C → G  Pre-order Traversal In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.  We start from\xa0A, and following pre-order traversal, we first visit\xa0A\xa0itself and then move to its left subtree\xa0B.\xa0B\xa0is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be − A → B → D → E → C → F → G  Post-order Traversal In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.  We start from\xa0A, and following Post-order traversal, we first visit the left subtree\xa0B.\xa0B\xa0is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be − D → E → B → F → G → C → A  Traversals void pre_order_traversal(struct node* root) {    if(root != NULL) {       printf("%d ",root->data);       pre_order_traversal(root->leftChild);       pre_order_traversal(root->rightChild);    } } void inorder_traversal(struct node* root) {    if(root != NULL) {       inorder_traversal(root->leftChild);       printf("%d ",root->data);                 inorder_traversal(root->rightChild);    } } void post_order_traversal(struct node* root) {    if(root != NULL) {       post_order_traversal(root->leftChild);       post_order_traversal(root->rightChild);       printf("%d ", root->data);    } } Constructing a complete binary tree Input  :  arr[] = {1, 2, 3, 4, 5, 6} Output : Root of the following tree                   1                  / \\                 2   3                / \\ /               4  5 6 // Function to insert nodes in level order  Node* insertLevelOrder(int arr[], Node* root,  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int i, int n) {  \xa0\xa0\xa0\xa0// Base case for recursion  \xa0\xa0\xa0\xa0if (i < n) {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Node* temp = newNode(arr[i]);  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0root = temp;  \xa0\xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// insert left child  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0root->left = insertLevelOrder(arr,  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0root->left, 2 * i + 1, n);  \xa0\xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// insert right child  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0root->right = insertLevelOrder(arr,  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0root->right, 2 * i + 2, n);  \xa0\xa0\xa0\xa0}  \xa0\xa0\xa0\xa0return root;  }   Binary trees with heap properties are trees where any given node of the tree is greater than or equal to the data in it’s left or right sub-trees Binary trees with ordering properties are trees where any given node of the tree is greater than or equal to the data on it’s left and less than or equal to the data on it’s right (also known as a Binary Search Tree [BST]) BST should be visited in an inOrder fashion if you want the elements to be displayed in an ascending fashion. Operations on BSTs Create(root) isEmpty(root) Traverse(root) – visit every node in the order relative to the hierarchy of the nodes in the tree Find(root, item) Add(root, node) – adds to the tree a new node without disrupting the hierarchical structure Remove(root, node) Heap Heap is a special case of balanced binary tree data structure where the root-node key is compared with its children and arranged accordingly. If\xa0α\xa0has child node\xa0β\xa0then − key(α) ≥ key(β) As the value of parent is greater than that of child, this property generates\xa0Max Heap. Based on this criteria, a heap can be of two types − For Input → 35 33 42 10 14 19 27 44 26 31 Min-Heap\xa0− Where the value of the root node is less than or equal to either of its children.  Max-Heap\xa0− Where the value of the root node is greater than or equal to either of its children.  Both trees are constructed using the same input and order of arrival.  '}, {'name': '2021-01-15 -- FINAL REVIEW Algorithms.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/Notes', 'content': 'Algorithms Empirical: Analyze the time it takes to run the corresponding program by trying it on different instances Theoretical: Determine the quantity of resources required mathematically (execution time, memory space) needed by the algorithm Rules for calculating time taken by algorithm: Execution of one of the following operations takes time 1: Assignment Operation Single Input/Output Operation Single Boolean Operations Single Arithmetic Operations Function Return Running time of a selection statement (if, switch) is the time for the condition evaluation + the maximum of the running times for the individual clauses in the selection. Loops:  Running time for a loop is equal to the running time for the statements inside the loop * number of iterations.  The total running time of a statement inside a group of nested loops is the running time of the statements multiplied by the product of the sizes of all the loops. For nested loops, analyze inside out. Always assume that the loop executes the maximum number of iterations possible. Running time of a function call is 1 for setup + the time for any parameter calculations + the time required for the execution of the function body. int sum (int n){ \tint sum = 0;  \tfor(int i = 1; i <= n; i++) \t\tsum = sum + i; \treturn sum; }  Time Units to Compute 1 for the assignment statement:    int sum=0 In the for loop:  1 assignment \ti=1,   n+1 tests \ti<=n n increments \ti++.  n loops of 2 units for an assignment, and an addition.  1 for the return statement. ------------------------------------------------------------------- T (n)= 1+1+n+1+n+2n+1 = 4n+4  Running “time”: Running time refers to the number of operations that the algorithm need to perform of as a function of the data size.  Growth rate: Takes running time function and find the most dominant part by neglecting the terms which are less discriminative. This is called the Big O of the algorithm. Sorting Algorithms Heap Sort public class HeapSort {\n\xa0\xa0\xa0\xa0public void sort(int arr[]){\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int n = arr.length;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Build heap (rearrange array)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int i = n / 2 - 1; i >= 0; i--)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0heapify(arr, n, i);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// One by one extract an element from heap\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int i = n - 1; i > 0; i--) {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Move current root to end\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int temp = arr[0];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[0] = arr[i];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[i] = temp;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// call max heapify on the reduced heap\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0heapify(arr, i, 0);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0// To heapify a subtree rooted with node i which is\n\xa0\xa0\xa0\xa0// an index in arr[]. n is size of heap\n\xa0\xa0\xa0\xa0void heapify(int arr[], int n, int i){\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int largest = i; // Initialize largest as root\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int l = 2 * i + 1; // left = 2*i + 1\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int r = 2 * i + 2; // right = 2*i + 2\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// If left child is larger than root\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (l < n && arr[l] > arr[largest])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0largest = l;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// If right child is larger than largest so far\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (r < n && arr[r] > arr[largest])\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0largest = r;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// If largest is not root\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (largest != i) {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int swap = arr[i];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[i] = arr[largest];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[largest] = swap;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Recursively heapify the affected sub-tree\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0heapify(arr, n, largest);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n} Might be as good as  or as bad as  Quicksort It’s considered one of the more advanced algorithms because it is a type of divide and conquer method of sorting instead of handling it all as a whole (similar idea to merge sort) It uses the concept of a see-saw Quicksort divides a data into two halves using a pivot point. And then the algorithm tries to change the array so that all the data to the right of the pivot is larger than the pivot value and all the data to the left is smaller than the pivot point. Each element in the array will get a chance to be a pivot.  A way to go about it either to set the peripheral values as pivot points and work from there or to analyze the data and get the median to set as a pivot point. Given the data: 7, 2, 11, 5, 1, 9 7 will be the lower element and 9 will be the higher The pivot data will be 7 (PD). It will go from 9 and one condition for termination will be if it gets to 7 (PD). The next process will be to move the pointer to 1 and then see if PD is larger than 1. It is so 1 will be the new PD and 7 will take the place of 1 right behind 9. 1, 2, 11, 5, 9 Nailing: Important process in setting a pivot. Somehow, 7 will be nailed as a pivot. So, data will be 1, 2, 5, 7, 11, 9. The partitions will be like 1, 2, 5 and 11, 9. For the second partition, 11 will be PD and 9 will be high. So when compared, 11 will be greater than 9 so they will switch spots and 11 will be nailed to the end.   public static void qs(int[] db, int low, int high) {\n\xa0\xa0\xa0\xa0int pivotIndex = partition(db, low, high);\n\xa0\xa0\xa0\xa0if (pivotIndex > low) {\n\xa0\xa0\xa0\xa0\xa0\xa0qs(db, low, pivotIndex - 1);\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0if (pivotIndex < high) {\n\xa0\xa0\xa0\xa0\xa0\xa0qs(db, pivotIndex + 1, high);\n\xa0\xa0\xa0\xa0}\n\xa0\xa0}\n\xa0\xa0public static int partition(int[] db, int first, int last) {\n\xa0\xa0\xa0\xa0int pd = db[first];\n\xa0\xa0\xa0\xa0while (first < last) {\n\xa0\xa0\xa0\xa0\xa0\xa0while (first < last && db[last] > pd)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0last--;\n\xa0\xa0\xa0\xa0\xa0\xa0if (first < last) {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0db[first] = db[last];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0first++;\n\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0while (first < last && db[first] < pd)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0first++;\n\xa0\xa0\xa0\xa0\xa0\xa0if (first < last) {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0db[last] = db[first];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0last--;\n\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0db[last] = pd;\n\xa0\xa0\xa0\xa0\xa0\xa0return first;\n\xa0\xa0\xa0\xa0}\n\xa0\xa0} worst  best   Merge Sort  We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.  This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.  We further divide these arrays and we achieve atomic value which can no more be divided.  Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists. We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.  In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.  After the final merging, the list should look like this −  void merge(int arr[], int l, int m, int r){ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Find sizes of two subarrays to be merged \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int n1 = m - l + 1; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int n2 = r - m; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0/* Create temp arrays */ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int L[] = new int[n1]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int R[] = new int[n2]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0/*Copy data to temp arrays*/ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int i = 0; i < n1; ++i) \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0L[i] = arr[l + i]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int j = 0; j < n2; ++j) \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0R[j] = arr[m + 1 + j]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0/* Merge the temp arrays */ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Initial indexes of first and second subarrays \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int i = 0, j = 0; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Initial index of merged subarry array \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int k = l; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while (i < n1 && j < n2) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (L[i] <= R[j]) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[k] = L[i]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0i++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[k] = R[j]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0j++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0k++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0/* Copy remaining elements of L[] if any */ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while (i < n1) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[k] = L[i]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0i++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0k++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0/* Copy remaining elements of R[] if any */ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while (j < n2) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[k] = R[j]; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0j++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0k++; \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0// Main function that sorts arr[l..r] using \xa0\xa0\xa0\xa0// merge() \xa0\xa0\xa0\xa0void sort(int arr[], int l, int r) \xa0\xa0\xa0\xa0{ \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if (l < r) { \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Find the middle point \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int m = (l + r) / 2; \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Sort first and second halves \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sort(arr, l, m); \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sort(arr, m + 1, r); \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Merge the sorted halves \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0merge(arr, l, m, r); \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} \xa0\xa0\xa0\xa0} Always  Shell sort Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}  We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this −  Then, we take interval of 1 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}  We compare and swap the values, if required, in the original array. After this step, the array should look like this −  Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array. Following is the step-by-step depiction −   \xa0/* function to sort arr using shellSort */ \xa0\xa0\xa0\xa0int sort(int arr[]) {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int n = arr.length;  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Start with a big gap, then reduce the gap  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int gap = n/2; gap > 0; gap /= 2) {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// Do a gapped insertion sort for this gap size.  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// The first gap elements a[0..gap-1] are already  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// in gapped order keep adding one more element  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// until the entire array is gap sorted  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (int i = gap; i < n; i += 1) {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// add a[i] to the elements that have been gap  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// sorted save a[i] in temp and make a hole at  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// position i  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int temp = arr[i];  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// shift earlier gap-sorted elements up until  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// the correct location for a[i] is found  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int j;  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[j] = arr[j - gap];  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// put temp (the original a[i]) in its correct  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0// location  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[j] = temp;  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return 0;  \xa0\xa0\xa0\xa0}  Works super-fast with a complexity of  (for the best AND the worst case) Insertion Sort We take an unsorted array for our example.  Insertion sort compares the first two elements.  It finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.  Insertion sort moves ahead and compares 33 with 27.  And finds that 33 is not in the correct position.  It swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.  By now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.  These values are not in a sorted order.  So we swap them.  However, swapping makes 27 and 10 unsorted.  Hence, we swap them too.  Again we find 14 and 10 in an unsorted order.  We swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.  List<int> insert(List<int> arr){\n\xa0\xa0int i, j, key, n = arr.length;\n\xa0\xa0for (i = 1; i <= n-1; i++){\n\xa0\xa0\xa0\xa0j=i;\n\xa0\xa0\xa0\xa0key = arr[j];\xa0\xa0\xa0\n\xa0\xa0\xa0\xa0while (j > 0 && key < arr[j-1]){\n\xa0\xa0\xa0\xa0\xa0\xa0arr[j] = arr[j-1];\n\xa0\xa0\xa0\xa0\xa0\xa0j--;\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0arr[j] = key;\n\xa0\xa0}\n\xa0\xa0return arr;\n}\nvoid main() {\n\xa0\xa0var stuff = [1, 5, 2, 8, 3, 69, 4];\n\xa0\xa0print(stuff);\n\xa0\xa0print(insert(stuff));\n\xa0\xa0//! Output\n\xa0\xa0//[1, 5, 2, 8, 3, 69, 4]\n\xa0\xa0//[1, 2, 3, 4, 5, 8, 69]\n}  best case  Bubble sort Basically, just checks each pair of adjacent elements and swaps them if they’re not in order. Not great for large data sets. List<int> bub1(List<int> arr){\n\xa0\xa0int temp, n = arr.length;\n\xa0\xa0for (int i = 0; i < n; i++){\n\xa0\xa0\xa0\xa0for (int j=n-1; j > i; j--){\n\xa0\xa0\xa0\xa0\xa0\xa0if (arr[j] > arr[j-1]){\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0temp = arr[j];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[j] = arr[j-1];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[j-1] = temp;\n\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n\xa0\xa0}\n\xa0\xa0return arr;\n} Worst case  Best case  Selection sort This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list. Consider the following depicted array as an example.  For the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.  So we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.  For the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.  We find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.  After two iterations, two least values are positioned at the beginning in a sorted manner.  The same process is applied to the rest of the items in the array. Following is a pictorial depiction of the entire sorting process −  List<int> selec(List<int> arr){\n\xa0\xa0int minPos, temp, n = arr.length;\n\n\xa0\xa0for (int i=0; i <= n-2; i++){\n\xa0\xa0\xa0\xa0minPos = i;\n\xa0\xa0\xa0\xa0for (int j = i+1; j <= n-1; j++){\n\xa0\xa0\xa0\xa0\xa0\xa0if (arr[j] < arr[minPos]){\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0minPos = j;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0temp = arr[i];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[i] = arr[minPos];\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0arr[minPos] = temp;\n\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n\xa0\xa0}\n\xa0\xa0return arr;\n}  Searching Algorithms Linear Search In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection. int linearSearch(int List[], int arrSize, int sk){   int i = 0, found = 0;    while (i < arrSize && !found)  \tif(List[i] == sk) found = 1; \telse i++;   if (found) return 1; // or i for the index   else return -1; } Has a runtime complexity of  Binary Search A searching algorithm that’s adapted for a sorted data set. It repeatedly divides the data set into two halves and eliminates half of the array each time it divides. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.  First, we shall determine half of the array by using this formula − mid = low + (high - low) / 2 Here it is, 0 + (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.  Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.  We change our low to mid + 1 and find the new mid value again. low = mid + 1 mid = low + (high - low) / 2 Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.  The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.  Hence, we calculate the mid again. This time it is 5.  We compare the value stored at location 5 with our target value. We find that it is a match.  We conclude that the target value 31 is stored at location 5. Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers. int binarySearch(int List[], int arrSize, int sk){   int low = 0, high = arrSize – 1, mid, found =0;   while(low <= high && !found){ \tmid = (high + low)/2; \tif(sk < List[mid]) high = mid – 1; \telse if(sk > List[mid]) low = mid + 1; \telse /* ie. sk == List[mid] */ found = 1;   }   if (found) return 1;  // or mid for the index   else return -1; } Has a run time complexity of  '}, {'name': '2020-12-19 -- Quick Sort.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/Notes', 'content': 'Quicksort It’s considered one of the more advanced algorithms because it is a type of divide and conquer method of sorting instead of handling it all as a whole (similar idea to merge sort) It uses the concept of a see-saw Quicksort divides a data into two halves using a pivot point. And then the algorithm tries to change the array so that all the data to the right of the pivot is larger than the pivot value and all the data to the left is smaller than the pivot point. Each element in the array will get a chance to be a pivot.  A way to go about it either to set the peripheral values as pivot points and work from there or to analyze the data and get the median to set as a pivot point. Given the data: 7, 2, 11, 5, 1, 9 7 will be the lower element and 9 will be the higher The pivot data will be 7 (PD). It will go from 9 and one condition for termination will be if it gets to 7 (PD). The next process will be to move the pointer to 1 and then see if PD is larger than 1. It is so 1 will be the new PD and 7 will take the place of 1 right behind 9. 1, 2, 11, 5, 9 Nailing: Important process in setting a pivot. Somehow, 7 will be nailed as a pivot. So, data will be 1, 2, 5, 7, 11, 9. The partitions will be like 1, 2, 5 and 11, 9. For the second partition, 11 will be PD and 9 will be high. So when compared, 11 will be greater than 9 so they will switch spots and 11 will be nailed to the end. '}, {'name': '2020-12-12 -- Heap Sort.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CS321/Lecture/Notes', 'content': 'Heap tree (binary tree with a heap property): The value on the node should be larger than the parent (max heap). There are two types of heaps, max heaps and min heaps. Max heap is when the parent is greater than the node Min heap is when the parent value is less than the node Complete binary tree: is a left justified, balanced binary tree. Or a maximum height difference between a left and right sub-tree is 1. 12 ,18, 6, 41, 27       Heapify: …?   41, 27, 9, 18, 12, 6 When doing this, in the best-case scenario of this operation. It might be as good as taking time  or it might be as fast as just checking the array and taking time  '}, {'name': '2020-12-15 -- General Course Description.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'General Course Description  What are the two major concerns of the course? Theoretical aspects (inputs) The Practical Components  Chapter 1 The Nature and Components of a Report Systematically observed to collect data. Reports Vs. Essay (similarities and differences) Reports and essays have divisions like an introduction and all that You always know the conclusion to an essay when constructing it while a report answers the question after the data collection. Essays may show a point of view while a report should simply show data without any opinions. Reports are the ones to contain illustrations of data like tables, charts and the like while essays do not have that. Definitions of a Report Systematic observation when collecting data Organization and analysis of collected data Needs to be written objectively and in an unambiguous fashion Unbiased and impartial construction of report. Generalization (is considered to be dangerous) Classification of a Report Oral Reports (not really applicable for this course) Written Reports Informal and Formal Informative Report Interpretive (Analytical/Recommendation) Report Routine and Special Reports Formal Reports Used for academics and use their own conventions Neatness and care required (i.e. proofreading). Require analytical thinking. Informal Reports Chapter 2 Structure of Reports Front matters Main body Back matters  '}, {'name': '2020-12-29 -- Data Presentation.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'Data Presentation Classify your ideas into sections Use headings and sub-headings appropriately If you use tables and figures, Present them near the relevant parts They should precede the discussion They should have a title or caption as the case may be They should present different words, meaning a particular set of data shouldn’t be presented by multiple tables and figures simultaneously. Titles of the tables appear at the top and captions or titles for figure appear at the bottom. Tables and figures should be consecutively numbered. Titles should: Not be written as short phrases  Not be in question or statement form (?) Data Analysis Discussion After presenting the results (backwards order) you: Evaluate and interpret their implications, especially with respect to your research/questions or hypotheses. Here you will examine, interpret, and qualify the results and draw inferences and conclusions from them. Emphasize any theoretical or practical consequences of the results. (When the discussion is relatively brief and straightforward, some authors prefer to combine it with the Results section, creating a section called Results and Discussion.) How to Organize your discussion Open the discussion section with a clear statement of support or your hypothesis/research questions. Similarities and differences between your results and the work of others should be used to contextualize, confirm and qualify your conclusions. Do not simply reformulate and repeat points that you’ve already made; each new statement should contribute to your interpretation and to the reader’s understanding of the problem. Interpretation This is a very important part of the research report Points to consider while writing the interpretation: Explain the possible reasons for the outcomes of the research. Compare the results with the results of previous studies Generalize from the results (be careful of your words, remain tentative) Ask as many questions as possible to see what your data could mean. Let the facts speak for themselves, do not force your data to prove your points or hypothesis. '}, {'name': '2020-12-22 -- Main Body - Structure of Reports.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'Structure of Reports Main Body Components: Introduction Statement of the problem  This is basically the statement form of the interesting title you had crafted in the front matters. Also stating the background of the study and why you’d decided to study it. Objectives How your objectives must be set: SMART S: Specific; the objective must be highly specific. Written with action verbs (demonstrate, assess) M: Measurable  A: Accurate R: Reliable T: ? Significance Answers the question of why Specifies who benefits from this study Delimitation (Scope of the study) Limitations (Constraints) Operations Definitions (if any) Organization of the paper Also known as the background It provides background/context for undertaking the research to hook your readers. Describes the relevant scholarship/previous studies. It also indicates the current status of the area under investigation. It is the tool to indicate to your reader that your research is unique and of added value. Concludes with the brief but formal statement of the purpose of the research that summarizes the material preceding it. A good introduction must have: Motivation: explains why it is important. Background: explains the history of this issue. Objectives: explains what you’re trying to accomplish with the report. Scope: explains what the focus of your analysis is Limitations: explains the constraints and other limiting factors you face Organization: this section explains how the report is organized. Main Body Review of Related Literature It is the critical evaluation of materials Meaning it should define and clarify the problem Summarize previous investigations to inform the reader of the status of the research. Organized around and directly related to the thesis or research question Is NOT repeating work that has been done before. Sources of Literature Products of research Dissertations  Formal reports Books (hard or soft copies) Online publications (with proper URL references) Avoid using textbooks, Wikipedia and sources whose scholarly features are questionable Note-taking Quoting Putting other’s ideas into your own words Summarizing Paraphrasing Don’t be a slave to the owner’s words or phrases without disrupting the meaning. Quoting Using other’s materials as they are written in the source document to: Affirm your statement Capture the precise language of an expert who made the point exceptionally well. Discuss the source’s exact choice of words to better understand complex subjects or specialized language. Draw attention to an important point. Never let a quotation stand on its own. '}, {'name': '2021-01-01 -- Back Matters [INCOMPLETE].docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'Back Matters References/Bibliography Appendices References Acknowledge the works of previous scholars and provide a reliable way to locate them. Enable the readers to retrieve and use the sources Must be correct and complete The word “References” should appear in uppercase letter centered. (advisor) Remain consistent in referencing sources Use numerical (square bracketed) order to list the resources Appendices  '}, {'name': '2020-12-18 -- Structure of Reports.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'Structure of Reports A report is structured into: Front matters Main Body Back matters Front Matters Contains: The cover-page. The title and approval page. Table of contents List of tables and figures List of Acronyms and Abbreviations. The acknowledgements. The Abstract. Cover page The cover page consists of: The logo of the institution The Title and the author, in the middle, centered And the date at the bottom. Centered. The cover page exists simply as a form of protection against the environment. Title and Approval page The title page consists of: The title of the thesis and/or project at the top and centered The title cannot be a complete sentence. The title cannot be a question. The title must catch the reader’s eye and attention. The title should be a maximum of 12 words. The author in the middle and centered The purpose of the report (i.e. the phrase) “A Thesis submitted to… in a particular fulfillment of the requirements for the Degree of (insert name of the degree) ………” The date, at the bottom and centered. The Table of Contents Includes all the report sections, subsections and appendices. Can go up to 4 levels (like 1.1.1.1) Major headings are in capitals and more attractive so as not to make the page look boring and uninteresting. It is not a numbered page of the report. Is the outline of the major headings of a report Shows the organizational structure of a paper. The main aim should be to help readers to find specific information quickly. Should consist of headings the same way they appear in the body. Has sub-headings indented 3 lines of space before the proceeding heading and page numbers for each heading Does not show title, blank, and dedication pages. The List of Tables and Figures List any illustrations, tables, charts, figures maps and so on, giving the page number for each. Identifies the location of tables/figures indicating page numbers. Each table and/or figure should contain some sort of caption for better sorting and organization. Where should you store the caption/title? At the top of the table and named like “Table One” At the bottom of the figure and named like “Figure One” Acknowledgements Listing the people, you wish to thank for help given with the report. Statements which recognize individuals and/or institutions that contributed to the thesis Research participants Employers Funding body Advisors, etc. Describes how they contributed to the work. Abstract “The Abstract is writing the whole report in short” Should be about half a page or so. Gives a brief summary or overview of the report, including its conclusions. Restricted to usually to one paragraph, and concise. Omit details or examples, except main experimental data. Must not be longer than half a page and must not contain figures or make reference. Must coney the key elements of the objective and context, and the most important methods, findings and recommendations. No specific technical jargon, abbreviations, or acronyms of the report. The abstract is usually the last part of the report to be written. Include in the abstract the keywords that someone may use to search for the report in a literature database. The Abstract is not an introduction to the report. It often provides no background information. Every word is important, limit the use of words that do not convey important information to a minimum (250-300 words). As a summary of work done, it is usually written in past tense. It is a numbered page (roman numbered as it’s part of the front matters) '}, {'name': '2020-12-25 -- Research Design.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 3/CC351/Notes', 'content': 'Research Design (Metrology) Contains: Research Methods Findings Data presentation, analysis and interpretation Research Methods Gives detailed information about data collection and analysis, including,  Type of research, sources of data, population, sample size, sampling techniques, data collection tools, data collection, presentation and processing methods, ethical considerations. We use systematic random sampling techniques to collect sample data. Justify why you have chosen the methods, samples, sampling techniques, etc. Make sure that all components of the research methods are discussed well. Mind the tense you use (simple past is mostly used). Remain consistent. Remain consistent in using the appropriate tense throughout your work. Sources of Data/Information Primary Interview Observation Experimentation Company records Questionnaire, etc. Secondary Books Journals Magazines Other published documents The difference between these is that secondary sources of data are more evaluated than primary. Provides evidence in the form of: Theoretical ideas Critical evaluations Research findings, and Scholarly opinions Academic sources of evidence differ from: Your own opinions, Conclusions or outcomes of discussions on the issue with friends or relatives, A celebrity’s opinion, Opinion columns in newspapers (as opposed to newspaper articles) Methods of Collecting Data Choose the ones relevant to your purpose. We may place them into: Category A. (mainly using words) Interviews Accounts Diaries Focus groups Document interrogation Category B. (using both words and/or numbers) Questionnaires  Observation Category C. (mainly using numbers) Tests Official statistics Other numerical data '}, {'name': '2020-02-27 -- In documents you can find information about.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'In documents you can find information about: Problems with existing systems Opportunities to meet new needs if only certain information or information processing were available Titles and names of key individuals who have an interest in relevant existing systems Special information-processing circumstances that occur irregularly that may not be identified by any other requirements determination technique The reason why current systems are designed as they are, which can suggest features left out of current software that may now be feasible and desirable Data, rules for processing data, and principles by which the organization operates that must be enforced by the information system. Prototyping is most useful for requirements determination when: User requirements are not clear or well understood, which is often the case for totally new systems. One or a few users and other stakeholders are involved with the system. Possible designs are complex and require concrete form to evaluate fully. Communication problems have existed in the past between users and analysts, and both parties want to be sure that system requirements are as specific as possible Prototyping also has some drawbacks as a tool for requirements determination. They include: A tendency to avoid creating formal documentation of system requirements, which can then make the system more difficult to develop into a fully working system. Prototypes can become idiosyncratic to the initial user and difficult to diffuse or adapt to other potential users Prototypes are often built as a stand-alone system, thus ignoring issues of sharing data and interactions with other systems. A data flow: Is data that are in motion and moving as a unit from one place in a system to another A data flow could represent: Data on a customer order form or a payroll check A query to a database The contents of a printed report Data on a data-entry computer display form A data flow can be composed of many individual pieces of data that are generated at the same time and that flow together to common destinations. '}, {'name': '2020-02-10 -- Systems thinking.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'Systems thinking Is a mind set or way of viewing a world as a system. Actually, systems thinking is just one part of the skills a systems analyst requires. It helps to see the big picture; helps to break problems down to their components to avoid complexity. Minimizes the effect a change in one module will have on another It emphasizes on the relationship and the process that goes inside rather the constituent parts or just the sum of the parts. Information System Is an arrangement of people, data, processes, communication, and information technology that interact to capture, transmit, store, retrieve, manipulate and/or display information needed to support and improve day-to-day operations in a business as well as support the problem solving and decision making… Types of Information Systems Classified into various types based on their function: TPS MIS DSS (Decision[?] Support Systems) ESS (Executive Support Systems) Transaction Processing Systems (TPS) Perform and record the daily routine transactions necessary to conduct business, such as sales order entry, hotel reservations, payroll, employee record keeping, etc. TPS are foundation of other information systems. Management Information Systems (MIS) Provide middle managers with reports on the organization’s current performance. The information is used to monitor and control the business and predict the future performance. MIS summarize and report on the company’s basic operations using data supplied by transaction processing systems. Most MIS use simple routines, such as summaries and comparisons, as opposed to sophisticated mathematical models or statistical techniques. …  '}, {'name': '2020-03-16 -- DFD completeness.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'DFD completeness: refers to the extent to which all necessary components of the system have been included and fully described in the model. DFD consistency: refers to the extent to which information contained on one level of a set of nested data-flow diagrams is also included on other levels. DFD Timing: refers to drawing the DFD as if the system you are modeling has never started and will never stop DFD Iterative Development: refers to counting on drawing the same diagram over and over again, in an iterative fashion. Iterative DFD development recognizes that requirements determination and requirements structuring are interacting, not sequential, sub-phases of the analysis phase of the SDLC. Primitive DFDs: one of the more difficult decisions you need to make when drawing DFDs is when to stop decomposing processes. One rule is to stop drawing when you have reached the lowest logical level; however, it is not always easy to know what the lowest logical level is. Logic Modeling Although data-flow diagrams are good for identifying processes, they do not show the logic inside the processes Because data-flow diagrams are not really designed to show the detailed logic of processes Modeling Logic with Decision Tables Decision table is a matrix representation of the logic of a decision, which specifies the possible conditions for the decision and the resulting actions. A decision table has three parts: Condition stubs is part of the decision table that lists the conditions relevant to the decision Action stubs is part of a decision table that lists the actions that result for a given set of conditions. Rules is part of a decision table that specifies which actions are to be followed for a given set of conditions Indifferent condition: is a condition whose value does not affect which actions are taken for two or more rules. Decision Table Basic Procedures In constructing decision tables, the general set of basic procedures to be followed are: Name the conditions and the values each condition an assume Name all possible actions that can occur List all possible rules Define the actions for each rule Simplify the decision table Modeling Logic with Decision Trees A graphical representation of a decision situation Decision situation points are connected together by arcs that terminate in ovals Two main components … … Read from left to right Each node corresponds to a numbered choice ona a legend All possible actions are listed to the far right. Modeling Logic with Structured English Structured English is a modified form of the English language used to specify the logic of information system processes Although there is no single standard, structured English typically relies on action verbs and noun phrases and contains no adjectives or adverbs. It is possible to use Structured English to represent all three processes typical of structured programming: sequence, conditional statements, and repetition. Conceptual Data Modeling A conceptual data model is a representation of organizational data. The purpose of a conceptual data model is to show as many rules about the meaning and interrelationships among data as possible, independent of any database management system or other implementation considerations. Entity-relationship (E-R) data model is a commonly used diagram that shows how data are organized in an information system. The main goal of conceptual data modeling is to create accurate E-R diagrams. Methods such as interviewing, questionnaires, and JAD sessions can be used to collect information for conceptual data modeling On larger systems development teams, a subset of the project team concentrates on data modeling while other team members focus attention on process or logic modeling Since the process flow, decision logic, and data-model descriptions of a system describe different but complementary view of the same information system, they must be consistent and complete. For example, the names of data stores on primitive-level DFDs often correspond to the names of data entities in entity-relationship diagrams, and the data elements in data flows on DFDs must be attributes of entities and relationships in entity-relationship diagrams. '}, {'name': '2020-02-24 -- Assessing Economic Feasibility.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'Assessing Economic Feasibility The purpose of economic feasibility study is to identify the financial benefits associated with the development project. Assessing Other Feasibility Concerns Operational Feasibility: The process of assessing the degree to which a proposed system solves business problems or takes advantage of business opportunities. Technical feasibility: The process of assessing the development organization’s ability to construct a proposed system. Political feasibility: the process of evaluating how key stakeholders withing the organization view the proposed system Systems Analysis … Determining Requirements During requirements determination, information on what the system should do is gathered from as many sources as possible. Understanding the following components of an organization is crucial: The business objectives that rive what and how work is done The information people need to do their jobs The data handled withing the organization to support the jobs When, how, and by whom or what the data are moved, transformed and stored The sequence and other dependencies among different data-handling activities The rules governing how data are handled and processed Policies and guidelines that describe the nature of the business, the market, and the environment in which it operates Key events affecting data values and when these events occur Guidelines for Effective Interviewing Plan the interview Be neutral Listen and take notes Review notes Seek diverse views  '}, {'name': '2020-02-17 -- Phase 4.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'Phase 4: Systems Implementation and Operation During systems implementation and operation, you turn system specifications into a working system that is tested and then put into use. Implementation includes coding, testing and installation. During operation, programmers make the changes that users ask for and modify the system to reflect changing business conditions. Prototyping Prototyping is the process of designing and building a scaled-down but working version of a desired system. The key advantages of prototyping technique are: It involves the user in analysis and design It captures requirements in concrete, rather than verbal or abstract form Rapid Application Development Rapid application development (RAD) is a systems development methodology created to radically decrease the time needed to design and implement information systems. Focus is more on system functional and user interface requirements at the expense of detailed business analysis and concern for system performance issues. Agile Methodologies A family of development methodologies characterized by Short iterative cycles and extensive testing Active involvement of users for establishing, prioritizing, and verifying requirements and, A focus on small teams of talented, experienced programmers. Identifying potential development projects This process can be performed by: A key member of top management A steering committee User departments The development group or a senior IS manager Classifying and ranking IS development projects Assessing the merit of potential projects is the second major activity in the project identification and selection phase. The criteria used to evaluate projects usually varies by organization Possible evaluation criteria when classifying and ranking projects are: Value chain analysis Strategic alignment Potential benefits Resource availability Project size/duration Technical risk/difficulty Selecting IS development projects The selection of projects is the final activity in the number identification and selection phase. Numerous factors are considered when selecting a project including: Perceived needs of the organization Existing systems and ongoing projects Resource availability Evaluation criteria Current business conditions 2. Initiating and Planning Systems Development Projects Project initiation focuses on activities that will help organize a team to conduct project planning. Among the activities performed are: Establishing the project initiation team Establishing a relationship with the customer Establishing the project initiation plan Establishing management procedures Project planning focuses on defining clear, discrete tasks and the work needed to complete each task Among the activities performed are: Describing the project scope, alternative and feasibility Dividing the project into manageable tasks Estimating resources and creating a resource plan Developing a preliminary schedule Developing a communication plan Developing a project scope statement Setting a baseline project plan The major outcomes and deliverables from project initiation and planning are the baseline project plan and the project scope statement  The baseline project plan (BPP) contains all information collected and analyzed during the project initiation and planning activity The project scope statement (PSS) clearly describes what the project will deliver and outlines generally at high level all work required to complete the project '}, {'name': '2020-11-16 -- Review 1.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'System Development Approaches, Methodologies and Phases/Processes  Organizations use a standard set of steps, called a systems development methodology, to develop and support their information systems. The systems development life cycle (SDLC) is a common methodology for systems…  Alternative approaches to development Prototyping Computer aided software engineering (CASE) tools Joint application design (JAD) Rapid application development (RAD) Which is the most popular  Agile Methodologies Agile methodologies are a family of development methodologies characterized by Short iterative cycles and extensive testing Active involvement of users for establishing, prioritizing and verifying requirements and, A focus on small teams of talented, experienced programmers The Trend to Agile Methodologies Systems analysis and design, or systems development, has gone thorugh three major phases since its inception Undisciplined approach Engineering approach Agile Methodologies  Agile methodologies are an umbrella of methodologies including: Crystal family of methodologies Adaptive software development Scrum eXtreme .. The Agile Methodologies share three key principles: A focus on adaptive rather than predictive methodologies, A focus on people rather than roles, A self-adaptive process The heart of systems development process In the Agile Methodologies, the activities traditionally though of as belonging to analysis, design and implementation are combined into a single process Analyze -> Design -> Code -> Test (and then back to analyze)  Analysis is about the ‘what’ phase of the process Design is about the ‘how’ phase of the process  Requirement Determination Requirement Determination Methods: Interview Questionnaire Document Analysis Observation JAD Prototyping Systems Requirement Specification (SRS): Functional Requirements and, Non-Functional Requirements Requirement structuring: Process Modelling – (Data Flow Diagram (DFD)) Logic Modelling – (Decision Table, Decision Tree, Structured English) Data Modelling – (Entity-Relationship Model) Process Modeling (next up) '}, {'name': '2020-11-18 -- Process Modeling.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS343/Notes', 'content': 'Process Modeling   Context Diagram Shows a simple data flow Level-0 Diagram Focuses on showing the major processes; Which is more decomposed than the context diagram.   '}, {'name': 'Lec-Assignment-1.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Assignments', 'content': '    DR = SR = 1b/0.001s = 1Kb/s SR = 0.5/0.001s = 500b/s DR = 1b/0.001s = 1Kb/s     Differences Manchester consumes more bandwidth than NRZ-L Similarities Both Manchester and NRZ-L aren’t as effective at conserving bandwidth consumption as Bipolar AMI.    DR = 1b/0.004s = 250b/s; least accurate case. DR Req is lowest. DR = 1b/0.002s = 500b/s; more accurate than case 1. DR = 1b/0.002s = 500b/s; most accurate case. DR Req is highest '}, {'name': '2020-02-18 -- By default.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Lab Notes', 'content': 'By default, all switch ports are on VLAN 1 Access Mode for passing a single VLAN. And Trunk Mode for passing multiple VLANs '}, {'name': '2020-11-19 -- Review 2.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Elements of Routing Techniques  Which performance criteria are used to select a path? When is a path selected? Which nodes are responsible for selecting a path? Which nodes provide information about network status? Topology, link costs, current usage How often is a network status information updated?  '}, {'name': '2020-02-10 -- Delay.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Delay There are 4 components that contribute to total delay: Transmission Delay: time to transmit data on to link Propagation Delay: time for signal element (or bit) to propagate across link Processing Delay: time for device to process data Queueing Delay: time data spent waiting in queue (memory) inside device  Transmission Delay Number of bits to send, b [bytes] Link data rate, r Transmission delay,  Propagation Delay Link distance, d [meters] Speed of signal propagation, s [meters per second] Propagation delay,  Unless otherwise stated, s = c = 3 x 108 '}, {'name': '2019-02-05 -- Communication Overhead.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Communication Overhead: - External control information. Throughput: - Actual speed/bandwidth of a network.     '}, {'name': '2020-02-17 -- Three tradeoffs to consider when we choose the signal.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Three tradeoffs to consider when we choose the signal If all things the same Advantages Increased Bandwidth means there is an Increased Accuracy (less errors) Increased Frequency (BW) also means there is an Increase in the data rate Disadvantages Increased bandwidth means there is an increased cost Increased frequency requires an increased complexity (of hardware)  '}, {'name': '2020-01-29 -- Questions.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Questions A model of communication system consists of Sender Receiver Transmission Media Describe a functionality of a Modem (ADSL) A device that converts a digital to analog signal and vice versa and also acts as a sender and receiver. What is the task of data link layer? Transport layer? Data Link: controls the error detection of the data. Checker of reliable delivery of data across a single link Transport: Same as data link but across a network (end-to-end) Tasks for sending signals across a link are part of Physical Layer Tasks for delivering data across multiple links Network Layer Three important measures of effective data communication. Accuracy: assuring proper transfer of data without errors in encoding or decoding. Timelines: Making sure the data is transferred without too much of a delay depending on context. Delivery: assuring that the data is transferred to the correct address/destination.(Network) WAN Wide Area Network Covers a large surface area Owned by the Internet Service Provider Collection of LANs LAN Local Area Network Covers a relatively small surface area Two important protocols in the Internet, and from which the internet stack gets its name TCP/IP Transfer Control Protocol Internet Protocol The application layer protocol used by web browsers to download web pages? HTTP(s)  Data Communication – link communication (across a single ink) Computer Networks – across multiple links Application Transport Network Data link Physical (hardware)  What is a Protocol? Set of rules that two (or more) peer entities obey in order to communicate Syntax: format of data blocks; types of messages Procedures: set of rules each peer must follow; timing information TCP/IP Layers Physical layer Physical interface between transmission device and medium; how to send bits over transmission medium: data rate, signaling, electrical signals, codecs, modems… Data Link Layer Transmission  Network Layer Allows hosts to communicate across different networks; provides routing across the internet; may provide congesting control, quality of service; sometimes called: “IP”, internet layer Transport layer Transfer of data between end-points; connect processes running in OS of host; may provide error control, flow control, congestion control, reliable deliver Application Layer Provides functionality needed for various applications  '}, {'name': '2020-11-17 -- Review 1.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Computer Networking Networking is data communication across multiple links. Switching: Answers the question on how the packets are forwarded Switching Types Circuit Switching: Phone calls Packet Switching: Internet Datagram Drawback is that packets may come back out of order. Virtual Circuit Routing:  Answers the question of selecting the pest path. Best path can be chosen by: Least number of hops (RIP uses that) Least cost (OSPF uses this)  Application Transport Network Data-Link Physical   '}, {'name': '2020-11-21 -- Review 3.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'Flooding Instead of a choosing a route before sending the data, just send the data to everyone. A copy of the original packet is sent to all neighbors of the source Each node that receives the packet, forwards a copy of the packet to all of its neighbors. Advantages: All possible routes are tried; at least one packet will take a minimum hop route, e.g. setup a virtual circuit All nodes are visited Simple Disadvantages: Inefficient: need to send many copies of a packet to get one packet from source to destination Using hop limit and/or selective flooding, packet may not reach destination. Flooding Extensions Don’t send back the same packet to the node that sent it. Only forward a packet once: nodes remember which packets they have forwarded; do not forward a packet if you have previously forwarded that same packet Duplicate detection: each packet has a sequence number so if destination receives multiple copies of the same packet, it can discard the duplicates Hop Limit:  '}, {'name': '2020-02-03 -- SCTP.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': 'SCTP – Stream Control Transmission Protocol DCCP – Datagram Congestion Control Protocol ICMP – Internet Control Message Protocol (Send error messages and operational info) OSPF – Open Short Path First (Routing) ARP – Address Resolution Protocol – discovering the link layer address Frame Relay – standardized WAN technology of the physical and data link layers of digital telecommunications channels using packet switching ATM – Asynchronous Transmission Mode : standard defined by ANSI and ITU (carrieage of user traffic, telephony, data and video) SDH – Synchronous Digital Hierarchy Transport large quantities of data over digital transport equipment such as fiber optic PDH – Plesiosynchronous Digital Hierarchy    Ethernet – LAN (Embedded in hardware devices) '}, {'name': '2020-02-26.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': ' to determine the power loss between transmitter and receiver.       - Parabolic antenna '}, {'name': '2020-02-12 -- Data Transmission.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS461/Notes', 'content': '3. Data Transmission Spectrum – Length of frequency Absolute bandwidth – width of spectrum If a signal contains a frequency with 0 zero frequency, then the signal is said to have a DC component Many signals have infinite absolute bandwidth, but most of the signal energy is contained in narrow band of frequencies; called Effective Bandwidth or just Bandwidth In practice, transmission system can only carry limited band of frequencies '}, {'name': 'Online Assignment 1.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CC234/Assignments', 'content': 'HiLCoE School of Computer Science & Technology  Statistics and Probability (CC234) Assignment 1         Submitted to: Paulos Gemechu  Done by:  Bruk Berhane Asfaw    30th May, 2020    Int: The average mid-term mark scored from a sample of 60 students is 18.17.    Int: About 50% of the sample students scored 18.1 on the exam.          Int: 75% or more of the data lies between 34.2 and 1.65                If we view the coefficient of variation of the two companies, we can assume that the monthly salaries of the employees of Deluxe is relatively more variable than that of NHBAY    Int: As can be observed, Mrs. Fozia of Deluxe gets paid better relative to her group.    : - the area between x=20 and x=23.7 is Z20   : - the area between x=30 and z=23.7 is Z30 Area between x=20 and x=30 = 0.3554 + 0.4641 = 0.8195 * 100 = 81.95% Int: 81.95% of the age of first marriage for men in Australia is between 20 and 30 years old.           and     96 Int: Strongly, inversely related   marks Explained Variation   Int: 92.2% of the changes in the test scores can be explained/related to the time spend watching the television.   Unexplained Variation   Int: 7.8% of the changes in test scores can not be attributed to the hours spent watching television and are instead explained by other problems/occurences.      '}, {'name': 'Assignment 1.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CC234/Assignments', 'content': '                  The next answer is the better answer for (iii) and (v) Less than type \t      Greater than type       Int: The most time averagely spent in the school by the most students from the sample HiLCoE students data is about 32.4 hours.      Int: About 50% of the sample HiLCoE student more than approximately 33.38 hours at school.    Int: More than 25% of the sample HiLCoE students spent more than 26.3 hours at school.     Int: More than 75% of the sample HiLCoE students spent less than 39.4 hours at school.    Int: More than 20% of the sample HiLCoE students spent more than 24.2 hours at school.     Int: About 40% of the sample HiLCoE students have spent more than approximately 35.4 hours at school.     Int: Less than 90% of the sample HiLCoE students have spent less than or equal to 38.5 hours at school. '}, {'name': 'Online Assignment 2.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CC234/Assignments', 'content': '   Int: The average age of the sample of 60 offenders who committed auto-theft crimes in Addis Ababa is 25.03 years old.    Int: At least 50% or above of the sample of 60 offenders who committed auto-theft crimes in Addis Ababa are 24.75 years or older  According to Chebyshev’s Theorem, you will always find at least 75% of the data between 2s of .   Int: At least 75% of the data lies between the interval 11.73 – 38.33.             Int: The adolescent boys gain 2.8Kgs for every 10 calories they consume. They also lose 4.72Kgs when they don’t consume any food.  Int: There is a strong positive correlation between food consumption and weight gain.       Int: 84% in the changes in weight in adolescent boys can be attributed to food consumption.   Int: 16% of the changes in weight can not be attributed to food consumption and can be explained by other factors.                1.1m – 3.5m  = 1.2  = 1.2 S = 1.2 Int: A minimum of 75% of the data lies between 1.1 – 3.5 million 0.8 – 3.8  = 1.5  = 1.5 S = 1.5 Int: A minimum of 84% of the data lies between 0.8m – 4.1m 0.5 – 4.1  = 1.8  = 1.8 S = 1.8 Int: A minimum of 89% of the data lies between 0.5m and 4.1m        Int: The probability that any random tropical insect living less than 70 days is 40%      0.31 Int: The probability that any random tropical insect living more than 76 days is 31%      = 0.47 Int: There is a 47% probability that any given tropical insect will live between 68-78 days  '}, {'name': 'robots.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 2/CS322/Assignment/pwa_notebook/public', 'content': '# https://www.robotstxt.org/robotstxt.html\nUser-agent: *\nDisallow:\n'}, {'name': '2019-11-15 -- Worksheet Selective Answers.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Class Exercises', 'content': "--Number 1\nCREATE PROCEDURE [Employee Salary Increment]\n(@newSalary decimal(7,2), @employeeID int)\nAS\nBEGIN\n\t--OPTION 1\n\tIF @newSalary > (SELECT salary FROM Employee WHERE eid = @employeeID)\n\tBEGIN\n\t\tUPDATE Employee SET salary = @newSalary WHERE eid = @employeeID\n\tEND\n\t--OPTION 2\n\tUPDATE Employee SET salary = CASE\n\t\t\t\t\t\t\t\t\tWHEN salary > @newSalary THEN salary\n\t\t\t\t\t\t\t\t\tWHEN salary < @newSalary THEN @newSalary\n\t\t\t\t\t\t\t\t\tEND\n\tWHERE eid = @employeeID\n\t--OPTION 3\n\tUPDATE Employee SET salary = @newSalary WHERE eid = @employeeID AND salary < @newSalary\n\n\tIF @@ROWCOUNT > 0\n\t\tRETURN 1\n\tELSE\n\t\tRETURN -1\nEND\n\n--Number 2\nDECLARE @Table TABLE\n(\n\tFullName VARCHAR(50),\n\tAge int\n)\n\nINSERT @Table\nSELECT name, DATEDIFF(YEAR, DoB, GETDATE()) FROM Employee\n\n\n--Number 5\nSELECT dbo.getFullname(first_name, last_name) FROM Employee WHERE Department = 'Research'\n\n--Number 6\nDECLARE @output int\nEXEC myProc 5, 3, @output OUTPUT\nPRINT @output\n\n--Number 7\nDECLARE @f, @l, @depID\nOPEN CurEmployees\nFETCH NEXT FROM CurEmployees INTO @f, @l, @depID\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n\tPRINT @f + ' ' + @l + ' ' +(SELECT DepName FROM Department WHERE DepID= @depID) + char(13)\n\tFETCH NEXT FROM CurEmployees INTO @f, @l, @depID\nEND\nCLOSE CurEmployees\nDEALLOCATE CurEmployees"}, {'name': '2019-11-27 -- Sub-Queries and Data Types.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Sub-Queries A select statement nested in another statement Enclosed in a parenthesis Returns a single value Also referred as inner query Correlated Sub-Query Will be executed for each row returned by the outer query If the sub query depends on the outer query, then it’s called a correlated sub-query  Special Data Types Row version or Timestamp Data Type ROWVERSION and TIMESTAMP are synonyms Have been available since 2005 TIMESTAMP is deprecated. Automatically generated, unique binary numbers within a database Has nothing to do with dates or times Binary numbers (OR HEX [it might not be binary]) that indicate the relative sequence in which data mods have occurred in a database Generally used as a mechanism for version-stamping table rows Never use timestamp columns in keys, especially primary keys Cause value changes every time the row is modified Is NOT a date or time It’s a binary number that gets incremented by SQL whenever the row is updated It’s a row version, not a date It cannot go into a date time column Storage size is 8 bytes Only one ROWVERSION column is allowed per table When you insert or update a row A new number across the table is generated and assigned to the ROWVERSION column This property makes the column a poor candidate for primary keys Sql_variant Data Type A data type that stores values of various SQL Server supported data types A column defined as sql_variant can store int, binary and char values Can have a maximum length of 8016 bytes. A table can have any number of sql_variant columns Sysname Allows you to store database object names. Some features are Can store object names from the sql database, such as functions, stored procedures, tables, users, server names, databases, login, and views. When declaring the data type, the object names assigned to it must be quoted. User Defined Data Type (ALIAS) There are some situations where a customized data type is needed for consistency across an app Then can be considered customized SQL Server data types Are also called Alias Data types. Ex. Can be phone numbers in a specific format, … Allow developers to use the same type for the same type of columns We can create user defined data types and bind them to an existing default and rule Using your own defined types with rules and defaults will provide a powerful mechanism to implement uniformity and consistency in your database design. Is only accessible in a single database as such Store the definition in a script so that it can be used whenever required Create the objects in the model database so as the new databases that are created have the user defined data types, rules, defaults etc. To modify it you need to drop and recreate it. CREATE DEFAULT Creates an object called a default Specifies a value to be inserted in to the column to which the object is bound (or into all columns, if of an alias data type), when no value is excplicitly supplied during an insert Can be bound to a column or alias data type CREATE RULE Creates an object called a rule When bound to a column or alias, a rule specifies the acceptable values that can be inserted. A rule can be any expression valid in a where clause Can include Elements such as arithmetic operators Predicates as in like, equals, is…  '}, {'name': '2019-10-23 -- Control.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Control-of-Flow Statements SELECT @SQL = Salary FROM Employee WHERE E_ID = 509  IF <Boolean> \t<Statement> | BEGIN <series of code> END ELSE  \t<Statement> | BEGIN <series of code> END  WHILE <Boolean> [BEGIN \t<Statement block> \t[BREAK] \t<Statement block> \t[CONTINUE] END]   WHILE (SELECT SUM(Salary) FROM Employee) < 150000 BEGIN \t \tIF (SELECT SUM(Salary + 100) FROM Employee) < 150000 \t\tUPDATE  Employee SET Salary += 100 \tELSE \t\tBREAK \t \tIF (SELECT MIN(Salary) FROM Employee) > 7000 \t\tBREAK \tELSE \t\tCONTINUE  The GOTO Statement Causes the flow of execution to a LABEL The LABEL is an identifier followed by a colon The statements that follow GOTO are skipped and processing continues at the label GOTO statements and labels can be used anywhere within a procedure, batch, or block but they have to be in the same batch.  Built-In Functions  '}, {'name': '2019-11-05 -- Stored Procedure.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Stored Procedure A stored procedure is a saved collection of T-SQL statements A batch is stored in the database Or precompiled script Syntax CREATE PROC <procedure name> \t< (parameter list) > AS BEGIN \t<statements> END Advantages When a stored proc is created, it is “pre=compiled” When the procedure is run for the first time, all the information about it is stored in the system cache, which makes it much faster to run subsequently They require much less network traffic and therefore may run much more quickly than other queries passed from client to application They make maintenance of code much simpler because it is managed in one place Stored procs can be used by multiple applications Stored pros are an excellent way of encapsulating business rules  PARAMETERS You can supply default values You don’t need to enclose the parameters in brackets ENCRYPTION Indicates that SQL Server will convert the original text of the CREATE PROCEDURE statement to an obscured format CREATE PROC spEncryptThis  AS BEGIN  END Executing Stored Procedures When a procedure is executed it is compiled to determine optimal access plan to retruve data Subsequent executions  may reuse the plan already genereated Nested stored procedure Refers to one stored procedure calling another one. Return Values Return values are used: To return data such as identity value or the number of rows that were affected by the procedure To return values to indicate the status of the stored procedure It’s recommended to return status of the stored proc By default SQL server auto returns a value of 0 when proc completes The return value must be an integer '}, {'name': '2019-10-30 -- Scalar Functions.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Scalar Functions CREATE FUNCTION function_name \t([@parameterName datatype [=default][ , … n] ] ) \tRETURNS return Data Type AS BEGIN \tFunction_body \tRETURN scalar_expression END  CREATE FUNCTION getFirstName(@fullName varchar(100)) RETURNS varchar(50) AS BEGIN \tRETURN SUBSTRING(@fullName, 0, CHARINDEX(@fullName, ‘ ‘)) END  Table- Valued Functions  CREATE FUNCTION LetterConverter(@letter VARCHAR(30)) RETURNS INT AS BEGIN \tCASE @letter \t\tWHEN @letter = ‘A’ THEN RETURN 4 \t\tWHEN @letter = ‘B’ THEN RETURN 3 \t\tWHEN @letter = ‘C’ THEN RETURN 2 \t\tWHEN @letter = ‘D’ THEN RETURN 1 \t\tELSE RETURN 0 \tEND END '}, {'name': '2019-12-04 -- User-defined table (SHORT).docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'User-Defined Table Type Basically makes an inheritable table that variables can use as a data type. '}, {'name': '2019-12-18 -- Backups and Restore.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Backups and Restore Recovery models Simple: Log backups are not supported .. ..  Backing up Databases Full backup Differential backup Simple backup  Full Backup Is a full backup of the database files as it is as of the last transaction that was committed prior to you issuing the backup command… Differential Backup Backup of everything that’s happened since another full backup Writes out changes that have happened since the last full backup It only writes out a copy of the extends that have changed since you did the last full backup Ideal for very large databases where backups can take a very long time to run Take a full backup only one in a period of time Take several differential backups in between the FULL backup to save both space and time. Transaction Log Backup Is a “copy” of the transaction log It is a backup of the log files since the last backup Can only be used when the database is set to full or Bulk logging Cannot be used with a Simple Recovery Model Both differential and transaction backups need a full backup in order to be used for restoring the database  BACKUP DATABASE DB_NAME TO DISK = FULL_FILE_NAME –(.bak extension) [WITH FORMAT]  BACKUP LOG DB_NAME TO DISK = FULL_FILE_NAME  Restore Database Restores backups taken using the BACKUP command. Let’s you Restore an entire DB from a full DB backup To restore to a specific point in time RESTORE DATABASE DB_NAME\nFROM DISK = FULL_FILE_NAME [WITH <RECOVERY | NORECOVERY | STANDBY>] Recovery States Determines the state of the database after the restore operation RESTORE WITH RECOVERY The default behavior which leaves the database ready for use by rolling back the uncommitted transactions RESTORE WITH NORECOVERY Leaves the database non-operational Doesn’t roll back the uncommitted transactions Additional transaction logs can be restored The DB can’t be used until it is recovered RESTORE WITH STANDBY Leaves the database in read-only mode Uncommitted transactions are undone Using Full Database Backup Full backups contain all information necessary to restore your database to the point in time when the backup process had finished The backup will overwrite your DB if such a DB exists or produces a new database If you are going to continue with restoring differential or transaction log backups You need to add the NORECOVERY option This will leave the backup process in restoring state Using Differential Backup Differential backup restores the DB to the point in time at which the differential backup was completed Use the NORECOVERY clause to restore the full DB backup that comes before the differential DB backup To recover to the point of failure You must apply all transaction log backups created after the last differential backup was created Contain changes that took place in the DB since the last full backup The last differential backup accumulates all the changes So, you don’t need all previous differential backups to restore a database Before using the differential backup, you need to restore the last backup first with NORECOVERY option And then the last differential backup with RECOVERY option Using Transaction Log Backup Contain all transactions that took place between the last transaction log backup Log backups are rerstored after the full and differential backups RESTORE LOG DB_NAME FROM DISK = FILE_NAME (.bak extension) Using a Tail Log Backup (t-log backup) captures all transaction log entries made since the previous t-log backup It captures any log records that have not yet been backed up Used to prevent work loss Captures log records not yet backed up Will be the last backup of interest in the recovery plan for the DB Is executed manually by the DBA just prior to beginning a complete restore In order to perform a tail-log backup, the DB must be In Full or Bulk-logged recovery mode and Have at least one Full backup BACKUP LOG DB_NAME TO DISK = FILE_NAME WITH NORECOVERY  This command captures log entries that have not been backed up Puts the DB into restoring state so that no new data can be inserted RESTORE DATABASE DB_NAME FROM DISK = FILE_NAME WITH NORECOVERY, STOPAT=’Dec 15 2019 3:12 PM’  Read on the STEPS to recover using a T-Log and others  '}, {'name': '2019-10-15 -- Built-in functions.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Built-In Functions Built-in function is a piece or programming  that takes zero or more inputs and returns a value. The inputs to a function are called parameters Some functions have more than one and others may not have any Parameters are enclosed in parenthesis We use functions in the SELECT clause (or anywhere where an expression is allowed) as well as the WHERE filter condition A function can be used anywhere in a SELECT statement that you can  use an expression Deterministic & Nondeterministic A function is said to be deterministic or nondeterministic function depending on whether it returns the same or different value give the same set of inputs Deterministic functions always return the same result Nondeterministic functions may return different results each time they are called EX. Deterministic DATEDIFF, ISNUMERIC, ISNULL Nondeterministic NEWID, NEWSEQUENTIALID String Functions SUBSTRING(value_exp, start_exp, length_exp) Extracts length_exp number of characters from value_exp starting from start_exp UPPER (character_expression) Returns a character expression converted to uppercase LOWER (character_expression) Returns a character expression converted to lowercase. LEFT (character_expression, integer_expression) Returns a specified no. of characters from the left part of a string RIGHT (character_expression, integer_expression) LEN(string_expression) Returns the number of characters of the specified string expression excluding trailing blanks. LTRIM(string_expression) | RTRIM(string_expression) STUFF(character_expression, start, length, character_expression) Inserts a string into another string. Deletes a specified length of cahractesr in the first string at the start position and then inserts the second string into the first string at the start position REPLACE(string_expression, string_expression, string_expression) Replaces all occurrences of a specified string value with another string value ( everything matching the second string expression is replaced by the third string expression) ASCII (character) Returns the ASCII value for the specific character. CHAR (number) Returns the character based on the ASCII code STR (float_expression [, length [,decimal]]) Returns a number as a string CONCAT Adds two or more strings together CHARINDEX (exp to find, exp to search [, start at]) Search char expression Inside a second char expression Returns the position of a patter in a string PATINDEX Returns the position of a pattern in a string If the pattern is not found it returns 0 The search is case insensitive Mathematical Functions FLOOR (numeric_expression) Returns the largest integer less than or equal to the specified numeric expression CEILING (numeric_expression) ABS (numeric_expression) Returns the absolute (positive) value of the specified numeric expression POWER (float_expression, y) Date Functions GETDATE DATENAME( date part, date) Returns a string that represents the date part of the date DATEPART (date part, date) Returns an int that represents the date part of the date DAY (date) Returns the day of the month given from the date. YEAR (date) MONTH (date) DATEDIFF (date part, start date, end date) Returns the number of date or dime date part boundaries that are crossed between two specified dates DATEADD (date part, number, date) Returns a new date value by adding an interval to the specified date part of the specified date ISDATE (expression) Determines whether a datetime or small date time input expression is a valid date or time value. Security Functions CURRENT_USER Returns the name of current user, equivalent to USER_NAME USER_ID Returns the id number for a database user. USER_NAME Returns a database user name from a specified identification number CAST & CONVERT CAST Converts a value of one type into another datatype. (temporarily) CONVERT Converts a value of one type into another datatype. COALESCE Returns the first non-null expression among its arguments COALESCE and CASE The COALESCE expression is a syntactic shortcut for the CASE expression Other Functions ISNULL (check expression, replacement value) The value of check expression is return if it is not NULL; otherwise, replacement value is returned  @@ERROR Function We can respond to errors by using the @@ERROR function. Returns 0 if the last T-SQL statement executed successfully Or an error number if the statement generated an error @@IDENTITY Function The last value inserted into an identity column.. IDENT_CURRENT is not limited by scope or session; It is limited to a specified table Returns the value generated for a specific table in any session or scope SCOPE_IDENTITY  @@ROWCOUNT Function Returns the number of rows affected by the last command Returns int If the number of rows is more than 2 billion use ROWCOUNT_BIG() Statements that make a simple assignment always set the row count value to 1. User-Defined Functions Is a collection of T-SQL statements Accepts params .. .. .. . .  '}, {'name': '2019-12-11 -- Database Administration.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Database Administration Security Backup/Restore Concurrency What is database administration? Set of activities performed to ensure that a database is always available as needed The task of managing and maintaining database management systems The Database Administrator (DBA) A specialized computer systems administrator who maintains a successful database environment Role of the DBA Job is to Maintain data integrity Ensure data availability Protect data from loss and corruption DBA should have a working knowledge and experience Should be familiar with a wide range of DBMS products. Have a degree in CS(?) Have some practical experience Certified(?) Needs for Databases DBs are used by different people in different departments and for different reasons Data interpretation and presentation is different for different uses DMBS must provide each  user a separate view of the data and support their specific needs Distribution of data and information needs to be To the right people At the right time The database supports the organization – at all levels Top Level – Strategic Decisions Middle Management – tactical decisions Operational Management – daily operations… Top Level Management Provide info for strategic decision making Planning, policy formation and making goals Provide access to data to identify growth opportunities Middle Management Provide necessary data for Tactical decision making and Planning Usually at the department level Monitor and control use of company resources How efficiently are the resources allocated and used… Operational Management Support the company operations Support for app development and computer operations Produce query results at the required performance levels Enhance short-term operational ability Timely customer support etc...  Common DBA Tasks Define standards and procedures Capacity planning Installation and configuration Requirements gathering and conceptual design Logical design and implementation Testing and debugging Data migration Performance monitoring Security Troubleshooting Backup and data recovery Operations and maintenance Training and support  Software Installation and Maintenance A DBA often collaborates on initial installation and configuration of a database server The DBA installs the database software and configures it for use Handles on-going maintenance Whenever updates and patches are required ETL Data Extraction, Transformation, and Loading Refers to efficiently importing large volumes of data that have been extracted from multiple systems into a data warehouse environment External Data Is cleaned up and Transformed to fit the desired format so that it can be imported into a central repository Data Migration The DBA handles the transfer of data from the existing system to a new platform. Specialized Data Handling Today’s databases can be massive and may contain unstructured data types such as images, documents or sound and video files. Managing a very large database (VLDB) may require higher-level skills and additional monitoring and tuning Database Backup and Recovery DBAs create backups and recovery plans and procedures based on industry best practices Then make sure that the necessary steps are followed. The DBA may have to persuade management to allocate budget and take necessary steps to preserve data In the case of a server failure or other form of data loss The DBA will use existing backups to restore lost data Different types of failures may require different recovery strategies With technology change, it is becoming ever more typical for a DBA to backup databases to the cloud Oracle Cloud for Oracle Databases and MS Azure for SQL Server Security A DBA needs to know potential weaknesses of the database software and the company’s overall system and work to minimize risks No one system is one hundred percent immune to attacks But implementing best practices can minimize risks In case of a security breach or irregularity, the DBA can consult audit logs to see who has done what to the data. Authentication Setting up employee access is an important aspect of database security Capacity Planning DBA needs to know How large the database currently is Whether he needs to upgrade or whether employees need new training etc. 8. 9. 10.  Development DBA Works to support the application development Focuses on tasks related to Building an effective, usable database environment Support the creation of applications Building and maintaining the proper database structures required by applications Gives guidance to the database programmers Ensures that appropriate and efficient SQL is being coded and tested works with the application team to create and maintain effective database objects DBA needs to be skilled in: Ability to interview end users Translate requirements int a logical data model and E/R diagrams – the process of data modelling… .  '}, {'name': '2019-11-01 -- Cursors.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Cursors Allows you to define a certain result set. Then points to the first record. Is a POINTER data type (handle) Allows you to access to one row at a time It’s a pointer that will walk through the record set row by row A cursor is a database object which is used to retrieve data from a result set one row at a time SQL server works faster with data as a set than it does with interactive series of commands Are slower and consume more resources Should be used as a last option Can be faster than a while loop But they do have more overhead  Declaring a Cursor Declare a cursor Declares a variable of a cursor type The declaration includes The name  Query used to build the result Its scrolling behavior Scope of variable, updatability, visibility of updates and deletes Syntax: DECLARE <cursor Name> CURSOR FOR <select statement> Other keywords  FETCH NEXT FROM <cursor> INTO @<variable> OPEN <cursor> DEALLOCATE <cursor> The FETCH Statement NEXT Returns the row immediately following the next row … …      … The four types of cursors Static Dynamic FAST_FORWARD Keyset-driven Static cursor detect no changes and use relatively few resources Dynamic cursors detect changes, use more resources FAST_FORWARD are READ_ONLY with performance optimizations enabled. Keyset-driven cursors lie in between They detect most changes, but with less resource demands than dynamic cursors.  STATIC Defines a cursor that makes a temp copy of the data Uses tempdb Displays the result set as it was when the cursor was opened Modifications made by other users are not seen by the cursor Doesn’t display new rows inserted into database after cursor opening No Update INSERT or DELETE ops are reflected in the static cursor Unless cursor is closed and reopened KEYSET The membership and order of rows in the cursor are fixed The set of keys that uniquely ID the rows in the cursor (keyset) is stored into a table The keyset is built into tempdb when cursor is opened Changes to non-key values in the base tables are visible to the cursor Inserts made by other users are not visible DYNAMIC ALL DATA CHANGES MADE TO THE ROWS IN ITS RESULT SET ARE VISIBLE All UPDATE, INSERT, and DELETE statements made by users are visible through the cursor. Data values, order and membership of the rows… Absolute fetch is not supported by this cursor FAST_FORWARD Default cursor type READ_ONLY cursor with performance optimizations Can not be specified if SCROLL is also specified Produces the least amount of overhead '}, {'name': '2019-10-16 -- Database Programming and Administration.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Database Programming and Administration T-SQL is not a standard Programming T-SQL Elements of T-SQL Batch and script Variables Flow control statements Built0In Functions Cursors Stored Procedures User-Defined Functions Triggers DML Triggers Programming in T-SQL T-SQL is SQL Server’s own dialect of SQL T-SQL Stands for Transact SQL Procedural Programming Language + SQL Scripts A script is one or more SQL statement(s) stored in a file Scripts generally have a unified goal All the statements within a script have one overall purpose Scripts are stored as text files Scripts are usually treated as a unit You normally execute the entire script or nothing at all SQL script A collection of SQL commands Stored in a text file and Perform some operation or task Scripts are usually used for repetitive tasks Get executed over and over regularly Advantages: Ease of use: the scripts can be saved and loaded when needed Consistent operation: statements are tested and free from errors Scheduled operation Scripts can be scheduled to run a ta time when it is convenient Can be automated Batches A batch is a grouping of T-SQL statements into one logical unit Batches are used when something has to happen either before or separately form everything else in your script. All statements in a batch are compiled into one execution plan Batches are delimited by the GO statement The GO statement The GO statement must be on its own line Is not a T-SQL command It is a command recognize by the SQL Server command utilities All statements in t he same batch Are parsed together Must pass a validation of the syntax as a unit The statements in the batch are compiled into a single execution plan Runtime errors may result in the partial execution of statements in a batch. Summary If a statement fails at parse-time (syntax error), then nothing runs. If a statement fails at runtime, all statements until the error happened have already run. Each batch is processed independently An error in one batch does not prevent another batch from running.   Statements in Batches  Some commands must be in their own batch: CREATE PROCEDURE CREATE TRIGGER CREATE VIEW you cannot create an object (ex. A table) and use it in the same batch if you want to combine any of these statements with other statements in a single script you will need to break them up using GO statements  variables declared in one batch  do not exist in another if want to run a stored procedure call it’s name on first line or add EXEC to  it’s name at any other line sp_who provides info about current users, sessions and processes.  Local Variables The scope of a lical variable is the current batch DECLARE @<variable name> <variable type> [=<value>] Ex. DECLARE @product varchar(50), @UnitPrice decimal(6,2) A variable cannot be of text, ntext or image data type  Global Variables Represent a special type of variable       Ex. @@ERROR, @@IDENTITY, @@ROWCOUNT, @@SERVERNAME, @@VERSION Variable Assignement The value of a variable will be null until it is initialized Two ways to set the value of a variable Use the select or set statement Ex. DELCARE @price decimal(4,1) = 9.9 \tSET @price = 12.50 \tSET @price=12.50, @quantity=12  SELECT and SET Use SET When you are performing a simple assignment of a variable Where the value is known     Use SELECT           Table Data Type \tDECLARE @MyTableVar table ( \tFN varchar(50), \tLN varchar(50) ) INSERT @MyTableVar(FN,LN) SELECT FirstName, LastName FROM Users Constraints can be used with table variables. DECLARE @myTable TABLE ( \tProdID int Unique \tPRICE money check (price > 500) ) The table definition of a table variable cannot change after the DECLARE statement If you are using a table variable in a join you will need to alias the table in order to execute the query SELECT ProdName, Revenue FROM Products P JOIN @ProductTotals PT \tON P.ProdID = PT.ProdID  '}, {'name': '2019-12-06 -- Common Table Expressions.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'Common Table Expressions (CTE) Example: \tWITH cteEmployees (employee name, Salary DEPID) \tAS ( \t\tSELECT FName + ‘ ‘ + LName, Salary, DepID \t\tFROM Employee)  Windows Functions Different categories of Windows Functions Aggregate Functions: AVG, SUM, COUNT, MIN, MAX, etc. Ranking Functions: RANK, DENSE_RANK, ROW_NUMBER Analytic Functions: LEAD, LAG, etc. SELECT …Function Name(…) OVER(…) FROM Table Name The over clause determines the partitioning and ordering of the result set before the associated window function is applied Example. \tSELECT FName, LName \t\t, ROW_NUMBER () OVER (order by GPA DESC) AS [RANK] \tFROM Student The following example shows using the OVER clause with ROW_NUMBER function to display arrow number for each row within a partition SELECT ROW_NUMBER () OVER (PARTITION BY DepID ORDER BY Salary) AS “Row Number’, FName, LName, DepID, Salary FROM Employee The OVER Clause Defines the partitioning and ordering of the rows (a window) for the above functions to operate on The over clause determines the window Accepts the following 3 args to define a window for the functions to operate on ORDER BY: Defines the logical order of the rows PARTITION BY: divides the result set into the partitions, and the window function is applied to each partition separately If you omit the partition by, the window function will treat the whole result set as a single partition ROWS or RANGE: Limits the rows within the partition by specifying start and end points The Default ROWs and RANGE is UNBOUNDED PRECEDING and CURRENT ROW '}, {'name': '2019-12-20 -- LOGIN and USER definition.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Notes', 'content': 'LOGIN and USER definition CREATE LOGIN login_name {WITH PASSWORD = ‘password’ [MUST_CHANGE]} [, DEFAULT_DATABASE = database] [, CHECK_EXPIRATION = {ON | OFF}] [, CHECK_POLICY = {ON | OFF}] If MUST_CHANGE is specified, CHEKCK_EXPIRATION and CHECK_POLICY must be set to on A combination of CHECK_POLICY OFF and CHECK_EXPIRATION ON is not supported  CREATE USER user_name {FOR LOGIN login_name | WITHOUT LOGIN} ALTER USER user_name WITH NAME = new USERNAME CREATE ROLE Creates a new database role in the current database Roles provide a better way to manage permissions CREATE ROLE role_name EXEC sp_addrolemember role_name, user_name  Permissions Default assumption is that there is no access unless granted    Grant Statement Give a user privileges on an object Grants permissions on a securable to a principal. Granting a permission removes DENY or REVOKE of that permission on the specified securable GRANT {ALL | permission [ (column [,…n]) [,…n] ON securable TO principal [,…n] [WITH GRANT OPTION]  GRANT SELECT ON Customers  TO TESTUSER  GRANT SELECCT (First Name) ON Employee TO buyers  GRANT INSERT ON Orders TO TESTUSER WITH GRANT OPTION  Deny Statement Denies permission to a principal Remove user privileges on an object Prevents the principal from inheriting the permission through its role memberships DENY {ALL | permission [ (column [,…n]) [,…n] ON securable TO principal [,…n] CASCADE CASCADE Indicates that the permission is denied to the specified principal and to all other principals to which the principal had granted the permission Revoke Statement Removes a previously granted or denied permission Removes explicit grant or deny REVOKE [GRANT OPTION FOR] {[ALL] | permission [(column [,…n])][,..n] [ON securable] {TO | FROM| principal [,…n] [CASCADE] GRANT OPTION FOR The ability to grant the specified permission will be revoked. This is required when you are using the CASCADE argument CASCADE The permission that is being revoked is also revoked from other principals to which it has been granted by this principal. REVOKE SELECT ON customers TO test  Index Maintenance Once indexes are created, they can get fragmented over time Fragmentation happens when the logical order of pages in an index don’t match the physical order in the data CREATE [UNIQUE] [CLUSTERED | NONCLUSTERED] INDEX index_name ON Table Name (column [ASC | DESC] [,…n] WITH  \tPAD_INDEX = {ON | OFF} \t| FILLFACTOR = fillfactor  Fill Factor Specifies a percentage that indicates how full the Database Engine should make the leaf level of each index page during index creation or rebuild. Must be an integer of value from 1 to 100 If fillfactor is 100, the database engine creates indexes with leaf pages filled to capacity The setting applies only when an index is created or rebuilt Fill factor Used to avoid page splits (temporarily) Specifies the percentage of free space reserved Is a specification done during the creation of indexes Specifies that a particular amount of space is left on a leaf level pages Applies to the bottom layer (leaf level page) Values From 1-100 CREATE INDEX IX_EMPPLOYEE ON Employee (Organization Level, Organization Node) WITH FILLFACTOR = 80 ALTER INDEX Command All about maintenance and not really about structure ALTER INDEX {<name of index> | ALL} ON <table name> { \tREBUILD \t| DISABLE \t| REORGANIZE } Index REBUILD OPTION The old index is completely thrown away and reconstructed from scratch Every page from both the leaf and not leaf level will be reconstructed as you have defined them The index cannot be used until the rebuild is complete Creation of the index will be a significant load on the system Schedule INDEX REBILDing to run in off hours The Enterprise version of SQL Server includes a special ONLINE version of this option that will keep the index alive and build the new one parallel to the old Index DISABLE option Essentially makes an index unusable Once it’s been disabled it must be rebuilt Not reorganized but rebuild – before it will be active again If you disable the clustered index for your table It has the effect of disabling the table The data will remain but it won’t be able to be accessed Index REORGANIZE option Is an online operation Users can still utilize the index during operation Works only on the leaf level of your index Non-leaf levels of the index go untouched Means you’re not quite getting a full optimization This is the tool you’ll want to use as your regular maintenance option. ALTER INDEX ALL ON <Table Name> REORGANIZE  ALTER INDEX <index name> REBUILD WITH (FILLFACTOR = 20)  CREATE INDEX <index name> on <table name> (column1, column2, column3) WITH (DROP_EXISTING = ON) '}, {'name': 'SQL Injection.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS342/Assignments and Projects/Lecture Presentation', 'content': 'Group Members: Bruk Berhane, Dagmawi Mekonen, Daniel Degabas, Elroe Tadele\tSECTION A  SQL Injection SQL injection, also known as SQLI, is a common attack vector that uses malicious SQL code for backend database manipulation to access information that was not intended to be displayed. It generally allows an attacker to view data that they are not normally able to retrieve. This might include data belonging to other users, or any other data that the application itself is able to access. In many cases, an attacker can modify or delete this data, causing persistent changes to the application\'s content or behavior. Examples of types of SQLI: Retrieving hidden data: modifying an SQL query to return additional results. Let us consider a Grade storing table in database with the following format: StudGrade (studId, courseId, Grade) An application involved with this table will most likely allow the user to enter course Code along with his/her student ID and display Grade. The query it would pass to the Database will probably look like: SELECT Grade FROM StudGrade  WHERE studId=enteredId AND CourseId=enteredCode The enteredId is the student Id that the user had previously entered and so is the CouseId. But what if the user intentionally enters an Id and a code such as enteredId=FD1234 OR 1=1    \tenteredCode=CS342 OR  1=1 The query will now look like: SELECT Grade FROM StudGrade  WHERE studId= ES1234 OR 1=1   AND CourseId= CS342 OR1=1 This will result in displaying the Grades of ALL students for ALL courses since the expression 1=1 is always true. This causes the lack of security of data (grade), which was supposed to be sealed and only revealed to the student with a corresponding student ID. Subverting application logic: changing a query to interfere with the application’s logic. Consider an application that lets users log in with a username and password. If a user submits the username ‘abebe’ and the password ‘abex’, the application checks the credentials by performing the following SQL query on the database:                 SELECT * FROM users WHERE username = \'abebe\' AND password = \'abex\' Here, the attacker can log in as any user without a password by using the comment sequence ’--‘ to remove password check from the WHERE clause of the query. For example, by submitting the username `Kebede`--` and a blank or any password results in the following query: SELECT * FROM users WHERE username = \'Kebede\'--\' AND password = \'\' The part after Kebede will be commented out, and the attacker has successfully logged into Kebede’s account without a password. UNION attacks: retrieving data from different database tables. Consider a database with multiple tables, such as a Product and a User Table. A application involved with this database most likely allows users to log in with their username and password and allows them to purchase available products. A common query run by the database would be:  SELECT name, description FROM products WHERE category = \'Gifts\' But an attacker may input values for category such as: SELECT name, description FROM products WHERE category = \'\'UNION SELECT username, password FROM Users --‘ This will cause the application to return all usernames and passwords along with the names and descriptions of products. and many more… How to prevent SQLI: Parameterized queries or prepared statements. \tA prepared statement is a feature used to execute the same SQL statements repeatedly by leaving certain values unspecified (called parameters) labeled as ‘?’. PreparedStatement statement = connection.prepareStatement("SELECT * FROM products WHERE category = ?"); statement.setString(1, input); (The input received will replace ?) Input Validation. \tWe must always check and test our code to ensure that we handle the input given by the user and restrict potential damage to our database. Some examples could be restricting characters such as `, -, or whitespace characters as a username or a password, or even a search statement. Stored Procedures In addition to their speed and efficiency, stored procedures provide us with a great way of preventing SQL injections. We should always use them to access our database by giving them inputs as parameters and never access our database with a direct query. Can also be referred to as Encapsulation(as of OOP.) Web Application Firewalls. '}, {'name': '2019-11-11.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Class Work/2019-11-11/2019-11-11/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\bin\\Debug\\2019-11-11.exe.config\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\bin\\Debug\\2019-11-11.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\bin\\Debug\\2019-11-11.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\obj\\Debug\\2019-11-11.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\obj\\Debug\\2019-11-11.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-11\\2019-11-11\\obj\\Debug\\2019-11-11.pdb\n'}, {'name': '2019-12-30.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Class Work/2019-12-30/2019-12-30/2019-12-30/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\bin\\Debug\\2019-12-30.exe.config\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\bin\\Debug\\2019-12-30.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\bin\\Debug\\2019-12-30.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\obj\\Debug\\2019-12-30.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\obj\\Debug\\2019-12-30.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-30\\2019-12-30\\2019-12-30\\obj\\Debug\\2019-12-30.pdb\n'}, {'name': '2019-12-02.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Class Work/2019-12-02/2019-12-02/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\bin\\Debug\\2019-12-02.exe.config\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\bin\\Debug\\2019-12-02.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\bin\\Debug\\2019-12-02.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\2019-12-02.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\_2019_12_02.Form1.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\_2019_12_02.Properties.Resources.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\2019-12-02.csproj.GenerateResource.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\2019-12-02.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-12-02\\2019-12-02\\obj\\Debug\\2019-12-02.pdb\n'}, {'name': '2019-11-07.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Class Work/2019-11-07/2019-11-07/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Class Work\\2019-11-07\\2019-11-07\\obj\\Debug\\2019-11-07.csprojAssemblyReference.cache\n'}, {'name': 'AssignmentWPF.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentWPF/AssignmentWPF/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.exe.config\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\MainWindow.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\App.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF_MarkupCompile.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF_MarkupCompile.lref\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\MainWindow.baml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.g.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.Properties.Resources.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.csproj.GenerateResource.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\LoginPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\CreateUserPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\LoginPage.baml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\CreateUserPage.baml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\NotebooksList.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\NotebooksList.baml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AddNotebookWindow.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AddNotebookWindow.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.exe.config\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\bin\\Debug\\AssignmentWPF.pdb\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.csprojAssemblyReference.cache\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AddNotebookWindow.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\CreateUserPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\LoginPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\MainWindow.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\NotebooksList.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\App.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF_MarkupCompile.cache\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF_MarkupCompile.lref\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AddNotebookWindow.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\CreateUserPage.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\LoginPage.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\MainWindow.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\NotebooksList.baml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.g.resources\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.Properties.Resources.resources\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.csproj.GenerateResource.cache\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentWPF\\AssignmentWPF\\obj\\Debug\\AssignmentWPF.pdb\n'}, {'name': 'qualifiers.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'AssignmentNotepad.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.xr.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\resources.pri\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Core\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Core\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.build.appxrecipe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\System.Runtime.dll\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\XamlTypeInfo.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\XamlSaveStateFile.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.csproj.CopyComplete\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\ResourceHandlingTask.state\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\priconfig.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\priconfig.xml.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\unfiltered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\unfiltered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\filtered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\filtered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\excluded.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\excluded.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\resources.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\resources.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\pri.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\pri.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\qualifiers.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\qualifiers.txt.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MultipleQualifiersPerDimensionFound.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\ProjectArchitectures.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\n'}, {'name': 'qualifiers.txt.intermediate', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'MultipleQualifiersPerDimensionFound.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'False'}, {'name': 'ProjectArchitectures.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\AssignmentNotepad.csproj;x64\n'}, {'name': 'qualifiers.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'AssignmentNotepad.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.xr.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\resources.pri\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.build.appxrecipe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\System.Runtime.dll\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlTypeInfo.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlSaveStateFile.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csproj.CopyComplete\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ResourceHandlingTask.state\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MultipleQualifiersPerDimensionFound.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ProjectArchitectures.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\App.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\LoginPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\MainPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\UserCreatePage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.xr.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.pdb\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\System.Runtime.dll\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlTypeInfo.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlSaveStateFile.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csproj.CopyComplete\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.pdb\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\resources.pri\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AppxManifest.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AppxManifest.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.build.appxrecipe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ResourceHandlingTask.state\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MultipleQualifiersPerDimensionFound.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ProjectArchitectures.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NotebooksList.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NoteListPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NoteDetailPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Models\\RenameDialog.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.xbf\n'}, {'name': 'qualifiers.txt.intermediate', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'MultipleQualifiersPerDimensionFound.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'False'}, {'name': 'ProjectArchitectures.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'C:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\AssignmentNotepad.csproj;x86\n'}, {'name': 'Methods for ComboBox.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Assignment', 'content': 'Methods for ComboBox BeginUpdate(): Maintains performance when items are added to the ComboBox one at a time EndUpdate(): Resumes painting the ComboBox after painting is suspended by the  BeginUpdate() method. FindString(string[, int]): returns the index of the first item that starts with the specified string and an optional offset with the passed int. FindStringExact(string[, int]): returns the index of the first item that exactly matches the specified string and an optional offset for where to start with the passed int. GetItemHeight(int): returns the height of an item in the ComboBox at the specified Index ResetText(): Resets its Text property to its default value SelectText(int, int): Selects a range of text in the editable portion of the ComboBox starting form the string index of the first int and ending at the index with the second int. SelectAll(): Selects all text in the editable portion of the ComboBox Methods for ComboBox.Items AddRange(object[]): Adds an array of items to a list of items for a ComboBox Clear(): Removes all items form the ComboBox Add(object): Add an item to the list of items in a ComboBox  RemoveAt(int): Removes an item from the ComboBox at the specified index Contains(object): Determines whether the specified object is within the list of items in the ComboBox IndexOf(object): Gets the index for the specified object within the collection Insert(object, int): Inserts an object into the collection at the specified index. Remove(object): Removes the specified object from the collection RemoveAt(int): Removes an item from the ComboBox at the specified index '}, {'name': '2019-10-17 -- Visual Design and Event.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Notes', 'content': 'Visual Design and Event-Driven Programming In computer programming, event-driven programming is a paradigm in which the flow of the program is determined by events. Events An event can be defined as a type of signal to the program that something has happened The event is generated by external user actions such as mouse movements, mouse clicks and keystrokes, or by the operating system, such as a timer In event-driven programming, code is executed upon activation of events. In an event-driven app, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. An event occurs whenever an event listener detects an event trigger and responds by running a method called an event handler. Event-driven program can be written in any programming language that provides high level abstractions. C# supports event-driven programming normally associated with Microsoft Windows Applications. One normally thinks of events as being generated by GUI Components …..but any object can generate an “event” if it’s programmed to do so…. Generally speaking two logical components are required to implement the even processing model An event producer (publisher) An event consumer (subscriber) The .NET API contains lots of classes that generate different types of events Most are GUI related   Write a series of methods called event handler subroutine. These routines handle the events to which the main program will respond. Many modern day programming environments provide the programmer with event templates, allowing the programmer to focus on writing the event code. Bind event handlers to events so that the correct function is called when the event takes place. Graphical editors combine the first two steps Writing the main loop The function checks for the occurrence of events, and then call the matching event handler to process it If you are developing applications that require speedy deliver to your customers and features like integration with some version control software then simple notepad may not serve your purpose. In such cases you require some Integrated Development Environment (IDE) that allows for Rapid Action Development (RAD). The new Visual Studio.NET is such an IDE VS.NET is a powerful and flexible IDE that makes developing .NET applications a breeze. Visual studio is the easiest way to handle C# code. Input / Output C# programs generally use the input / output services provided by the runtime library of the .NET Framework. Text display on the standard output (usually on the computer screen). WriteLine method Text input from the standard input (usually keyboard) ReadLine method  '}, {'name': '2019-10-21 -- Program Structure.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Notes', 'content': 'C# Program Structure Has: Namespace declaration A class Class methods Class attributes A main method Statements and expressions Comments  '}, {'name': '2019-11-04 -- Properties in C.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Notes', 'content': 'Properties in C# Properties are also known as the smart fields in C# They are the extensions of the C# data fields In a class we declare the data fields as private and will provide the public SET/GET methods to access the data fields The access modifier can be private, public, protected or internal The return type can be any valid C# data type Properties contain Getters (get{}) to retrieve values of underlying fields Setters (set{}) to set the value SYNTAX <access modifier> <return type> <property name> { \tGet \t{} \tSet \t{} } Auto-implemented property Property declaration has been made easy if you don’t want to apply some logic in get or est. The following is an example of an auto implemented property: Public int Length { get; set; } Indexers in C# An indexer allows an instance of a class to be indexed as an array if the user will define an indexer for a class, then the class will behave as a virtual array. Array access operator i.e. [] is used to access the instance of the class will behave like a virtual array. A user can retrieve or set the indexed value without pointing an instance ora type member. Indexers are almost similar to the Properties. The main difference between indexers and Properties is that the accessors of the indexers will take parameters. There are two types of indexers, one and two dimensional Indexers area also known as the Smart Arrays or Parameterized Property in C# This enables the object to be indexed in a similar way to arrays. A set accessor will always assign the value while the get accessor will return the value. “this” keyword is always used to declare an indexer. To define the value being assigned by the set indexer “value” keyword is used An indexer can’t be a static member as it is an instance member of the class.  '}, {'name': '2019-10-14 -- The.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Notes', 'content': 'The .NET Framework Is a framework which provides a common platform to execute or run the applications developed in various programming languages. Microsoft announced the .NET initiative back in July 2000. The main intention was to bridge the gap in interoperability between services of various programming languages. .NET is not a programming language; It supports multiple programming languages for different types of programmers. .NET framework also enables a programmer to create shareable components to be used in a distributed application It is a language independent platform .NET framework supports OOPs model for multiple languages in a manner to allow language interoperability. The framework is designed to fulfil the following objectives: Provide an object-oriented programming environment Provide an environment for developing various types of applications such as Windows-based applications and Web-based applications To ensure that code based on the .NET framework can integrate with any other code The Common Language Specification (CLS) It contains guidelines that language should follow so that they can communicate with other .NET languages. It is also responsible for Type matching. The Framework Base Class Libraries (BCL) A consistent, object-oriented library of prepackaged functionality and applications. The Common Language Runtime (CLR) A language-neutral development and execution environment that provides common runtime for application execution. Common Language Specification CLS performs the following functions: Establishes a framework that helps enable cross-language integration, type safety and high performance code execution. Provides an object-oriented model that supports the complete implementation of many programming languages Defines rules that languages must follow, which helps ensure that objects written in different languages can interact with each other.           The functionality of the base framework classes resides in the namespace called System These class library can be used to develop __________       It provides the following: I/O operations String handling Managing arrays, lists, maps, etc Accessing files and file systems. Accessing the registry Security  Windowing Database management Drawing Exception handling Internet connections Common Language Runtime (CLR) .NET CLR which is responsible for maintaining the execution of all applications developed using the .NET library. CLR provides interoperability between different languages like C#, VB, Visual C++, by providing a common environment for the execution of code written in those languages CLR provides environment for all .NET languages…… In .NET framework’s each compiler converts source code into an intermediate code known as Microsoft Intermediate Language code.   Instead, you compile your code into Common Intermediate language (CIL) code. This code isn’t specific to any operating system and isn’t specific to C#. Obviously, more work is necessary to execute an application. That is the job of a just-in-time (JIT) compiler, which compiles CIL into native code that is specific to the OS and machine architecture being targeted. Only at this ……. When you compile an application, the compiler generates an executable file that the CLR can run. This file is called an assembly. An assembly contains code in an intermediate format called Microsoft intermediate language (MSIL) .. . CLR ensures: A common runtime environment for all .NET languages Uses common type system              C# Microsoft C# is developed by Microsoft Corporation, USA New programming language that runs on the .NET framework C# is simple, modern, type safe, and object oriented C# code is compiled as managed code (Code that targets the CLR) Managed code means IL Combines the best features of Visual Basic, C++ and Java What applications can you write with C#? Windows applications Web applications: ASP.NET, ASP.NET MVC Web services Service: WCF (Windows communication Foundation):- is a framework for building service-oriented applications. Characteristics of C# Simple C# simplifies C++ by eliminating some operations such as ->,::,and pointers C# treats integers and Boolean data types as entirely different types. Consistent C# supports a unified type system which eliminates the problem of varying ranges of integer types. All types are treated as objects. Modern C# supports: Automatic garbage collection Rich intrinsic model for error handling Decimal data types for financial applications Modern approach to debugging Robust security model. Object-oriented C# is truly object-oriented. It supports Encapsulation Inheritance Polymorphism Compatible C# enforces the .NET common language specifications and therefore allows interoperation with other .NET languages. Interoperable C# provides support for using COM objects. Type-safe Type safety promotes robust programs. C# incorporates number of type-safe measures: All dynamically allocated objects and arrays are initialized to zero Use of uninitialized variables produces an error message by the compiler Access to arrays are range checked. C# does not support unsafe casts. C# supports automatic garbage collection. '}, {'name': '2019-11-02.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS223/Lab Work/2019-11-02/2019-11-02/obj/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\bin\\Debug\\2019-11-02.exe.config\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\bin\\Debug\\2019-11-02.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\bin\\Debug\\2019-11-02.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\2019-11-02.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\_2019_11_02.Form1.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\_2019_11_02.Properties.Resources.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\2019-11-02.csproj.GenerateResource.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\2019-11-02.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\2019-11-02.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\_2019_11_02.Form2.resources\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Lab Work\\2019-11-02\\2019-11-02\\obj\\Debug\\_2019_11_02.RegistrationForm.resources\n'}, {'name': '2019-10-25 -- Chapter 2.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Chapter 2 Microprocessor Organization    2.2 General Register Organization Register Memory locations are needed for storing pointer, counter, return address, temporary results, and partial products during multiplication Memory access is the most time consuming operation in a computer More convenient and effective way is to store intermediate values in processor registers Bus organization for 7CPU registers 2MUX: select one of the 7 registers or external data input by SELA and SELB BUS A and BUS B: share the inputs to a common ALU ALU: OPR determine the arithmetic logic or logic microoperation >> The result of the microoperation is available for external data output and also goes into the inputs of all the registers 3x8 Decoder: select the register (by SELD) that receives the information from ALU Binary selector input: R1<- R2 + R3    2.3 Stack Organization Stack or LIFO (Last-in, First-out) A storage device that stores information >> The  item stored last is the first item retrieved Stack Pointer (SP) >> The register that holds the address for the stack >> SP always point at the top item in the stack Two operations of a stack: Insertion and deletion of items >> PUSH: Push-Down = Insertion >> POP: Pop-up = Deletion  '}, {'name': '2019-12-02 -- LODS.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'LODS (Load String) LODS : AL, AX, EAX <- DS : [SI] Loads AL, AX, EAX with data stored at the data segment offset address indexed by SI AL, AX, EAX : SI <- SI +- 1, +- 2, +-4  D = 0\xa0: auto-increment, D = 1 auto-decrement  Arithmetic Instructions Done in 8- or 16-bit operations… Floating point arithmetic done in one of three ways: 80x87 math processor Software routines that emulate the coprocessor Software that converts floating point to integer, executes the instruction and then converts back to floating point.  54FF '}, {'name': '2019-12-16 -- Chapter 6.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Chapter 6 Memory Organization 6-1 Memory Hierarchy Memory hierarchy in a computer system: Main Memory: memory unit that communicates directly with the CPU (RAM) Auxiliary Memory: device that provides a backup storage (Disk Drives) Cache Memory: special very-high-speed memory to increase the processing speed (Cache RAM) Multiprogramming Enable the CPU to process a number of independent programs concurrently Memory Management System: Supervise the flow of information between auxiliary memory and main memory 6-2 Main Memory Bootstrap Loader (Boot loader) A program whose function is to start the computer software operating when power is turned on RAM and ROM Chips Typical RAM chip: >> 128 X 8 RAM: 27 = 128 (7-bit address lines) Typical ROM chip: >> 512 X 8 ROM: 29 = 512 (9-bit address lines) MBR: Master Boot Record  … Memory Address Map Memory Configuration: 512 bytes RAM + 512 bytes of ROM 1 x 512 bytes ROM + 4 x 128 bytes RAM Memory Address Map Address line   9  8 RAM1 0  0 : 0000 – 007F RAM2 0  1 : 0080 – 00FF RAM3 1  0 : 0100 – 017F RAM4 1  1 : 0180 – 01FF \t\t\tAddress line  10 \t\t\t\tRAM select: CS2 \t\t\t\tROM select: CS2 Invert 6-3 Cache Memory Locality of Reference The references to memory tend to be confined within a few localized areas in memory Cache Memory: a fast, small memory Keeping the most frequently accessed instructions and data in the fast cache memory Cache Cache size: usually 256KB (or 512KB) Mapping method: 1) associative, 2) direct, 3) set-associative Replace algorithm: 1) LRU, 2) LFU, 3) FIFO Write policy: 1) Write-through, 2) write-back Least Recently Used, Least Frequently Used, First In First Out Hit Ratio The ration of the number of hits divided by the total CPU references (hits + misses) to memory >> hit: the CPU finds the word in the cache >> miss: the word is not found in the cache (CPU must read main memory) For example, cache memory access time = 100ns, main memory access time 1000ns, hit ration – 0.9 Mapping Function \tSpecification of correspondence between main memory blocks and cache blocks \t\t\tAssociative mapping \t\t\tDirect mapping \t\t\tSet-associative Mapping Associative Mapping Any block location in cache can store any block in memory Most flexible Mapping table is implemented in an associative memory Very expensive Mapping table  Stores both address and the content of the memory word Direct Mapping Each memory block has only one place to load a cache Mapping table is made of RAM instead of CAM (Content Addressable Memory) N-bit memory address consists of 2 parts; k bits of index field and n-k bits of Tag field N-bit addresses are used to access main memory and k-bit index is used to access the cache Operation CPU generates a memory request with (TAG; Index) Access cache using INDEX; (tag; data) Compare TAG and tag If matches => hit Provide cache[index](data) to CPU If not match => miss M [tag; INDEX] <- Cache [INDEX](data) Cache [INDEX] <- (TAG; M [TAG; INDEX]) CPU <- Cache [INDEX](data)  Set-Associative Mapping Each memory block has a set of locations in the cache to load Operation CPU generates a memory address (TAG; INDEX) Access Cache with INDEX, (ache word = (tag 0, data 0); (tag 1, data 1) Compare TAG and tag 0 and then tag 1 If tag i = TAG => Hit, CPU <- data i If tag i != TAG => Miss, Replace either (tag 0, data 0) or (tag 1, data 1), Assume (tag 0, data 0) is selected for replacement, (Why (tag 0, data 0) instead of (tag 1, data 1)?) M [tag 0, INIDEX] <- Cache [INDEX] (data 0) Cache [INDEX] (tag 0, data 0) <- (TAG, M [TAG, INDEX]), CPU <- Cache [INDEX] (data 0) '}, {'name': '2019-12-16 -- notes.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': '8 RAM chips needed \n4 ROM chips needed\n\n6144 bytes\n13-bit address.\neach ram needs 8-bits\n12 11 10 9  8  7 - 0\n\n0-7 for RAM location\n10-8 for differentiating the 8 different RAMs\n0-9 for ROM location\n13-11 for differentiating the 4 different ROMs\n\nRAM1 Range: 0000H - 00FFH\nRAM2 Range: 0100H - 01FFH\nRAM3 Range: 0200H - 02FFH\nRAM4 Range: 0300H - 03FFH\nRAM5 Range: 0400H - 04FFH\nRAM6 Range: 0500H - 05FFH\nRAM7 Range: 0600H - 06FFH\nRAM8 Range: 0700H - 07FFH\n\nROM4 Range 1000H - 1FFFH'}, {'name': '2019-10-14 -- Computer Organization and Assembly Language Programming.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Computer Organization and Assembly Language Programming Architecture and Organizations: Definitions Computer hardware can be seen from three different points of view depending on the interest of the investigator: computer organization, computer design and computer architecture  Computer architecture (conceptual view) Describes major components of the computer User perspective of computer structure and behavior Architectural design deals with component specs (e.g. processor speed, memory capacity) and combining them to build a computer Computer Organization Describes how the computer works How hardware components operate and the way they are connected together to form the computer system Computer design (computer implementation) Describes how the computer is build Once the computer specifications are formulated, this step is performed Determines which hardware should be used and how parts are connected E.g. choosing the ECL (emitter-coupled logic) circuit family for ….  Definition, Evolution and Types of Microprocessors Processors vary in their speed capacity of memory, registers and data bus. An internal clock synchronizes and controls all the processor’s operations. The basic time unit, the clock cycle, is rated in terms of megahertz(millions of cycles per second). A microprocessor is a clock-driven semiconductor device with tens of hundreds of transistors, resistors, capacitors, switches and other digital circuit elements that are miniaturized on a single silicon chip. It can either be LSIC or VLSIC It is considered to be the heart of a computer system as it performs all the tasks. The microprocessor you are using might be a Pentium, AMD, a PowerPC, a Sun-SPARC or any of the many other brands and types of microprocessors. µ-processor can be divided into 3 segments for the sake of clarity: ALU (Arithmetic Logic and Shift Unit), Register array and Control Unit. '}, {'name': '2019-11-07 -- Default Segment and Offset Registers.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Default Segment and Offset Registers The microprocessor has rules that apply to segments whenever memory is addressed These define the segment and offset register combination The code segment register defines the start of the code segment (described in 16 bits) The instruction pointer locates the next instruction within the code segment Another default combination is the stack. Stack data are referenced through the stack  segment at the memory location addressed by either the stack pointer (SP/ESP) or the pointer (BP/EBP) Think of segments as windows that can be moved over any area of memory to access data or code A program can have more than four or six segments, But only access four or six segments at a time. A program placed in memory by DOS is loaded in the TPA at the first available area of memory above drivers and other TPA programs Are is indicated by a free-pointer maintained by DOS Program is handled automatically by the DOS loader… TPA The Transient Program Area(TPA) holds device drivers and operating system …. Segment and Offset Addressing Scheme Allows Relocation Segment plus offset addressing allows DOS programs to be relocated in memory A relocatable program is one that can be executed into any area of memory and executed without change. Relocatable data are data that can be placed n any area of memory and used without any change to the program Because memory is addressed within a segment by an offset address, the memory segment can be moved to any place in the memory system without changing any of the offset addresses. Only the contents of the segment register must be changed to address the program in the new area of memory The windows programs are written assuming that the first 2GB of memory are available for code and data. Addressing Modes Efficient software development for the microprocessor requires a complete familiarity with the addressing modes employed by each instruction. OBJ Explain operation of each data-addressing mode Use data-addressing modes to form assembly language statements Select appropriate addressing mode to accomplish a given task. Detail the difference between addressing memory data using real mode and protected mode operations 2-1 DATA ADDRESSING MODES MOV instruction is a common and flexible instruction. Provides a basis for explanation of data-addressing modes These data-addressing modes are found with all versions of the intel micro processor Except for the scaled-index-addressing mode, found only in 80386 through core2 RIP relative addressing mode is not illustrated Only illustrated in Pentium 4 and above to other 64bit microprocessors. REGISTER\t\t\tMOV Ax, BX IMMEDIATE\t\tMOV CH, 3AH DIRECT\t\t\tMOV [1234H], AX REGISTER INDIRECT\t\tMOV [BX], CL Base-Plus-Index\t\tMOV [BX+SI], BP REGISTER RELATIVE\t\tMOV CL, [BX+4] Base Relative-Plus-Index\tMOV ARRAY[BX+SI], DX SCALED INDEX\t\tMOV [EBX+2 x ESI], AX Important for instructions to use registers that are the same size Never mix an 8-bit with a 16-bit register and it’s not allowed on the processor and produces an error The source register’s contents do not change The destination register’s contents do change The contents of the destination register or destination memory location… Immediate Addressing Implies that data immediately follow the hexadecimal opcode in the memory. Immediate data are constant data Data transferred from a register or memory location are variable data Immediate addressing operations upon a byte or word of data The source data overwrites the destination data for MOV EAX, [124356H] In symbolic assembly language, the symbol # precedes immediate data in some assemblers. Most asseblers don’t use the # symbol, but represent the immediate data as in the mov ax, 3456H The symbolic assembler portrays immediate data in many ways. The letter H appends hexadecimal data. If the data begin with a letter, the assembler requires the data start with a 0. To represent a hexadecimal F2, 0F2H is used in assembly language Decimal data are represented as is and require no special codes or adjustments. Example MOV AL, 100 An ASCII-coded character may be depicted in the immediate form if the ascii data are enclosed in apostrophes. Be careful to use apostrophe (‘) for ASCII data and not the single quotation mark(‘) Binary data are represented if the binary number is followed by the letter B. In some assemblers, the letter Y Each statement in assembly language program consists of four parts or fields. The leftmost field is called the label. Used to store a symbol name for the memory location it represents All labels must begin with a letter or one of the following special characters : @, $, - or ? A label can be any length from 1 to 35 characters The label appears in a program to identify the name of the memory location for storing data and for other purposes. The next field to the right is the opcode field Designed to hold the instruction/opcode The MOV part of the move data instruction is an example of an opcode Right of the opcode field is the operand field Contains information used by the opcode The MOV AL, BL instruction has the opcode MOV and operands AL and BL The comment field, the final field contains comment about the instruction(s). Comments always begin with a semicolon(;) Direct Data Addressing Applied to many instructions in a typical program. Two basic forms of this addressing: Direct addressing, which applies to a MOV between a memory location and AL, AX or EAX Displacement addressing which applies to almost any instruction in the instruction set Address is formed by adding the displacement to the default data segment address or an alternate segment address. '}, {'name': '2019-11-01 -- Data Transfer and Manipulation.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': '2-6 Data Transfer and Manipulation Most computer instrutions can be classified into 2 categories 1) Data transfer, 2) Data manipulation, 3) Program control instructions Data Transfer Instruction Typical data transfer instruction: Load: transfer from memory  to a processor register, usually an AC (mem-read) Store: transfer from a processor register into memory ( memory write) Exchange: swap information between two registers or a register and a memory word Input/Output: transfer data among processor registers and I/O device Push/Pop: transfer data between … 2-8 Reduced Instruction Set Computer Complex Instruction Set Computer Major characteristics 1) A large number of instructions – typically from 100 to 250 2) Some instructions that perform specialized tasks and are used infrequently 3) A large variety of addressing modes – typically from 5 to 20 different modes 4) variable-length instruction formats Instructions that manipulate operands in memory (RISC in register) Reduced Instruction Set Major characteristics 1) relatively few instructions 2) relatively few addressing modes 3) memory access limited to load and store instruction 4) All operations done within the registers of the CPU 5) Fixed-length, easily decoded instruction format 6) Single-cycle instruction execution 7) Hardwired rather than microprogrammed control …. .. ..  Chapter 3 The Intel 8086 Architecture  '}, {'name': '2019-10-21 -- Processor.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Processor Consists of Datapath ALI Registers Control Unit ALU Performs arithmetic and logic instructions Control Unit (CU) Generates the control signals required to execute instructions The implementation of these components varies from one processor to another. Clock Synchronizes processor and bus operations Clock cycle = clock period = 1/clock rate Clock rate = clock frequency = cycles per second 1Hz = 1 cycle/sec \t\t\t1KHz = 103cycles/sec \xa01MHz = 106cycles/sec \t\t1GHz = 109cycles/sec 2GHz clock has a cycle time = 1/(2x109cycles/sec) Memory Ordered sequence of bytes The sequence number is called the memory address Byte addressable memory Each byte has a unique address Supported by almost all processors Physical address space Determined by the address bus width Pentium has a 32-bit address bus Physical address space = 4GB = 232bytes Itanium with a 64-bit address bus can support up to 264 bytes CPU Memory Interface Address bus Memory address is put on the address bus If memory address = m bits then 2m locations are addressed Data Bus: b-bit bi-directional bus Data can be transferred in both directions on the bus    Memory Devices Random-Access Memory (RAM) Usually called the main memory It can be read and written to It does not store information permanently . . . . . . . . ROM (Read-Only Memory) A read-only memory, non-volatile i.e. stores information permanently Has random access of stored information. Used to store the information required to startup the computer Many types: Masked ROM, PROM, EPROM, EEPROM, FLASH FLASH memory can be erased electrically in blocks Cache A very fast type of RAM that is used to store information that is most frequently or recently used by the computer Recent computers have 3-levels of cache; the first is fastest but smallest in size. The second layer is slower but larger in size (external cache). The Need for a Memory Hierarchy Widening (expand) speed gap between CPU and main memory Processor operation takes less than 1ns Main memory requires more than 50ms to access Each instruction involves at least one memory access One memory access to fetch the instruction Additional memory accesses for instructions involving memory data access. Memory bandwidths limit….. …. …. Magnetic Disk Storage Disk Access Time = Seek Time + Rotation Latency + Transfer Time Seek Time: head movement to the desired track (milliseconds) Rotation Latency: disk rotation until desired sector arrives under the head Transfer time: to transfer data '}, {'name': '2019-12-09 -- Always short jumps in 8086 0 80286.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Always short jumps in 8086 0 80286. Limits range to within +127 and -128 bytes from the location following the conditional jump.   Conditional jump instructions test flag bits: Sign (S), zero (z), carry(C) Parity (P), overflow(O) If the condition under test is true, a branch to the label associated with the jump instruction occurs. If false, next sequential step in program executes For example, a JC will jump if the carry bit is set.  Because both signed and unsigned numbers are used in programming. Because the order of these numbers is different, there are two sets of conditional jump instructions for magnitude comparisons. 16- and 32-bit numbers follow the same order as 8-bit numbers, except   Remaining conditional jumps test individual flag bits, such as overflow and parity. Notice that JE has an alternative opcode JZ All instructions have alternates, but many aren’t use— LOOP A combination of a decrement CX and the JNZ conditional jump In 8086 0 80286 LOOP decrements CX. If CX != 0, it jumps to the address indicated by the label If CX becomes -, the next sequential instruction executes In 808386 and above either increments or decrements CX… In 16-bit instruction mode, LOOP uses CX; in the 32-bit mode, LOOP uses ECX. Default isi changed by the LOOPW(using CX) and LOOPD… Conditional LOOPs LOOP instruction also has conditional forms: LOOPE and LOOPNE LOOPE (loop while equal) instruction jumps if CX != 0 while an equal condition exists. Will exit if the condition is not equal or the CX register decrements to 0 LOOPNE (loop while not equal) jumps if CX != 0 while a not-equal condition exists. Will exit loop if the condition is equal or the CX register decrements to 0 '}, {'name': '2019-10-28 -- RPN.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'RPN (Reverse Polish Notation) The common mathematical method of writing arithmetic expressions imposes difficulties when evaluated by a computer A stack organization is very effective for evaluating arithmetic expressions A * B + C * D -> AB + CD  … … 3 Types of CPU Organizations 1) Single AC Organization : ADD X \tAC <- AC + M[X] 2) General Register Organization: ADD R1, R2, R3\t\tR1 <- R2 + R3 3) Stack Organization: PUSH X \t\tTOS <- M[X] The influence of the number of addresses on computer instruction. '}, {'name': '2019-10-18 --  Definition.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302/Notes', 'content': 'Definition, Evolution and Types of Microprocessors  ALU (Arithmetic/Logic Unit): This unit performs such arithmetic operations as addition, subtraction and such logic operations as  AND, OR and exclusive OR Register Array: This area of the mu-processor consists of various registers identified by letters such as B, C, D, E, H, L and Accumulator (there are a maximum of 24 bits on the register) Control Unit It controls the flow of data between the µ-processor and memory and peripherals µ-processor also consists: an  address bus (may be 8, 16, 32 bits wide) that can send data to memory or receive data from memory an RD (read) and WR (write) line to tell the memory whether it wants to set or get the addressed location a clock line that lets a clock pulse sequence the processor a reset line that resets the program counter to zero (or whatever) and restarts execution the system bus is a communication path between the microprocessor & peripherals; it is nothing but a group of wires to carry bits. I/O devices are also known as peripherals i.e., keyboard, switches and Analog-to-digital converters are input devices. Such as LEDs, printer, X—Y plotter, Digital-to-analog converters, video screen are various output devices. Intel 4004 The intel 4004 was a 4-bit central processing unit (CPU) released by intel corporation in 1971 It was the first complete CPU on one chip, and also the first commercially available microprocessor It has 2300 transistors, 640 bytes of addressable memory and 740KHz clock speed The 4001  was a ROM (read-only memory) with four lines of output the 4002 was a RAM (random access memory) with four lines of input / output …. . . . Intel 8080 The first microprocessor to make it into a home computer It was introduced in 1974, it was a complete 8-bit computer on one chip. It was an extended and enhanced variant of the earlier 8008 design, although without binary compatability. The initial specified clock frequency limit was 2MHz wand with common instructions having execution times of 4, 5, 7 10 or 11 cycles this meant a few hundred thousand instructions per second. It has 6000 transistors, 64kb addressable memory and 2MHz of clock rate. . Intel 8085 Still with an 8-bit data bus and 16 bit address bus microprocessor introduced in 1977 It was binary compatible with the more famous intel 8080 but required less supporting  hardware, thus allowing simpler and less expensive microcomputer systems to be build The 8085 had a long life as a controller The processor has seven 8-bit registers named A, B, C,D, E, H and I. where A was the 8-bit accumulator and the other six can be used as independent byte registers…. …. Intel 8086 It has a 16-bit data bus and register size with 29,000 transistors and 20 bit address bus and runs faster. Intel 8088 Has 16-bit registers and an 8-bit data bus and can address up to 1 million bytes of internal memory Although the registers can process two bytes at a time, the data bus can transfer only one byte at a time. This processor runs in what is known as real mode, that is, one program at a time, which actual (“real”) addresses in the segment registers. Intel 80286 Runs faster than the preceding processors, has additional capabilities and c an address up to 16 million bytes. This processor and its successors can operate in real mode or in protected mode which enables an operating system like Windows to perform multitasking (running more than one job concurrently) and to protect them from each other. Intel 80386 Has a 32-bit registers and a 32-bit data bus and can address up to 4 billion bytes of memory. As well as protected mode, the processor supports virtual mode, whereby it can swap portions of memory onto disk; in this way, programs running concurrently have space to operate. It consists of 275,000 transistors as its components. Intel 80486 Also has a 32-bit register and a 32-bit data bus. Also, high speed cache memory connected to the processor bus enables to processor to stores copies of the most recently used instructions and data. The processor can operate faster when using the cache directly without having to access the slower main memory. It is the first processor with built-int math co-processor. Intel Pentium Pentium is a registered trademark that is included n the brand names of many of intel’s x86 compatible microprocessors Has 32-bit registers a 64-bit data bus and separate caches for data and for memory. Its superscalar design enables the processor to decode and execute more than one instruction per clock cycle Intel’s fifth generation microarchitecture, the P5, was first released under the Pentium brand on March22, 1993. The Pentium 44 brand refers to Intel’s line of single-core desktop and laptop central processing units (CPUs) introduced on November 20, 2000. The initial 32-bit x86-64 set and were clocked from 1.3GHz to 2GHz.  Pentium II and III Have a dual independent bus design that provides separate paths to the system cache and to memory. Where the previous processors’ connection to a storage cache on the system board caused delays, these processors are connected to a built-in storage cache by a 64-bit wide bus. Processors up through the 80486 have what is known as a single-stage pipeline, which restricts them to completing one instruction before starting the next Pipelining involves the way a processor divides an instruction into sequential steps…. …. ….   Assembly and Machine Language Machine Language Native to a processor: executed directly by the hardware Instructions consist of binary code (0 and 1s) Assembly Language A programming language that uses symbolic names to represent operations, registers and memory locations. Slightly higher-level language Readability of instructions is better than machine language. One-to-one correspondence with machine language instructions Assemblers translate… … Instructions and Machine Language Each command of a program is called an instruction ( it instructs the computer what to do) Computers only deal with binary data, hence the instructions must be in binary format The set of all instructions  makes up the computer’s machine language. This is also referred to as the instruction set. Instruction Fields Machine language instructions usually are made up of several fields. Each field specifies different information for the computer. The major two fields are: Opcode field which stands for operation code and it specifies the particular operation that is to be performed Each operation has it’s unique opcode Operand …  … … … Mapping Between Assembly Langauge and HLL Translating HLL programs to machine language programs is not a one-to-one mapping A HLL instruction (usually called a statement) will be translated to one or more machine language instructions. Advantages of High-Level Languages Program development is faster High-level statements: fewer instructions to code Program maintenance is faster For the same above reasons Programs are portable Contain few machine dependent details Compiler translates to the target machine language Assembly programs are not portable  Why learn Assembly Language? Accessibility to system hardware. Assembly language is useful for implementing system software Also useful for small embedded system applications Space and time efficiency Understanding sources of program inefficiency Tuning program performance Writing compact code Writing assembly programs…. … … Assembler Is a program that converts source-code programs written in assembly language into object files in machine language. Popular assemblers have emerged over the years for the intel family of processors. Linker and Link Libraries You need a linker program to produce executable files. It contains your program’s object file created by the assembler with ot her object files and link libraries, and produces a single executable program. LINK32.exe is the linker program provided with the MASM distro for linking 32-bit programs. We will also use a link library for input and output. …. … Debugger Allows you to trace the execution of a program Allows you to view code, memory , registers etc. Ex. 32-bit Windows Debugger Editor Literally any text editor  '}, {'name': 'CS302 - Computer Organization and Assembly Language Programming - Winter 2019.docx', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/CS302', 'content': 'COURSE CONTENT  Introduction Revision of Logic Design Architecture and Organizations  Definition, Evolution and Types of Microprocessors and Computers Computer Programming and Software Assembly Language Programming Microprocessor Organization General Register Organization Instruction Formats Addressing Modes Data Transfer and Manipulation Program Control RISC and CISC technologies The Intel 8086 Micro Processor Architecture Basic Computer Organization and Design The Intel 8086 Architecture Intel 8086 CPU Registers Intel 8086 Memory address space Memory Segments Addressing Mode of the Intel 8086 Editing, Assembling and Linking an Assembly Program Introduction to common instructions of the Intel 8086 Instruction statements Editing a Source Program Keywords, Identifiers and Directives Assembling the Source file Linking object files Programming the Intel 8086 with ELASS Assembler Data allocation statements  Control Transfer Interrupts Input/Output  Disk I/O Memory Organization  Memory Hierarchy Main Memory Cache Memory Virtual Memory Memory Management Input-Output Organization  Peripheral Devices Input-Output Interface Modes of Data Transfer Priority Interrupt Direct Memory Access  '}, {'name': 'qualifiers.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'AssignmentNotepad.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.xr.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\resources.pri\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Core\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Core\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\AssignmentNotepad.build.appxrecipe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\System.Runtime.dll\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x64\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\XamlTypeInfo.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\XamlSaveStateFile.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.csproj.CopyComplete\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\ResourceHandlingTask.state\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\priconfig.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\priconfig.xml.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\unfiltered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\unfiltered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\filtered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\filtered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\excluded.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\excluded.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\resources.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\resources.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\pri.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\pri.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\qualifiers.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\qualifiers.txt.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\MultipleQualifiersPerDimensionFound.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\ProjectArchitectures.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x64\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\n'}, {'name': 'qualifiers.txt.intermediate', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'MultipleQualifiersPerDimensionFound.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'False'}, {'name': 'ProjectArchitectures.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x64/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\AssignmentNotepad.csproj;x64\n'}, {'name': 'qualifiers.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'AssignmentNotepad.csproj.FileListAbsolute.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'D:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.xr.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\resources.pri\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AppxManifest.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.build.appxrecipe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\System.Runtime.dll\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.i.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlTypeInfo.g.cs\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xaml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xbf\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlSaveStateFile.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csproj.CopyComplete\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.exe\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.pdb\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ResourceHandlingTask.state\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt.intermediate\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MultipleQualifiersPerDimensionFound.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ProjectArchitectures.txt\nD:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\App.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\LoginPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\MainPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\UserCreatePage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.xr.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.pdb\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\System.Runtime.dll\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Microsoft.UI.Xaml.Markup.winmd\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csprojAssemblyReference.cache\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlTypeInfo.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\App.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\LoginPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MainPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\UserCreatePage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\XamlSaveStateFile.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.csproj.CopyComplete\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\AssignmentNotepad.pdb\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\resources.pri\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AppxManifest.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AppxManifest.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Core\\AssignmentNotepad.exe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\AssignmentNotepad.build.appxrecipe\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ResourceHandlingTask.state\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\priconfig.xml.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\unfiltered.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\filtered.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\excluded.layout.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\resources.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\pri.resfiles.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\qualifiers.txt.intermediate\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\MultipleQualifiersPerDimensionFound.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\ProjectArchitectures.txt\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\.winmd_cache\\$Microsoft.UI.Xaml.Markup.winmd_636885202160000000.json\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NotebooksList.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NotebooksList.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NoteListPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteListPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\NoteDetailPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\NoteDetailPage.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\bin\\x86\\Debug\\Models\\RenameDialog.xbf\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.g.i.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.g.cs\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.xaml\nC:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\obj\\x86\\Debug\\Models\\RenameDialog.xbf\n'}, {'name': 'qualifiers.txt.intermediate', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'AlternateForm=UNPLATED\nScale=200\nTargetSize=24\n'}, {'name': 'MultipleQualifiersPerDimensionFound.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'False'}, {'name': 'ProjectArchitectures.txt', 'path': '/Users/brukb/Documents/Class/Year 2/Term 1/Final Project/AssignmentNotepad/AssignmentNotepad/obj/x86/Debug', 'content': 'C:\\Users\\brukb\\Documents\\Class\\Year 2\\Term 1\\CS223\\Assignment\\AssignmentNotepad\\AssignmentNotepad\\AssignmentNotepad.csproj;x86\n'}, {'name': 'Q1.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS222/Lab', 'content': 'Define a class called Sales, which consists of the following attributes and methods: \t\t\t\tAttributes sales_id (it must be unique) customer_name item_name[] quantity[] price[] \t\t\t\tMethods parameterized constructor displayTotalPrice displayTotalSales displayByCategory  \t Example:\t \t\t\t\t Item Name\t\t\tQuantity\t\t\t\tUnit Price\t\t\t\tTotal Price \t\t\t\t\tFloppy\t\t\t\t\t5\t\t\t\t\t\t\t\t\t3.00\t\t\t\t\t\t  15.0 \t\t\t\t\tFlash Disk\t\t\t\t\t2\t\t\t\t\t\t\t\t450.0\t\t\t\t\t\t950.0 \t\t\t\t\tCD Writer\t\t\t\t\t1\t\t\t\t\t\t\t\t750.0\t\t\t\t\t\t750.0  '}, {'name': 'Q1Ans.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS222/Lab', 'content': 'Solution for Question # 1 import javax.swing.JOptionPane; public class TestSales{ \tpublic static void main(String args[]){ \t\tString name = JOptionPane.showInputDialog("Enter customer name"); \t\tString strAns = JOptionPane.showInputDialog("How many items?"); \t\tint ans = Integer.parseInt(strAns); \t\tString itemname[] = new String[ans]; \t\tint qty[] = new int[ans]; \t\tfloat prc[] = new float[ans]; \t\tfor(int i = 0; i < ans; i++){ \t\t\tString itemName = JOptionPane.showInputDialog("Enter element "+(i+1)); \t\t\titemname[i] = itemName; \t\t\tString itemqty= JOptionPane.showInputDialog("Enter quantity of "+itemName); \t\t\tqty[i] = Integer.parseInt(itemqty); \t\t\tString itemprc= JOptionPane.showInputDialog("Enter price of "+itemName); \t\t\tprc[i] = Float.parseFloat(itemprc); \t\t} \t\tSales s = new Sales(name, itemname, qty, prc); \t\ts.display(); \t\ts.displayByCategory(); \t\ts.totalSales(); \t\tSystem.exit(0); \t} } class Sales{ \tprivate static int sales_id; \tprivate String cust_name; \tprivate String item_name[]; \tprivate int quantity[]; \tprivate float price[]; \tSales(String cust_name, String item_name[], int quantity[], float price[]){ \t\tsales_id++; \t\tthis.cust_name = cust_name; \t\tthis.item_name = item_name; \t\tthis.quantity = quantity; \t\tthis.price = price; \t} \tvoid totalPrice(){ \t\tfloat total_price[] = new float[item_name.length]; \t\tfor(int i = 0; i < item_name.length; i++){ \t\t\ttotal_price[i] = quantity[i]*price[i]; \t\t\tSystem.out.println("Total price of "+item_name[i]+" is "+total_price[i]); \t\t} \t} void display(){ \t\tSystem.out.println(sales_id); \t\tSystem.out.println(cust_name); \t\tint size = item_name.length; \t\tfor(int i = 0; i < size; i++){ \t\t\tSystem.out.println(item_name[i]); \t\t\tSystem.out.println(quantity[i]); \t\t\tSystem.out.println(price[i]); \t\t} \t\ttotalPrice(); \t}\t \tvoid displayByCategory(){ \t\tSystem.out.println("Item Name\\t\\tQty\\t\\tUnit Price\\t\\tTotal Price"); \t\tSystem.out.println("=========\\t\\t===\\t\\t==========\\t\\t==========="); \t\tfor(int i = 0; i < item_name.length; i++){ \t\t\tfloat total_price = quantity[i]*price[i]; System.out.println(item_name[i] + "\\t\\t" + quantity[i] + "\\t\\t" + price[i]+"\\t\\t" + total_price); \t\t} \t}\t \tvoid totalSales(){ \t\tfloat total = 0; \t\tfor(int i = 0; i < item_name.length; i++){ \t\t\ttotal = total + quantity[i]*price[i]; \t\t} \t\tSystem.out.println("Today\'s total sales is "+total); \t} }  '}, {'name': 'Ans.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS222/Lab', 'content': 'Solution  for the above questions a) \tx= 2 num1 = 20 num2 = 15 num3 = 5\t  b)\tDivision by zero error num1 = 20 num2 = 10 num3 = 10   c) \timport javax.swing.JOptionPane; public class ExceptionHandling{ \tpublic static void main(String args[]){ \t\tString strNum; \t\tint num1, num2, num3, x , y; \t\tstrNum = JOptionPane.showInputDialog("Enter the first number"); \t\tnum1 = Integer.parseInt(strNum); \t\tstrNum = JOptionPane.showInputDialog("Enter the second number"); \t\tnum2 = Integer.parseInt(strNum); \t\tstrNum = JOptionPane.showInputDialog("Enter the third number"); \t\tnum3 = Integer.parseInt(strNum); \t\ttry{ \t\t\t\t\tx = num1/(num2 - num3); \t\t\t\t\tSystem.out.println("x= " + x);  \t\t    } \t  catch(ArithmeticException e){ \t\t\tSystem.out.println("Division by zero error"); \t\t} \t\tSystem.out.println("num1 = "+num1); \t\tSystem.out.println("num2 = "+num2); \t\tSystem.out.println("num3 = "+num3); \t\tSystem.exit(0); \t} }     '}, {'name': '2019-06-19 -- Types of Data Models.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS341/Notes', 'content': 'Types of Data Models Hierarchical Data Model Network Data Model Relational Data Model Object-Relational Object-Oriented\n  1st Generation Data Models Hierarchical and Network Model Both kinds of DBMSs were accessible from the programming language (usually Cobol) using a low-level interface. Made some basic tasks controllable, but still complex and time-consuming Creating an application Maintaining the database Tuning the development  In hierarchical data models there is only one point of entry and you work your way to the data you want from root (tree like structure) Network Data Model is considered as a set or collections (nodes) and you can access the data anywhere.  Network Data Model Allows record types to have more than one parent Unlike hierarchical model A network data models sees records as set members Each  set has an owner and one or more members Allows many to many relationships between entities. 2nd Generation Data Models Relation DBMS – 1970 Edgar F. Codd. Data in a database could be represented as a tabular structure Using tables with columns and rows These tables are called relations Tables can be accessed using a high-level non-procedural ( or declarative) language  Instead of writing algorithms to access data The approach only needs a predicate (condition) that identified the desired records or combination of records. In the beginning of the 1980s several Relational DBMS (RDBMS) products emerged E.g. Oracle, Informix, Ingres, and DB2  Database Languages  Data Definition Language (DLL) Used to describe the name the required   Relational Data Model Based on set theory Based on the concept of RELATION Relation: Two dimensional table The database is seen as a collection of tables Stores data in the form of tables -> rows and columns A row in a table is called a tuple -> equivalent to a record Columns are called attribute -> equivalent to fields Data value is the value of the attribute Records are related by the data stored jointly in the fields of records in two tables. Uses Declarative ( as opposed to Procedural) approach to database processing Treats records as a group (set) System Catalog Repository of information (metadata) describing the data of the database. One of the fundamental components od DBMS. Typically stores: Names, types and sizes of data items; Constraints of the data; Names of authorized users;  3rd Generation Data Models Object-Relational Object-relational DBMS (ORDBMS) Includes some object-oriented features and encapsulate these features into RDBMS Extend the capabilities of an RDBMS to include support for richer object structures Object-Oriented OODBMSs Offer persistence to objects, including the object’s associations and methods  Information System (IS) Information system Collection Management Control  Dissemination of information throughout an organization Database is as fundamental component of IS Database development and usage should be viewed from perspective of the wider requirements of the organization System Development Life Cycle The core aspect of software engineering  is the subdivision of the development process into a series of phases or steps Each phase focuses on one aspect of the development Each phase in the life cycle can be checked for correctness before moving on to the next phase The collection of these steps is referred to as the Software Development Life Cycle (SDLC) Software products move through a life cycle repeatedly It is refined or redeveloped Until it is finally retired from use. System Development Phases The pain phases of the system development life cycle are: Requirements gathering Analysis Design Implementation Testing Maintenance Requirements Gathering Produces a statement of user requirements Involves consultation with stakeholders about what they want from a system Analysis Starts with the statement of requirements Produces a system specification The specification is a formal representation of what a system should do Is independent of how it may be realisted Design     Implenetation  The construction of a computer system according to a given design document Involves coding, db construction ,etc. Testing Compares the implemented system against the design documents and requirememnts Produces and acceptance report Maintenance Involves dealing with changes in the requirements or the implementation environment  Requirements Gathering – DB System Requirements gathering involves understanding the proposed system to obtain and document The data and Functional requirements The result of this step is a document that includes: The persistent data that the user wants to store The description of the meaning and the interpretation of the data elements The data description should answer What are the data items What are the properties of the data items What relationships hold between the data items. What constraints apply Different methods are used Interviewing end users individually and in a group Questionnaire survey Direct observation Examining different documents  Forms Reports  Receipts Invoices, etc. Analysis – DB System Analysis produces a conceptual data model A detailed description of the data that will suit user requirements. The conceptual data model Provides a shared, formal representation of what is being communicated between clients and developers Is concerned with the meaning and structure of data It is a formal representation of what data a database should contain and the constraints the data must satisfy. Expressed in terms that are independent of how the model may be implemented. Focuses on questions, “What is required?” not “How is it achieved?” Design & Implementation – DB System Design Database design starts with a conceptual data model and produces a specification of a logical schema The output of this stage is a detailed relational specification the logical schema of all the tables and constraints needed to satisfy the description of the data in the conceptual data model. Implementation The creation or construction of a database according to the specification of the logical schema It is the dependent on the choice of available DBMSs, database tools and operating environment. '}, {'name': 'Assignment 2.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS341', 'content': 'Solutions   It retrieves the data of all actors above the age of 45  Gets the titles of all films the films   Shows all the titles of films released before 2000  Gets the data of all films released in 2012 crossed with all non-American Directors  Gets the data of all movies made in 2012 with their corresponding directors  Gets the names of all films directed by British Directors  Gets the data of all films released before 2000 or after 2010  Gets the data of all films released between 2000 and 2010     σ year=2010(Film) σ(age<30)v(age>39)(Actor) πname(Director) πname(σ nationality=’American’(Director)) πname(σ(nationality=’British’ ^ age>40)(Actor)) πname, title(Actor ⋈(Performance ⋈ Film)) πname(Actor ⋈ (σ character=’Bruce Wayne’(Performance)) πname(Actor ⋈ (σ character=’Bruce Wayne’(Performance ⋈ Film) πactorId, name, nationality, age(Actor ⋈ (Performance ⋈ (σ title=’Inception’(Film)) πActor.name(Actor ⋈ Performance ⋈ Film ⋈ (σ name=’Christopher Nolan’(Film)) πtitle(Film ⋈ (πfilmId(σ name=’Kate Winslet’(Actor) ⋈ Performance) ∩ πfilmId(σ name=’Leonardo DiCaprio’(Actor) ⋈ Performance))) πactorId, name, nationality, age(Actor ⋈actorId=directorId Director) '}, {'name': 'Assignment 1.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS341', 'content': 'Name: Bruk Berhane Asfaw                                                            \tSection: DRB1802 A\t\t\t Title:  Student Registration Application\t\t\t\t\t\t\t\t\t  '}, {'name': '2019-06-24 -- Absolution x.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS301/Notes', 'content': 'Absolution x + xy = x Demogram (x+y)’ = x’y’ F1 = xyz’ The function F1 is equal to 1 only if x=1 and y=1 and z’=1 DeMorgan’s theorems for any number of variables resemble in form of the two variable case can be derived by successive substitutions similar to the method used in the above derivation. '}, {'name': 'CS301 Assignment.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 3/CS301', 'content': 'HiLCoE School of Computer Science & Technology  Logic and Design (CS301) Assignment          Submitted to: Abebe Teferi  Done by:  Bruk Berhane Asfaw    27th March, 2019  '}, {'name': '2019-03-11 -- Chapter 3.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lecture', 'content': 'Chapter 3 - \tThe File System Hierarchical organization of files Contains directories and files Basic commands to list and manipulate files Independent of physical file system organization Always single tree Typical file system types Ext3 (used to be ext2 (latest is ext4)) Reiserfs Vfat [virtual fat] Ntfs (now read & write) [new technology file system]   Common UNIX Directories Bin \tEssential command binaries Boot \tStatic files of the bootloader Dev \tDevice files Etc\tHost-specific system configuration Lib \tEssential shared libraries and kernel modules Media\tmount point for removable media Mnt \tmount poit for temporary file systems Opt\tadd-on application software packages Proc\tdata running on system Root\thome directory for system administrator Sbin\tessential system binaries Srv\tdata for services provided by this system Tmp\tTemporary files Usr\tsecondary hierarchy Var\tvariable data  Directory Terminology Root directory: / Top-most directory in any UNIX file structure Home directory: Directory owned by a user Default location when user logs in Current Dir Default location for working with files Parent directory Directory immediately above the current directory  File Types Regular files Text, data Binaries, executables Links to other files or directories System files Device files: character or block special Networking endpoints: Sockets  FIFO/Pipe Directories Character file Block file '}, {'name': '2019-04-10 -- Chapter 4.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lecture', 'content': 'Chapter 4 What is a shell? the user interface to the operating system first shell: 1972 Thompson most common shells: /bin/csh C shell /bin/tcsh Enhanced C shell /bin/sh The Bourne Shell / POSIX shell /bin/ksh Korn Shell /bin/bash Korn Shell Enhanced  Ways to use the shell Interactively When you log in, you interactively use the shell Scripting A set of shell commands that constitute an executable program  Shell Scripts A shell script is a regular text file that contains shell or UNIX commands Before running it, it must have execute permissions. A script can be invoked as: sh name [arg … ] sh <name [args … ] name [arg …] when a script is run, the kernel determines which shell it is written for by examining the first line of the script if 1st line starts with #!pathname-of-shell, then it invokes pathname and sends the script as an argument to be interpreted if #! Is not defined, the current shell assumes it is a script in its own language this normally leads to problems  Scripting vs. C Programming advantages of shell scripts easy to work with other programs easy to work with files easy to work with strings great for prototyping. No compilation Disadvantages of shell scripts Slower (during execution) Not well suited for algorithms and data structures  The C Shell C-like syntax (uses { }’s) Inadequate for scripting Poor control over file descriptors Difficult quoting “I say \\”hello\\”” doesn’t work Can only trap SIGINT (signal interrupt) Cant mix flow control and commands Survives mostly because of interactive features. Job control Command history Command line editing, with arrow keys (tcsh) The Bourne Shell Slight differences on various systems Evolved into standardized POSIX shell Scripts will also run with ksh, bash Influenced by ALGOL  Simple Commands Simple command: sequence of non-blanks arguments separated by blanks or tabs. 1st argument (numbered zero) usually specifies the name of the command to be executed. Any remaining arguments: Are passed as arguments to that command. Arguments may be file names, pathnames, directories or special options  Complex Commands The shell’s power is in its ability to hook commands together   Parameters A parameter is one of the following: A variable A positional parameter, starting from 1 Special parameter To get the value of a parameter: ${param} Can be part of a word (abc${foo}def) '}, {'name': '2019-03-25 -- Permission Default.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lecture', 'content': 'Permission Default Umask (user mask) Governs default permission for files and directories umask -S in octal form is substracted from: 777 for a directory 666 for a file Special Permissions : SUID   Special Permissions: SGID Similar logic to SUID bit Used for executable files Runs program with a group permission of file, rather than group of invoker Example:  Special Permissions: Sticky Bit Not clearly defined For executable files: Executable is kept in memory even after it ended For directories: Files can only be deleted by the user that created it   File Name Expansion The wildcard characters allow to select files that satisfy a particular name pattern  mkdir -p = creates intermediate directories if necessary (creates any missing directories that are needed) mkdir /home/turing/z036473/csci330/data mkdir csci330/Data  cd /home/turing cd ../../../ cd  '}, {'name': '2019-03-04 -- Lecture notes.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lecture', 'content': 'General Commands Passwd Used to change the login password A very good idea after you get a new account. It’s usually a paranoid program asking your password to have at least 6 chars in the password, at least two alphabetical and one numerical characters. Some other restriction (e.g. dictionary words or previous password similarity) may apply. Depending on a privilege, one can change user’s and group passwords as well as real name, login shell, etc. The password is stored in a shadow file and that file is encrypted in a one-way fashion (meaning the password can only be compared after what the user enters is encrypted and is checked with what is stored for verification). Date (take a guess what it does) Cal Calendar\t\tcal \t(current month) for month \t\tcal 2 2000\t(feb 2000, leap year) for year \t\tcal 2 2100 \t(not a leap year) Clear Clear the screen Alias for it: Ctrl + L Sleep Doing nothing for a certain amount of time Usually used for a  pause in between commands for shell scripts Alias Another name for a command or something Unalias Remove an existing alias Apropos  Search man pages for a substring apropos word equivalent man -k word Exit/ logout Shutdown Shutdown -h now (h is shutdown) Shutdown -r now (r is restart/reboot) Ls Ls -F Append “/” to dirs. And “*” to executables Ls -l Long format Ls  All files except those starting with . Ls -al Ls -lt Sort by modification time (latest, earliest) Ls -ltr Reverse Ls -a All Ls -A All without “.” And “..”. Cat Display and concatenate files Cat file1 [file2] Cat > filename Less  Less (“less is more”) a bit more smart that the more command To display contents of a file To display line numbers: less -N filename To display a prompt: less -P “Press ‘q’ to quit” filename Combine the two: less -NP “Blah-blah-blah” filename Touch By touching a file you either create it if it doesn’t exist (with 0 length) Or you update it’s last modification and access times. There are top options to override the default behavior. Cp Copy files/directories Cp [options] <source> <destination> Cp file1 file2 Cp file1 [file2] … /directory Useful option: -i to prevent overwriting existing files and prompt the user to confirm. Mv Move or rename files/directories Mv <source> <destination> (the source gets removed) Mv file1 dir/ Mv file1 file2 Rename Mv dir1 dir2 rm  removes files and/or directories rm file1 [file2] rm -r dir1 [dir2] rm -r file1 dir1 dir2 file4 script writes a log (a typescript) of whatever happened in the terminal to a file. Script [file] Script All log is saved into a file named typescript Script file All log is saved into a file named file To exit logging, type: exit Find Looks up a file in a directory tree find . -name name find . \\(-name ‘w*’ -or -name “W*” \\) mkdir makes a new directory. mkdir newdir cd change current directory cd /some/othere/dir Absolute path cd subdir Assuming subdir is in the current directory  cd Returns you to your home directory pwd shows the current directory rmdir remove a directory rmdir dirname \t== \trm -r dirname ln  create a symlink ln -s <real-name> <fake-name> chmod change file permissions possible invocations chmod 600 filename -rw------- 1 user group 2785 Feb 8 14:18 filename (a bit not intuitive where 600 comes from) Chmod u+rw filename (the same thing, more readable) For the assignment: chmod u+x myshellscript (makes myshellscript executable) uses octal mode so (600 means 4 = read and 2 = write and 1 = execute, so 600 = 4 + 2 [octal]) grep  searches its input for a pattern. Can be a substring or regex. Echo “blah-foo” | grep blah Wc (search the man for it) A pipe is a method of inter-process communication (IPC) In shells a ‘|’ symbol used It means that the output of one program (on one side of the pipe) serves as an input for the program on the other end. A set of piped commands is often called a pipeline '}, {'name': '2019-03-18 -- Lecture notes.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lecture', 'content': 'User info is stored in file /etc/passwd Userid, username, group, home directory, shell Passwords are listed in a separate file: /etc/shadow group info is stored in file /etc/group Groupid, group name Additional group members To find out group information, use the command named: groups user-id Example: \tGroups z036473  Security Levels There are three levels of security in UNIX: System, directory and file  System security Controlled by the superuser Directory and file Controlled by the user who owns them  Access Permission Types There are 3 general types of access permissions: r\tread\t\tview contents (open read) or list directory contents w\twrite\t\tchange file contents or change directory contents x\texecute\t\trun executable file or make it current directory access files in it -\tpermission denied\tjust doesn’t get any permissions  Checking Permissions To check the permissions of an existing file or an existing directory, use the command: ls -l  Changing permissions Symbolic mode Chmod u=rwx,g+w,o-w memo.doc ** you can concatenate users and groups and the like like: chmod u-x,go+x memo.doc Octal Mode User\t\tgroup\t\tothers r w x\t\tr – x\t\tr – x  4 2 1 \t\t4 – 1\t\t4 – 1    '}, {'name': '2019-03-05 -- Lecture notes.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lab', 'content': 'The UNIX File System There are three types of files Ordinary files Directory files Device files  Ordinary files Also known as regular files. It contains only data as a stream of characters Normal text file Directory files A file containing the names of other files and directories Contains inode (file number and the file name) Device files Represents all hardware devices The kernel does the mapping between the file name and the device What is in a file name? (What can be in a file name) Alphanumeric characters The period The hyphen The underscore Never use a hyphen at the beginning of a file name. When you use a file with a command it might be confused for a parameter  /etc – stores configuration files /usr – store user files /dev – contains all device files /tmp – temporary files /var – the variable part of the system Lib – contains all library files '}, {'name': 'Assignment Answers.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS262/Lab', 'content': 'Answers  X10$   and   1010   Line 2: invalid comparison for $ppprunning in the while loop Line 4&5: invalid syntax and commands. Line 6: invalid way to define choice Line 8: ‘$’ symbol is missing Line 15: invalid way to finish a switch case  sentinel = y while test sentinel == “y”  do \techo “Please enter the two numbers: “ \tread x y \techo ($x + $y)/2 \techo “Do you want to average another pair?” \tread ch \tcase $choice in \t\ty*|Y*) sentinel = y \t\t;; \t\t*) sentinel = n \t\t;; \tesac \tdone  su G [esc] :%s/edit/editorial/g  Normal mode: enabled by default when you open the editor. Normally accessible by [esc] Visual mode: you enter this mode by clicking ‘v’ Insert mode: you enter this mode by clicking ‘i’       #!/bin/bash echo “Enter the string to be searched:” read pname; if test -z “$pname”; then \techo “You’ve not entered the string”; exit 1; else \techo “Enter the file to be used:” read flname if (!test -n “$flname”); then \t\techo “You’ve not entered the file name”; exit 2; else \t\tgrep “$pname” “$flname” || echo “Can’t find the pattern” fi \tfi  chmod 511 lab makepart '}, {'name': 'Assignment2.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS222', 'content': 'Assignment I (C++ Function basic) You are requested to develop a contact book application. The program keeps the following information about a contact: Full name, telephone number and email. It allows adding, editing, removing, searching and displaying contact info. The program may also display all contacts details sorted by name. Assume array structure to hold the data. Break down the problem at least in to modules (functions) and draw the structure chart The problem is break down as shown below:                                                Data Structure Two dimensional character array to stores contact names:          \t\t\tname[1000][80] Two Dimensional character array to store phone:\t\t\t\t\tphone[1000][10] Two Dimensional character array to store email::\t\t\t\t\temail[1000][80]\t\t\t Interfaces int main() the main function int Welcome()  welcome function int Menu()\t the main menu which contains Edit, view , exit menu items int EditSubMenu() edit sub menu which contains add, edit, remove, back to main menu, exit menu item int ViewSubMenu() view sub menu which contains view by search and view all items void AddContact(name[][80], char phone[][10], char email[][80], int &n) void GetContactInfo(char prompt[]) accepts name, email or phone void Add(char name[][80], char phone[][10], char email[][80], int & n , const char newName[], const char newPhone, const char newEmail[]) void Sort(char name[][80], char phone[][10], char email[][80], int  n, int byWhat)  byWhat=0 means by “name” 1 means by ‘phone’ void SorByName(char name[][80], char phone[][10], char email[][80], int  n) void SorByPhone(char name[][80], char phone[][10], char email[][80], int  n) void EditContact(char name[][80], char phone[][10], char email[][80], int  n) void Search(const char name[][80], int  n, int byWhat, int searchResultIdx[], int & noResults)  searchResultIdx-index of found contacts void SearchByName(const char name[][80], int  n, int searchResultIdx[], int & noResults) void SearchByPhone(const char phone[][10], int  n, int searchResultIdx[], int & noResults) void Edit(char name[][80], char phone[][10], char email[][80],int contactToEditIdx) void RemoveContact(char name[][80], char phone[][10], char email[][80], int & n) int void Renove(char name[][80], char phone[][10], char email[][80], int & n, int contactToRemoveIdx) void ViewBySearch(const char name[][80], const char phone[][10], const char email[][80], int n) void Display(const char name[][80], const char phone[][10], const char email[][80], int n, const int resultToDisplay[], int noResult) void Display(const char name[][80], const char phone[][10], const char email[][80], int n) Question Implement the complete program. '}, {'name': 'Bruk - Case Study Answers - 2019-02-27.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': '2019/02/27 Answers to Case Study  The info shared between Japan’s tech and Ethiopia’s MoH was sufficient enough to get the service running. The technology being used was what was required and agreed on There were some problems in the processes because they did not implement the backup generators to support the EMR systems during blackouts but that is not solely a process problem. There were some big flaws in objectives because what was expected was a relevant and informative system while what had really happened was that the system had double entrees and other problems leading to data inaccuracy. The skills of the staff that use it was severely limited because they hadn’t received proper training and they did not even truly understand the use of the system in their day to day life. Truthfully, there were no real changes required in the management systems but the minster the fact that the minister that had initiated the program had resigned did not help the MoH to improve the System and help people better. There were lots of other wastages like time, the doctors took more time inputting the patient information because of the lack of training so there was more time wasted. Also the cost of fuel was a big problem for the hospitals because they didn’t have proper funding to support their new system and so on.  There were some Hard-Soft gaps because Doctors didn’t understand the use of the program, etc. and there were also numerous hard gaps like the miscommunications between the Ethiopian and Japanese developers. There were definitely large North-South gaps because the system was designed with a developed country in mind, but the power outages weren’t planned very well and weren’t given the proper budgeting and the likes. There was one major Organizational-Personal gap because although this project was well meaning, the Minster only implemented this for the sake of his reputation. If it had been implemented with the thoughts of the people in mind, the program might have been a lot more successful and ultimately a lot of the problems could have been avoided. There were some Public-Private gaps because although the overall objective was completed, partial fault to the inaccuracy of the data is the fact that the doctors and nurses were maybe too lazy or busy to properly fill out the information.  By Bruk Berhane Asfaw '}, {'name': '2019-02-19 -- Lecture notes and Exercise.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': 'ICT4D projects form socio-technical point of view Socio-technical approach is to aim to recognize the interaction between people and technology in society. In other words, this approach puts importance on both the social aspects and technical aspects. e.g. In the case of the M-Health project - There might be problems with Network coverage - People might not trust the validity of the information. * In order for a project to be successful, you need to list out the technical and social aspect.  Exercise Identify social and technical POV in  Agriculture: for example 8028 hotline service in Ethiopia Health: for example hospital management system Education: for example online education. Agriculture: Technical:  (previously listed) Network Issues Access to mobile phones nevertheless smart ones.  Social: Awareness Willingness to rely on the service Manageability  Health: Technical: Most hospital’s might not have a reliable power source Hospitals might not have enough tech for the system. Reliable personnel are needed to manage and maintain these systems. Social: People might get overwhelmed and not manage the system properly Hospitals might not want to integrate the digital services in lieu of written  Education: Technical:  People might not have access to computers Internet coverage is very limited outside of urban areas The right tools and finance for using these services dependably might not be available Social: People might not be able to properly navigate the online world Depending on how the online education is produced, people might not have a proper environment to ask questions and socialize Users might not get the proper attention they need to understand the lessons.  What is Success and failure of ICT4D projects We can divide failure into two parts Total failure: the initiative was never implemented or it was implemented but immediately abandoned Partial failure: major goals for the initiative were not attained and/or there were significant undesirable outcomes. Success: most stakeholder groups attained their major goals….  What is ITPOSMO Checklist? The ITPOSMO checklist is a useful tool to since evaluate and measure the gaps from the point of the socio-technical perspective it covers both technical and the other dimensions such as information, technology, process, objectives/value, skills/staffs, etc… Dimensions to find out the Design – Reality gaps I\tInformation (Type of info. To be shared between Govt. & Stakeholders). T\tTechnology (Technology being used & actually required) P\tProcesses. (Strategy & Techniques being used for implementation) O\tObjectives (Intended results/objectives and expected values) S\tSkills. (Staffing numbers & skill levels, Nature of staff’s employment) M\tManagement systems (Changes required in management & admin) O\tOthers ( Time, cost , and other factors required for success)  Why do ICT4D projects fail? In the following sections, factors that can cause failures of ict4d projects presented from three angles. Techno-centric approach Design-reality gap Idolize approach  Techno-centric approach One of the major reasons for ict4d projects failure is a techno-centric approach The weakness of the technology-centered approach is explained in terms of IS projects generally and ict4d projects particularly For instance, typical failures are such that a new IS is developed and works properly, but notbody uses it and that an IS is developed to solve targeted problem, but the problem do not exist in fact ( Curtis and Cuham 2005) Secondly, when it comes to the IS projects in developing countries especially, there are more importance on the factors, such as political, etc…  '}, {'name': '2019-03-12 -- Discussion Answers For IS.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': 'How can you differentiate information society? Information society is different from Agrarian society in that it focuses on information such that it is a driving factor in the day to day life of humans. What is an Information Society characterized by? In my opinion, an Information society is characterized by the need for gathering data and also for people to be able to process this said data into information and share it to other people and for it to be beneficiary to society in some way.  -By Bruk Berhane Asfaw Biniyam  Assefa '}, {'name': '2019-04-10 -- E.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': 'E-Government It is transformation of goernemt to provide Efficient Convenient  Transparent services to citizens and businesses through ICT Most important aspect is how it brings citizens and businesses closer to their governments. G2C C2G G2B B2G G2E G2G G2N N2G  Citizen Centric E-Goverrnance In the format convenient to them At the place of their choiuce Transparency about the decision making process Simplification of procedures of information   Social Media and Activism social media defined as websites and applications that enable users to create/share content and network. Social media activists use this tools to disseminate… Social Media: “ is a term used to describe a variety of web-based platforms, applications and technologies that enable people to socially interact with one another online” Activism “the policy or action of using strong campaigning to bring about a political or social change”  Advantages and Disadvantages of Social Media for Society From 2006 onwa  Disadvantages of Social Media for Society Cyberbullying – according to report published by pew.center.org most of the children have become victims of cyberbullying over the past Hacking – personal data and privacy can easily be hacked and shared on the internet. Addiction – the addictive part of the social media is bad and can disturb personal lives as well Teenagers are most affected by it cause they get involved more extensively It can waste individual time Fraud and scams. Cheating and Relationship Issues – Most of the people have used the social media platform to propose and marry each other. However, after some time they turn to be wrong with their decision and part ways. Similarly, couples have cheated each other by showing fake feelings and incorrect information. Health Issues Social Media causes death – Not just by using it but by following the stunts and other crazy things that impressionable people may witness. For example bikes doing unnecessary stunts, people doing the jump over trains and other life threatening things. Glamorizes drugs and alcohol – one of the disadvantages is that social media is the part people start to follow others who are wealthy or ddrug addicted and share their views and videos on the web Advantages of Social Media for the Society Connectivity Education – Social media has lots of benefits for students and teachers. Help – you cha share your rissues with the community and get help and guidelines.. whether it is helping in term of money or term of advice. Information and Updates – the main advantage of social media is that you update yourself on the latest happenings of the world. Most of the time TV and print medias are often biased and don’t always show the truth. Promotion – Whether you have an offline business or online you can promote your business to the largest audience. Honorable Cause – Social media can also be used to promote NGOs, social welfare activities etc. Awareness – Also helps to create awareness and innovate the way people live. Help Governments and Agencies Fight Crime Improves Business Reputation Helping Build Communities Advantages of Activism Rise public opinion Form an action plan Measuring impact digitally You can measure the number of people supporting the cause by signing the petition through platforms like change.org. these forms of activism are symbolic and persuasive and thus less harmful Online crowd-funding Disadvantages of Activism Misunderstanding of Key Issue Sometimes the issue to be resolved gets lost in the process of campaigning. Like the ALS Ice bucket challenge Unwanted Arguments A big problem is people arguing about arbitrary issues while the main problem is still at large Lack of Anonymity There is no absolute protection even after being anonymous on the web. Political Hindrances The power of Social Media Social media gave the power to voice their anger at what they deemed to be the 1% The organizers of the movement use the popularity of social media to advertise… '}, {'name': '2019-02-27 -- Lecture notes and part of the Case Study answers.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': 'What is ITPOSMO Check-list? The ITPOSMO checklist is a useful tool to evaluate and measure gaps from the point of the socio-technical perspective it covers both technical and the other dimensions such as information, technology, process, objectives/value, skills/staffs, management/structure, and other resources (time/money) and outside world. I\tInformation (type of info to be shared between govt. and stakeholders) T\tTechnology (tech being used and actually required) P\tprocesses. (strategy & techniques being sued for implementation) O\tObjectives.(intended results/objectives and expected values) S\tSkills. (staffing numbers and skill slevels, nature of staff’s employment) M\tManagement systems O\tOthers (time, cost, etc…) Design and Reality Gap Hard – Soft Gaps Hard, rational thinking \t\t\t\tSoft thinking  Organizational – Personal gaps North – South Gap (country gap) North (Developed Countries) \t\t\tSouth (Developing Countries) Public – Private Gap  The info shared between Japan’s tech and Ethiopia’s MoH was sufficient enough to get the service running. The technology being used was what was required and agreed on There were some problems in the processes because they did not implement the backup generators to support the EMR systems during blackouts but that is not solely a process problem. There were some big flaws in objectives because what was expected was a relevant and informative system while what had really happened was that the system had double entrees and other problems leading to data inaccuracy. The skills of the staff that use it was severely limited because they hadn’t received proper training and they did not even truly understand the use of the system in their day to day life. Truthfully, there were no real changes required in the management systems but the minster the fact that the minister that had initiated the program had resigned did not help the MoH to improve the System and help people better. There were lots of other wastages like time, the doctors took more time inputting the patient information because of the lack of training so there was more time wasted. Also the cost of fuel was a big problem for the hospitals because they didn’t have proper funding to support their new system and so on. '}, {'name': '2019-03-12 --  Lecture notes - Information Society.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 2/CS216', 'content': 'Information Society Rapid development and expansion of information technologies has created favorable conditions for the emergence of global society in the latter decade. New information technologies penetrate not only into business, work environment, life of state and world…   Main features of this society Information infrastructure – telecommunications, computer networks, databases, information systems and others The ability/proficiency of society’s members to use measurements of ….  Factors of the information society’s development Development of information technologies Use of computer equipment and computer literacy Investments in the development of information systems/structures Measures gathering information – large amounts of information The process of innovative production Ability to access global information and etc..  Agrarian Society An agrarian society is a social system where there is a concentration of most Active population, Production and Capital is in agriculture and extraction from nature… Historical Developments of agricultural society Hunting, fishing, and gathering societies (1st stage) Horticultural Societies (2nd stage) People began to plant and cultivate crops Major shift from subsistence economy to economic surplus Agrarian Society (3rd stage) The agrarian society was characterized by: Drastic increase in the efficiency of production as a result of  Better technology… … As a result of this there was: A rapid growth of: technology, trade, reading and writing, science, art Accumulation of wealth that created social inequalities … What is the role of information in agrarian society Information gathering and processing became increasingly important For the functioning of the state, … Information about kinship and property became an important part of culture. Regarding innovation in information processing: The early writing developed from pictures this was a part of religious information system. Industrial society is a social system whose mode of production focuses primarily on Finished goods with the aid of machinery. It is a social system where there is concentration of most active population, production, and capital in Industry and manufacturing. Important events (basic  is humans being replaced by machines) [you know this from history class (The Industrial Revolution)] … … The effects of the above changes include: The dominance of the modern factory in the economy Shift or production from home to factory, from rural to urban Explosive growth in productivity and surplus production Drastic transformation of the agricultural societies within a few decades because of: large scale energy production ….. Labor transformation due to industrialization: Human labor was freed from agricultural production…. Major features of social Life: Greater social inequalities Extremes of wealth and poverty became quite common Large scale unemployment and social unrest that resulted in: Initially, the destruction of machinery by workers to save the manual labor… Industrialization promoted: Formal education (expanded dramatically), Growth of science and knowledge, mass media, culture of democracy Freedom of information became one of the corner stones of democracy in industrial society. Citizens being able to exchange information freely Because of the spread of literacy and scientific knowledge, modern information became a new collective property. Information society is a social system in which the economy is highly dependent on Gathering  Processing and Transmission of information.  Information Society An information society is a society where the creation, distribution, use, integration and manipulation of information is a significant economic, political, and cultural activity. Its main drivers are digital information and communication technologies, which have resulted in an information explosion and are profoundly changing all aspects of social organization, including the economy. Key concepts: information, ICT as a driver. Information society is a social system in which the economy is highly dependent on Gathering, Processing and  Transmission of information Is characterized by: High degree of computerization, Large volume of electronic data transmission, Economic profile dominated by industries and occupations related to information production and distribution. '}, {'name': 'Assignment 1.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211 Lab', 'content': 'Assignment 1  mkdir Africa Africa/W_Africa Africa/N_Africa Africa/E_Africa Africa/S_Africa;  cd Africa/W_Africa;  mkdir Senegal Senegal/Daka Mali Mali/Bamako The\\ Gambia The\\ Gambia/Banjul Guinea-Bissau Guinea-Bissau/Bissau Guinea-Conakry Guinea-Conakry/Conakry Sierra-Leone Sierra-Leone/Free\\ town Liberia Liberia/Monrovia Nigeria Nigeria/Abuja Ghana Ghana/Accra;  cd ../N_Africa;  mkdir Tunisia Tunisia/Tunis Algeria Algeria/Algiers Libya Libya/Tripoli Morocco Morocco/Rabat; cd ../E_Africa; mkdir Ethiopia Ethiopia/Addis\\ Abeba Sudan Sudan/Khartoum South\\ Sudan South\\ Sudan/Juba Egypt Egypt/Cairo Somalia Somalia/Mogadishu Eritrea Eritrea/Asmara Djibouti Djibouti/Djibouti Kenya Kenya/Nairobi Yemen Yemen/Sana Uganda Uganda/Kampala Rwanda Rwanda/Kigali; cd ../S_Africa;  mkdir South\\ Africa South\\ Africa/Johannesburg Namibia Namibia\\Windhoek Botswana Botswana/Gaborone Zimbabwe Zimbabwe/Harare Mozambique Mozambique/Maputo Lesotho Lesotho/Maseru Swaziland Swaziland/Mbabane         Done By: Bruk Berhane Asfaw '}, {'name': 'Worksheet 3.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS221 Lab', 'content': 'Worksheet 3(C++ basics) Objectives To understand the different parts of C++ programs To understand the different basic concepts such as identifier, variables, and constant. Theoretical questions Identify and discuss the different parts of C++ program. What is the role of the return type in the main function? Give and describe the two ways of commenting your program. State the rules for naming identifiers. Describe the difference between variable and constant identifiers. State and describe the different classes of data types, List and describe the standard or fundamental data types. What do we mean by wrapping signed or unsigned integers? List and describe the different ways of coding a constant. Give examples for the different types of literal constants. What do we mean by character (escape) sequence? Give at least five examples. For the following lists of identifiers, state weather they are valid or not. For those which are not, state why they are invalid. Amount\t\tstages\t\tA1234\t\twhile\t\t_1234 Do\t\t\t$xy_1\t\ta_&*bc4\tnewVal\tABCD 1m123\t\tcout\t\tnetPay\t\t?book\t\tinvoices cal rang\t\tIF\t\t_123\t\tReturn\t\tstruct exit\t\t\tcontinue\telse\t\tfor\t\ttype date\t\tbreak\t\ttime\t\ttemp\t\tNB_STUD cin\t\t\tlong\t\tdouble\t\tsingle\t\ttry From the above list of identifiers which ones are known to be C++ keywords? Suggest appropriate data type for the following data Price of an item Number of students in a given class/section Area of rectangle Gender of a person Letter grade of students Give appropriate declaration for the following cases For the number of students in a class(noStudents) and their age(age) Salary of an employee(salary) and their service year(serviceYears) Cost and price of an item. Both initialized to zero. A constant called GRAVITY and PI that has a value of 9.8 and 3.14 respectively. Identify errors in the following declarations and give the correct declaration a, b, c; char m.n k; integer x, y unsigned long x, int y; signed double height=34.5; float length==3.45; int first= 37, last=48, new=59, old=70; int distance= 22 meters, const NB_EMPS=123;  Lab practice Open the code programParts.cpp from lab3 folder and identify the different parts of the C++ program. Open the code declaration.cpp from lab3 folder. The code contains variable declaration errors. Identify the problems and make corrections. Open the code constant.cpp from lab3 folder. The code contains undeclared constants` CELCIUSFACTOR having a value of 1.8 and ABSOLUTEZERO having a value of 273.15. CELCIUSFACTOR is to be declared as defined constant and ABSOLUTEZERO is to be declared as memory constant. One step a head A modern shopkeeper wanted a program that calculates the selling price of an item given its cost. He expected to gain 15% of the cost as a profit. The shopkeeper expected you to write this program. Identify the input. Identify the output. Identify the process to change the input to the output (the solution). Write the algorithm. Translate its algorithm to a C++ code. The profit factor is to be literal constant. Modify the above program so that the profit factor is to be declared as defined constant. Modify the above program so that the profit factor is to be declared as memory constant.  '}, {'name': 'Class Schedule Application and RESTful server Proposal.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211/Idea for Class Schedule and Implementation', 'content': 'Class Schedule Application and RESTful server Proposal  Introduction: The idea of this Class Schedule Application and REST API is to provide students with the ability to use their mobile devices or personal computers to reference their class schedule and also to use their mobile devices to provide identification on school sites. Background:  The idea for this application came to be from the realization that since the students already use their mobile electronic devices for lots of day to day activities it would be more efficient cost wise and material wise to digitize schedules and identification cards. Along with other functionalities that could be extended from analog logging on paper to digital distribution to students. Use of creating API: The use of creating the RESTful API is so that other students can create client applications to parse  through the data it can dispense like class schedules on a student to student basis. How the API server would work: The API server would work by having access to the students database and vending read only information on the student like their schedules or their picture so that the client application can display this information for reference either for the student or whomever needs this information officially. Additionally, the server would be able to dynamically change the schedules and distribute the new schedule as deemed necessary.  What is required of the school: There are two courses of action the school can take to aid in developing this API server. The first being providing read-only access the students and schedules database along with a RESTful API server. And the second is simply providing read-only access  of the databases to me (Bruk Berhane) and letting me create the RESTful API that will be used by clients and can be audited and edited as seen fit. Function outline for Client-Side Application: The client side application will have the ability to be made by any person who is willing to interact with the API server and prepare an application using it. Generally speaking, a client-side application will access the API server and request data from it like a certain person’s identity and schedule to aid the student. Conclusion: To conclude this proposal, the creation of this API can aid in promoting creativity and creative application making in our environment. Along with that, it would motivate students to come up with more creative ideas to have more of the school interconnected digitally and to increase learning efficiency, productivity, and connectivity.  '}, {'name': 'Requirements for Class Schedule Application.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211/Idea for Class Schedule and Implementation', 'content': 'What is required for Class Schedule application to run:  Read-Only access to the Students database so that it can know which student is using the Class Schedule and tailor the schedule to said student. Access to a schedule database. If this database does not exist, it can be created and shared for Read-Only access. An online domain so the backend server so Class Schedule can compile queries from the first two databases and send them to client devices (this can be on HiLCoE’s own servers or alternately it can also be hosted by third parties as long as the Databases can be accessed online). '}, {'name': 'CS211-ICT Fundamentals-Course Outline.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211/CS211-Winter-2018', 'content': ' COURSE CONTENT  Introduction Overview of ICT and CS Knowledge Hierarchy/Management Components of Information Systems  Applications of ICT/IS/Computers Information Systems in Business Why Study Computer Science?*  Computer Hardware,  Software, and Computer Architecture Evolution of Computers Computer Generations Milestones in Computer HW & SW Development Types and Characteristics of Computers* Components of the Computer System Software Generations System Software and Application Software Microcomputer Architecture  Data Representation and Computer Arithmetic Number Systems and Conversion Binary Arithmetic And Complements Fixed and Floating Point Numbers Units of Data Representation and Coding Methods Boolean Algebra and Logic Circuits*   Programming Languages and the Programming Process Instructions and Programs Steps in Computer Program Development Types of Programming Languages Introduction to the Basic Functions of Operating Systems*  Business Process Engineering Steps in Software Systems Development Phases of SDLC SDLC Models  Data Communications and Computer Networks Data Transmission Types of Networks Network Topologies Networking Components (Devices, Software, …) Distributed Systems* Introduction to Computer & Information Security Concepts*    Internet, Intranet and Extranet History How it works Electronic Communication  tools (e-services) Services (www, Telnet, email, ftp, IRC, internet telephony, …) Cloud Computing*  Future Trends in ICT [Reading Assignment] Artificial Intelligence Ubiquitous (Pervasive) Computing Grid Computing Internet of Things '}, {'name': 'Notes on Network Models.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211', 'content': 'Network Models  Network Models: OSI is developed by ISO Standards are essential for Interoperability (IP Address is added at the Network Layer) (Port numbers are added at the Transport Layer) IP Address + Port Number = Socket  Ethernet (example network protocol of hardware layer) CSMA/CD: Carrier Sense, Multiple Access, Collision Detect Since Ethernet was designed to be on shared media, with 2 or more users, and the “more” part can be very big (thus: “Multiple Access”) you have to listen to see if anyone else is talking before you talk (Carrier Sense) and if you and someone else start talking at the same time, notice it (Collision Detect), say “excuse me” stop and try again later. A polite free for all with rules.  Default port for http is 80.  Computer Networks A computer network is an interconnection of various computer systems located a t different places. Two or more computers and other peripheral or data communication devices linked together. The computer that provides resources to other computers on a network is known as a server. In a network individual computers, which access shared network resources, are known as workstations or terminals or clients.  Why networking? Remote access to resources – Efficiency through accessibility – Resource Sharing Reduction of data duplication – Data kept on a Server Communication (Collaboration) – people can work  together in ways not previously possible (ARPANET) Advanced Research Projects Agency Network Saving money (peer to peer) Price / performance rate of a number of linked small computer is better than few large ones. For example: Mainframes which are only about ten times the power of a personal computer, cost about a thousand times more. Better to get cheaper machines and network them. Scalability – ability to grow and shrink the computer set-up We can add more servers during peak hours, for example. The Costs (Drawbacks) of Networking Network hardware, software, and setup costs Hardware and software management and administration costs Undesirable sharing Illegal or undesirable sharing Data security concerns How can we be sure valuable information is safe in a networked environment?  Different ways of classifying networks There is no generally accepted taxonomy into which all computers fit, but the following dimensions standout as important: By Network Topologies By Transmission Technologies By Scale (size) By Management method Depending on one’s perspective, we can classify networks in different ways Based on transmission media: Wired (UTP, coaxial cables, fiber-optic cables) and wireless Based on network size: LAN and WAN Based on network topologies: Bus, Ring, Star, Mesh/Complete Topology Concerns Performance issues Reliability, ability to recover through/after failure of one or more nodes    Star Topology A number of workstations (nodes) are directly linked to a central node called a hub. Any communication between stations on a star LAN must pass through the central node.  Advantages of Star Offers flexibility of adding or removing of workstations from the network Easy to add or remove machines since we only need to hook them up to a central hub Breakdown of one station does not affect any other device on the network. It is robust since no machine depends on other machines. Major Disadvantage of Star Failure of the central node disables communication throughout the whole network.. Ring Topology Each node is connected to a nearby station on a point to point basis so that the entire system is in the form of a ring. Data is transmitted mostly in one direction only or in recent designs both directions. Thus the data packets circulate along the ring in either clockwise or anti-clockwise. Token Ring (protocol) A ring topology is easy to install, but uses expensive parts. It is easy to add a new machine. Token Ring Networks Bus Topology Uses ethernet protocol All workstations are connected to a single communication line called bus. There is no central node like in star topology. All nodes compete for the use of the BUS. If one station of the topology fails it does not affect the entire system. The disadvantage  if bus is that any break in the bus may break the entire network. All  messages are transmitted to the whole network. A bus topology is also easy and low cost to install. Mesh/Complete Topology A complete topology is very robust, since every machine has connection to every other machine, so doesn’t depend on other machines.  Hybrid topology  Network Types based on Management Method Two major types of networks Peer-to-Peer Client/Server (also called server-based)  Network Types based on Scale (Size) There is no hard and fast rule on how big a network is before it becomes a LAN, MAN or WAN E.g. a LAN is usually identified by either all machines using the same LAN protocol (e.g. IEEE 802.3 Ethernet), or they are machines communicating within the same organization or within 1km area Based on Scale: PAN (Personal Area Network) Square meter (around a person) LAN (Local Area Network) 10m, 100m, 1km (room, building, campus) MAN (Metropolitan area network) 10km (city) WAN (Wide Area Network) 100km, 1,000km (country, continent) Note: NIC = Network Interface Card  Repeaters Hub Hubs are actually Multiport repeaters Hubs are layer 1 devices (Physical layer devices) In many cases, the difference between the two devices is the number of ports that each proives. Bridges: Store frames from one LAN and sends to another The function of the bridge is to make intelligent decisions about whether or net to pass signals on to the next segment of a network Slows down transmission speed and has a potential for bottlenecks Do not forward noise and collision Uses computer MAC addresses (Physical addresses) Bridges are layer 2 devices (Data link layer devices) Switch Is more intelligent than a hub A switch is sometimes described as a multiport bridge While a typical bridge may have just two ports linking two network segments, a switch can have multiple ports depending on how many network segments are to be linked Bridges and switches are PnP (plug and play devices) while routers are configurable. '}, {'name': 'Notes on Network Models (AutoRecovered).docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211', 'content': 'Network Models  Network Models: OSI is developed by ISO Standards are essential for Interoperability (IP Address is added at the Network Layer) (Port numbers are added at the Transport Layer) IP Address + Port Number = Socket  Ethernet (example network protocol of hardware layer) CSMA/CD: Carrier Sense, Multiple Access, Collision Detect Since Ethernet was designed to be on shared media, with 2 or more users, and the “more” part can be very big (thus: “Multiple Access”) you have to listen to see if anyone else is talking before you talk (Carrier Sense) and if you and someone else start talking at the same time, notice it (Collision Detect), say “excuse me” stop and try again later. A polite free for all with rules.  Default port for http is 80.  Computer Networks A computer network is an interconnection of various computer systems located a t different places. Two or more computers and other peripheral or data communication devices linked together. The computer that provides resources to other computers on a network is known as a server. In a network individual computers, which access shared network resources, are known as workstations or terminals or clients.  Why networking? Remote access to resources – Efficiency through accessibility – Resource Sharing Reduction of data duplication – Data kept on a Server Communication (Collaboration) – people can work  together in ways not previously possible (ARPANET) Advanced Research Projects Agency Network Saving money (peer to peer) Price / performance rate of a number of linked small computer is better than few large ones. For example: Mainframes which are only about ten times the power of a personal computer, cost about a thousand times more. Better to get cheaper machines and network them. Scalability – ability to grow and shrink the computer set-up We can add more servers during peak hours, for example. The Costs (Drawbacks) of Networking Network hardware, software, and setup costs Hardware and software management and administration costs Undesirable sharing Illegal or undesirable sharing Data security concerns How can we be sure valuable information is safe in a networked environment?  Different ways of classifying networks There is no generally accepted taxonomy into which all computers fit, but the following dimensions standout as important: By Network Topologies By Transmission Technologies By Scale (size) By Management method Depending on one’s perspective, we can classify networks in different ways Based on transmission media: Wired (UTP, coaxial cables, fiber-optic cables) and wireless Based on network size: LAN and WAN Based on network topologies: Bus, Ring, Star, Mesh/Complete Topology Concerns Performance issues Reliability, ability to recover through/after failure of one or more nodes    Star Topology A number of workstations (nodes) are directly linked to a central node called a hub. Any communication between stations on a star LAN must pass through the central node.  Advantages of Star Offers flexibility of adding or removing of workstations from the network Easy to add or remove machines since we only need to hook them up to a central hub Breakdown of one station does not affect any other device on the network. It is robust since no machine depends on other machines. Major Disadvantage of Star Failure of the central node disables communication throughout the whole network.. Ring Topology Each node is connected to a nearby station on a point to point basis so that the entire system is in the form of a ring. Data is transmitted mostly in one direction only or in recent designs both directions. Thus the data packets circulate along the ring in either clockwise or anti-clockwise. Token Ring (protocol) A ring topology is easy to install, but uses expensive parts. It is easy to add a new machine. Token Ring Networks Bus Topology Uses ethernet protocol All workstations are connected to a single communication line called bus. There is no central node like in star topology. All nodes compete for the use of the BUS. If one station of the topology fails it does not affect the entire system. The disadvantage  if bus is that any break in the bus may break the entire network. All  messages are transmitted to the whole network. A bus topology is also easy and low cost to install. Mesh/Complete Topology A complete topology is very robust, since every machine has connection to every other machine, so doesn’t depend on other machines.  Hybrid topology  Network Types based on Management Method Two major types of networks Peer-to-Peer Client/Server (also called server-based)  Network Types based on Scale (Size) There is no hard and fast rule on how big a network is before it becomes a LAN, MAN or WAN E.g. a LAN is usually identified by either all machines using the same LAN protocol (e.g. IEEE 802.3 Ethernet), or they are machines communicating within the same organization or within 1km area Based on Scale: PAN (Personal Area Network) Square meter (around a person) LAN (Local Area Network) 10m, 100m, 1km (room, building, campus) MAN (Metropolitan area network) 10km (city) WAN (Wide Area Network) 100km, 1,000km (country, continent) Note: NIC = Network Interface Card  Repeaters Hub Hubs are actually Multiport repeaters Hubs are layer 1 devices (Physical layer devices) In many cases, the difference between the two devices is the number of ports that each proives. Bridges: Store frames from one LAN and sends to another The function of the bridge is to make intelligent decisions about whether or net to pass signals on to the next segment of a network Slows down transmission speed and has a potential for bottlenecks Do not forward noise and collision Uses computer MAC addresses (Physical addresses) Bridges are layer 2 devices (Data link layer devices) Switch Is more intelligent than a hub A switch is sometimes described as a multiport bridge While a typical bridge may have just two ports linking two network segments, a switch can have multiple ports depending on how many network segments are to be linked Bridges and switches are PnP (plug and play devices) while routers are configurable. Gateway Stores and sends packets to different networks. E.g. from a LAN to a public network. It is located at network perimeters. (ex. SMS gateway) Router Routers are responsible for routing data packets from source to destination within the LAN, and for providing connectivity to the WAN. In order to provide these services the router must be connected to the LAN and WAN. A router at the perimeter of a network, connecting  a LAN to a WAN, is essentially a gateway. Routers are Layer 3, network layer devices (uses IP address also called logical address) Metropolitan Area Networks (MANs) Similar technology to a LAN but over a wider area (e.g. city) Utilize microwave, optical fiber, other wires; Wired or wireless Different communicating LANs in a city can form MAN. MAN is a type of WAN Domain Name System Is used to translate hostnames to IP addresses DNS is an example of a distributed database If that server can resolve the hostname, it does so If not, that server asks another domain name server '}, {'name': 'Software Development Life Cycle Models.docx', 'path': '/Users/brukb/Documents/Class/Year 1/Term 1/CS211', 'content': 'Software Development Life Cycle Models There are six basic Software Development Life Cycle Methodologies/Models. These are: Agile Development Lean Development Waterfall Development Iterative Development Spiral Development DevOps   Agile Development This model helps teams identify and address small problems on projects before they evolve into more significant problems, all the while engaging business stakeholders and get their feedback throughout the process. In this model “fast failing” is a good thing. The approach produces ongoing release cycles, each featuring small, incremental changes from the previous release while being tested at each release. Lean Development This model is inspired by lean manufacturing practices and principles. The seven lean principles  are: eliminate waste, amplify learning, decide as late as possible, deliver as fast as possible, empower the team, build integrity in, and see the whole. This process is about working only on what must be worked on at the time, there is no room for multitasking. Waterfall Development Considered the oldest of SDLC methodologies and a very straightforward approach: finish one phase, then move to the next. No going back. Each stage relies on information from the previous stage and has its own project plan. The downside of this model is rigidity because early delays can throw off the entire project timeline. With little room for revisions once a stage is completed, problems can’t be fixed until you get to the maintenance stage. This model doesn’t work if flexibility is needed or if the project is long term and ongoing. Iterative Development In this model, instead of starting with fully know requirements, project teams implement a set of software requirements, then test, evaluate and pinpoint more requirements. A new version of the software is produced at each phase or iteration. And that sequence is repeated until the complete system is ready. Spiral Development This methodology is one of the most flexible ones. The spiral model takes a cue from the iterative model and its repetition. The project passes through four phases: planning, risk analysis, engineering, and evaluation) over and over in a “spiral” until it’s done, allowing for multiple rounds of refinement. This model is normally used for large projects because it enables development teams to build a highly customized product and incorporate user feedback early on in the project. DevOps This is a relatively new model to the SDLC. It emerged from two trends: the application of Agile and Lean methodologies to operations work, and the general shift in business toward seeing the value of collaboration between development and operations staff a tall stages. In a DevOps model, Developers and Operations teams work together closely, and sometimes as one team, to speed up innovation and the deployment of higher-quality and more reliable software products and functionalities. Updates to products are small but frequent. Hallmarks of the DevOps model are discipline, continuous feedback, process improvement and automation of manual development processes.  CASE Tools In a very broad sense, case tools are tools and methods used to support engineering approach to systems development at all stages of the process. There are three general types of CASE tools. Upper, Lower and Integrated. Upper CASE tools are tools used to support the upper processes of software development like Design and analysis. An example of an upper CASE tool could be graphing software to map out the design of an application. Lower CASE tools are used to support for the later stages of the SDLC like code generation and testing. A sufficient example being a debugger. And an integrated CASE tool supports the SDLC at both the early stages and the late stages. '}]
